/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/apopups-gallery/Gallery.js":
/*!*****************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Gallery.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Gallery; });
/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hammerjs */ "../../node_modules/apopups-gallery/node_modules/hammerjs/hammer.js");
/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hammerjs__WEBPACK_IMPORTED_MODULE_0__);


/**
 * 配置
 */
const DEFAULT_OPTIONS = {
    /**
     * 最大缩放比例
     */
    maxScale: 3,
    /**
     * 最小缩放比例
     */
    minScale: 0,
    /**
     * 下拉关闭的触发的阀值，百分比，0-1
     */
    closeThreshold: 0.1
};
/**
 * 常量
 */
const AXIS_SYMBOL = ['x', 'y'];

/**
 * gallery类，主要手势处理，数值计算，以及动作限制，不做DOM操作。
 */
class Gallery {
    /**
     * @param {Element} touchArea 
     * @param {Object} options 自定义配置
     */
    constructor(touchArea, options) {
        /**
         * 触摸交互区域
         */
        this.touchArea = touchArea;
        /**
         * 配置参数
         */
        this.options = {};
        Object.assign(this.options, DEFAULT_OPTIONS, options);
        /**
         * 实例化手势计算器
         */
        this.calculator = new GestureCalculator(this.touchArea, this.options);

        this.init();
    }

    init() {
        if (this.manager) {
            return;
        }
        this.manager = new hammerjs__WEBPACK_IMPORTED_MODULE_0___default.a.Manager(this.touchArea);
        this.manager.add(new hammerjs__WEBPACK_IMPORTED_MODULE_0___default.a.Pan({ threshold: 0, pointers: 0 }));
        this.manager.add(new hammerjs__WEBPACK_IMPORTED_MODULE_0___default.a.Pinch({ threshold: 0.05 })).recognizeWith(this.manager.get('pan'));
        this.manager.add(new hammerjs__WEBPACK_IMPORTED_MODULE_0___default.a.Swipe()).recognizeWith(this.manager.get('pan'));
        this.manager.add(new hammerjs__WEBPACK_IMPORTED_MODULE_0___default.a.Tap({ event: 'doubletap', taps: 2 }));
    }

    /**
     * 绑定手势事件
     * @param {String} eventName 需要绑定的事件名称
     * @param {Function} callback 
     */
    on(eventName, callback) {
        let proxy = this.events[eventName];
        if (!proxy) {
            throw Error(`unknown event '${eventName}'`);
        }
        this.events.callbacks[eventName] = callback;
        proxy.call(this);
    }

    updateImageIndex(newIndex) {
        this.calculator.curImgIndex = newIndex;
    }

    setImagesNumber(number) {
        this.calculator.imagesNumber = number;
        this.calculator.initValues();
    }

    trigger(eventName, e) {
        let eventFunc = this.events.functions[eventName];
        let callback = this.events.callbacks[eventName];
        return eventFunc.call(this, result => {
            e.preventDefault();
            return callback({ result, e });
        }, e);
    }

    correct() {
        return {
            correct: this.calculator.correct().correct,
            scale: this.calculator.get('scale'),
            slide: this.calculator.get('slide')
        };
    }

    resetGallery() {
        this.calculator.initValues();
        this.calculator.curImgIndex = 0;
    }
}

const fn = Gallery.prototype;

/**
 * events
 */
fn.events = {
    /**
     * 滑动事件
     * @param {Function} callback {distance:[x,y], org} 
     * org 是 hammerjs的事件对象
     */
    slide() {
        this.manager.on('panstart panmove', e => {
            this.trigger('slide', e);
        });
    },
    /**
     * 捏的手势事件
     * @param {Function} callback 
     */
    pinch() {
        this.manager.on('pinchstart pinchmove', e => {
            this.trigger('pinch', e);
        });
    },
    swipe() {
        this.manager.on('swipe', e => {
            this.trigger('swipe', e);
        });
    },
    doubletap() {
        this.manager.on('doubletap', e => {
            this.trigger('doubletap', e);
        });
    },
    actionend() {
        this.manager.on('pinchcancel pinchend', e => {
            this.trigger('actionend', e);
        });
        this.manager.on('pancancel panend', e => {
            if (!this.trigger('close', e)) {
                return;
            }
            this.trigger('actionend', e);
        });
    },
    close() {}
};

/**
 * 事件所对应的处理方法。分开的好处是可以随意触发对应的事件方法。
 */
fn.events.functions = {};
Object.assign(fn.events.functions, {
    /**
     * 滑动事件方法
     * @param {Object} callback 
     * @param {Object} e 
     */
    slide(callback, e) {
        if (this.isLock) {
            return;
        }
        const isStart = e.type === 'panstart';
        this.calculator.slide(e.deltaX, e.deltaY, isStart);
        callback({ slide: this.calculator.get('slide'), bound: this.calculator.checkBound(null, null, true) });
    },
    /**
     * 捏的事件方法
     * @param {Object} callback 
     * @param {Object} e 
     */
    pinch(callback, e) {
        const isStart = e.type === 'pinchstart';
        if (isStart) {
            this.calculator.position(e.center);
        }
        this.calculator.zoom(Number.parseFloat(e.scale), isStart);
        callback({ lastActionData: this.calculator.getLastActionData('scale'), scale: this.calculator.get('scale'),
            slide: this.calculator.get('slide') });
    },
    /**
     * 快速滑动的事件方法
     * @param {Object} callback 
     * @param {Object} e 
     */
    swipe(callback, e) {
        let slideStartDataX = this.calculator.getLastActionData('slide').x;
        let boundX = this.calculator.checkBound(null, { x: slideStartDataX + e.deltaX, y: 0 }, true).x;
        if (!this.calculator.switchThreshold(e.deltaX) && boundX.isOver && Math.abs(e.deltaX) <= Math.abs(boundX.number)) {
            let direction;
            if (e.direction === hammerjs__WEBPACK_IMPORTED_MODULE_0___default.a.DIRECTION_LEFT) {
                direction = 'next';
            } else if (e.direction === hammerjs__WEBPACK_IMPORTED_MODULE_0___default.a.DIRECTION_RIGHT) {
                direction = 'previous';
            }
            let switchObj = this.calculator.switch(direction || false, direction);
            callback({ switchObj }, e);
            return;
        }
        let deltaTime = e.deltaTime;
        let scale = this.calculator.get('scale');
        if (deltaTime > 200 || scale <= 1) {
            return;
        }
        this.calculator.swipe(e.deltaX, e.deltaY, deltaTime);
        callback({ slide: this.calculator.get('slide') }, e);
    },
    /**
     * 双击的事件方法
     * @param {Object} callback 
     * @param {Object} e 
     */
    doubletap(callback, e) {
        const scale = this.calculator.get('scale');
        if (scale < 3) {
            this.calculator.position(e.center);
            this.calculator.zoom(3 - scale + 1, true);
            this.calculator.correct(3);
        } else {
            this.calculator.initValues();
        }
        callback({ scale: this.calculator.get('scale'), slide: this.calculator.get('slide') });
    },
    /**
     * 持续动作结束的事件方法，适用于滑动，捏动作的结束事件。
     * @param {Object} callback 
     * @param {Object} e 
     */
    actionend(callback, e) {
        if (this.isLock) {
            return;
        }
        this.isLock = true;
        setTimeout(() => {
            this.isLock = false;
        }, 200);
        if (this.calculator.getLastActionData('scale') <= 1 && this.calculator.get('scale') < 1) {
            this.events.callbacks['close']({ close: true });
            this.resetGallery();
            return;
        }
        const before = this.calculator.get('slide').slice();
        const result = this.calculator.correct();
        let switchObj = { switch: false };
        if ((e.type === 'pancancel' || e.type === 'panend') && e.pointers.length == 1 && result.bound && result.bound.x.isOver && Math.abs(e.deltaX) <= Math.abs(result.bound.x.number)) {
            let direction = before.x > 0 ? 'previous' : 'next';
            let isSwitch = this.calculator.switchThreshold(result.bound.x.number);
            switchObj = this.calculator.switch(isSwitch, direction);
        }
        callback({
            slide: this.calculator.get('slide'),
            scale: this.calculator.get('scale'),
            correct: result.correct,
            switchObj
        });
    },
    /**
     * 相册关闭事件方法
     * @param {Object} callback 
     * @param {Object} e  
     */
    close(callback, e) {
        const slideY = this.calculator.get('slide').y;
        const bound = this.calculator.checkBound(null, null, true).y;
        const touchAreaSize = this.calculator.getTouchAreaSize().y || window.innerHeight;
        const closeThreshold = this.options.closeThreshold;
        if (this.calculator.get('scale') >= 1 && bound.isOver && Math.abs(bound.number) >= touchAreaSize * closeThreshold && slideY > 0 && e.deltaY <= Math.abs(bound.number)) {
            callback({ close: true });
            this.resetGallery();
            return false;
        }
        return true;
    }
});
/**
 * 用于存放所有事件的回调函数
 */
fn.events.callbacks = {};

/**
 * 计算器父类。
 */
class Calculator {

    constructor(touchArea, options) {
        this.touchArea = touchArea;
        //用户配置信息
        this.options = options;
        //图片的当前索引
        this.curImgIndex = 0;
        //图片总数
        this.imagesNumber = 0;

        //计算数据
        this.datas = {
            slide: {
                x: 0,
                y: 0,
                slice: function () {
                    return { x: this.x, y: this.y };
                },
                init: function () {
                    this.x = 0;
                    this.y = 0;
                }
            },
            scale: 1,
            lastScale: 1,
            lastActionDatas: {
                slide: {
                    x: 0,
                    y: 0
                },
                scale: 1
            },
            track: null
        };
    }

    /**
     * 舍入，保留指定的位数，默认保留2位小数
     * @param {Number} num 
     * @param {Number} scale 保留的位数
     */
    static round(num, scale) {
        num = num instanceof Number ? val : Number.parseFloat(num);
        if (Number.isNaN(num)) {
            throw new Error(`${num} 不是有效的数值！`);
        }
        return Number.parseFloat(num.toFixed(scale || 2));
    }

    /**
     * 获取手势触碰区域的尺寸
     */
    getTouchAreaSize() {
        const size = {};
        size.x = this.touchArea.clientWidth;
        size.y = this.touchArea.clientHeight;
        return size;
    }

    /**
     * 获取图片当前的尺寸
     * @param {Number} zoomScale 需要缩放的比例 
     * @returns {Array} 返回一个数组，{x, y}
     */
    getImgSize(zoomScale) {
        const size = {};
        const el = this.touchArea.childNodes[this.curImgIndex];
        size.x = Number.parseInt(el.clientWidth * (zoomScale || 1));
        size.y = Number.parseInt(el.clientHeight * (zoomScale || 1));
        return size;
    }

    /**
     * 检查是否已经越过了边界
     * @param {Number} zoomScale 
     * @param {Array} slideArray 在还没有更新dom之前的计算
     * @param {Boolean} noDifference 是否需要减去图片与边界的差值
     */
    checkBound(zoomScale, slideArray, noDifference) {
        const slide = slideArray || this.get('slide');
        /**
         * 越过的数值
         */
        let resultObj = {};
        this.eachAxis(axis => {
            let zoomUp = this.getBound(axis, zoomScale);
            let slideVal = Math.abs(slide[axis]);
            let overNum = zoomUp - slideVal;
            overNum = noDifference ? overNum - this.getImageSizeDiffVal(axis, zoomScale) : overNum;
            resultObj[axis] = {
                isOver: overNum < 0,
                number: overNum
            };
        });
        return resultObj;
    }

    /**
     * 取得指定轴的边界值
     * @param {String} axis 
     * @param {Number} zoomScale 
     */
    getBound(axis, zoomScale) {
        const touchAreaSize = this.getTouchAreaSize();
        const imgSize = this.getImgSize(zoomScale);
        let elSize = imgSize[axis];
        let zoomUp = (elSize - touchAreaSize[axis]) / 2;
        return zoomUp;
    }

    /**
     * 纠正图片脱离窗口边界的情况
     * Correct the image's departure from the window boundary
     */
    correct(scaleV) {
        let scale = this.get('scale');

        /**
         * 如果scale小于1那么slide和scale的值变为初始化值
         * if the scale < 1, then the values of slide&scale become initialization values
         */
        if (scale <= 1) {
            const bound = this.checkBound();
            this.initValues();
            return { correct: true, bound };
        }

        /**
         * 如果图片缩放大于3，那么就还原为3
         */
        let flag = false;
        let maxScale = this.options.maxScale;
        const zoomScale = scale > maxScale ? maxScale / scale : null;
        if (scale > maxScale) {
            this.zoom(zoomScale, true);
            flag = true;
        }

        /**
         * 纠正图片的位置
         */
        const slide = this.get('slide');
        const checked = this.checkBound(scaleV || zoomScale);
        const newSlideVal = { x: 0, y: 0 };
        const resultArray = this.eachAxis(axis => {
            const result = checked[axis];
            if (!result.isOver || result.isOver && result.number === 0) {
                return false;
            }
            const diffVal = this.getImageSizeDiffVal(axis, scaleV || zoomScale);
            newSlideVal[axis] = slide[axis] < 0 ? Math.abs(result.number) + diffVal : result.number + Math.abs(diffVal);
            return true;
        });
        this.addSlide(newSlideVal.x, newSlideVal.y);
        flag = flag || resultArray.x || resultArray.y;
        return { correct: flag, bound: checked };
    }

    eachAxis(func) {
        const result = {};
        AXIS_SYMBOL.forEach((axis, index) => {
            result[axis] = func(axis, index);
        });
        return result;
    }

    /**
     * 计算图片与边界的差值
     * @param {String} axis 
     * @param {Number} zoomScale 
     */
    getImageSizeDiffVal(axis, zoomScale) {
        axis = axis || 'x';
        const imgSize = this.getImgSize(zoomScale);
        const touchAreaSize = this.getTouchAreaSize();
        return imgSize[axis] > touchAreaSize[axis] ? 0 : (imgSize[axis] - touchAreaSize[axis]) / 2;
    }
}

Object.assign(Calculator.prototype, {
    initValues() {
        this.datas.scale = 1;
        this.datas.lastScale = 1;
        this.datas.slide.init();
    },
    addSlide(x, y) {
        x = x || 0;
        y = y || 0;
        this.datas.slide.x = Calculator.round(this.datas.slide.x + x);
        this.datas.slide.y = Calculator.round(this.datas.slide.y + y);
    },
    addScale(scale) {
        this.datas.lastScale = this.datas.scale;
        this.datas.scale = Calculator.round(this.datas.scale + scale);
    },
    get(key) {
        let result = this.datas[key];
        console.assert(result, `没有找到 ${key} 相关的数据！`);
        return result;
    },
    setLastActionData(key, val) {
        let check = this.datas.lastActionDatas[key];
        if (!check) {
            console.error(`设置 ${key} 为 ${val} 失败！不存在 ${key} 相关的动作数据!`);
            return;
        }
        this.datas.lastActionDatas[key] = val;
    },
    getLastActionData(key) {
        let result = this.datas.lastActionDatas[key];
        console.assert(result, `没有找到 ${key} 相关的动作数据数据！`);
        return result;
    }
});

/**
 * pinch相关的计算方法
 */
class GestureCalculator extends Calculator {

    constructor(touchArea, options) {
        super(touchArea, options);
        //触碰点位置信息
        this.positionVal = { x: 0, y: 0 };
        //每次移动的开始值
        this.slideStartVal = { x: 0, y: 0 };
        //每次缩放的开始值
        this.pinchStartVal = 0;
        //用于锁定切换
        this.switchLocked = false;
    }

    /**
     * 滑动计算方法
     * @param {*} x 
     * @param {*} y 
     * @param {*} isStart 
     */
    slide(x, y, isStart) {
        let args = arguments;
        let distance = [0, 0];
        if (isStart) {
            this.setLastActionData('slide', this.get('slide').slice());
        }
        this.eachAxis((axis, index) => {
            let startVal = this.slideStartVal[axis];
            let newVal = args[index];
            if (isStart) {
                distance[index] = startVal == newVal || Math.abs(newVal) > Math.abs(startVal) ? newVal - startVal : newVal;
            } else {
                distance[index] = newVal - startVal;
            }
        });
        this.slideStartVal = { x, y };
        return this.addSlide.apply(this, distance);
    }

    /**
     * 定位当前手指触碰的位置，用于在缩放时候始终保以手指所在位置来缩放
     * @param {*} center 
     */
    position(center) {
        this.eachAxis(axis => {
            const taSize = this.getTouchAreaSize();
            const axisSize = taSize[axis] / 2;
            let curAxisSize = axisSize + this.get('slide')[axis];
            let centerVal = center[axis];
            let scale = this.get('scale');
            let cal = (curAxisSize - centerVal) / scale;
            this.positionVal[axis] = Calculator.round(cal);
        });
    }

    /**
     * 在缩放的同时进行移动，用于保持图片始终处于 position() 所定位的位置
     */
    move() {
        let curScale = this.get('scale');
        let scale = curScale - this.get('lastScale');
        this.addSlide(this.positionVal.x * scale, this.positionVal.y * scale);
    }

    /**
     * 进行缩放计算
     * @param {*} scale 
     * @param {*} isStart 
     */
    zoom(scale, isStart) {
        const old = this.get('scale');
        let maxScale = this.options.maxScale;
        if (scale < 1 && old < 0.5 || scale > 1 && old > maxScale + 1) {
            return;
        }
        let distance = scale - 1;
        if (isStart) {
            this.setLastActionData('scale', old);
            this.baseScale = old;
        } else {
            distance = distance - this.pinchStartVal;
        }
        this.pinchStartVal = scale - 1;
        this.addScale(scale >= 1 ? distance : this.baseScale * scale - old);
        this.move();
    }

    /**
     * 切换图片计算
     * @param {*} isSwitch 
     * @param {*} direction 
     */
    switch(isSwitch, direction) {
        if (!isSwitch || this.switchLocked) {
            return { switch: false };
        }
        this.switchLocked = true;
        setTimeout(() => {
            this.switchLocked = false;
        }, 150);
        let next = isSwitch && direction === 'next';
        let previous = isSwitch && direction === 'previous';
        isSwitch = next && this.curImgIndex + 1 < this.imagesNumber;
        isSwitch = isSwitch || previous && this.curImgIndex > 0;
        if (isSwitch) {
            this.initValues();
        }
        return { switch: isSwitch, next, previous };
    }

    /**
     * 图片切换的所需的阀值
     * @param {*} slide 
     */
    switchThreshold(slide) {
        slide = Math.abs(slide || this.get('slide').x);
        let diffVal = this.getImageSizeDiffVal();
        slide = slide - Math.abs(diffVal);
        slide = slide < 0 ? 0 : slide;
        return slide >= this.getTouchAreaSize().x / 4;
    }

    /**
     * 快速滑动的计算方法
     * @param {*} x 
     * @param {*} y 
     * @param {*} deltaTime 
     */
    swipe(x, y, deltaTime) {
        let slide = this.get('slide').slice();
        const rate = 1 + (1 - deltaTime / 200);
        let newSlide = { x: x * rate, y: y * rate };
        this.eachAxis(axis => {
            let bound = this.getBound(axis);
            bound = bound <= 0 ? 0 : bound;
            if (Math.abs(slide[axis]) < bound) {
                if (Math.abs(slide[axis]) + Math.abs(newSlide[axis]) > bound) {
                    let cal = bound - Math.abs(slide[axis]) + 30;
                    newSlide[axis] = newSlide[axis] < 0 ? 0 - cal : cal;
                }
            } else {
                newSlide[axis] = 0;
            }
        });
        this.addSlide(newSlide.x, newSlide.y);
    }
}

/***/ }),

/***/ "../../node_modules/apopups-gallery/Gallery.vue":
/*!******************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Gallery.vue ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Gallery_vue_vue_type_template_id_7c0324d9_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Gallery.vue?vue&type=template&id=7c0324d9&scoped=true& */ "../../node_modules/apopups-gallery/Gallery.vue?vue&type=template&id=7c0324d9&scoped=true&");
/* harmony import */ var _Gallery_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Gallery.vue?vue&type=script&lang=js& */ "../../node_modules/apopups-gallery/Gallery.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport *//* harmony import */ var _Gallery_vue_vue_type_style_index_0_id_7c0324d9_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Gallery.vue?vue&type=style&index=0&id=7c0324d9&lang=scss&scoped=true& */ "../../node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=0&id=7c0324d9&lang=scss&scoped=true&");
/* harmony import */ var _Gallery_vue_vue_type_style_index_1_lang_css___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Gallery.vue?vue&type=style&index=1&lang=css& */ "../../node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=1&lang=css&");
/* harmony import */ var _vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../vue-loader/lib/runtime/componentNormalizer.js */ "../../node_modules/vue-loader/lib/runtime/componentNormalizer.js");







/* normalize component */

var component = Object(_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_4__["default"])(
  _Gallery_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Gallery_vue_vue_type_template_id_7c0324d9_scoped_true___WEBPACK_IMPORTED_MODULE_0__["render"],
  _Gallery_vue_vue_type_template_id_7c0324d9_scoped_true___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  false,
  null,
  "7c0324d9",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "node_modules/apopups-gallery/Gallery.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "../../node_modules/apopups-gallery/Gallery.vue?vue&type=script&lang=js&":
/*!*******************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Gallery.vue?vue&type=script&lang=js& ***!
  \*******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_loader_lib_index_js_vue_loader_lib_index_js_vue_loader_options_Gallery_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../babel-loader/lib!../vue-loader/lib??vue-loader-options!./Gallery.vue?vue&type=script&lang=js& */ "../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Gallery.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_babel_loader_lib_index_js_vue_loader_lib_index_js_vue_loader_options_Gallery_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "../../node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=0&id=7c0324d9&lang=scss&scoped=true&":
/*!****************************************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=0&id=7c0324d9&lang=scss&scoped=true& ***!
  \****************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_sass_loader_lib_loader_js_ref_3_2_vue_loader_lib_index_js_vue_loader_options_Gallery_vue_vue_type_style_index_0_id_7c0324d9_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../vue-style-loader!../css-loader!../vue-loader/lib/loaders/stylePostLoader.js!../sass-loader/lib/loader.js??ref--3-2!../vue-loader/lib??vue-loader-options!./Gallery.vue?vue&type=style&index=0&id=7c0324d9&lang=scss&scoped=true& */ "../../node_modules/vue-style-loader/index.js!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/lib/loader.js?!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=0&id=7c0324d9&lang=scss&scoped=true&");
/* harmony import */ var _vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_sass_loader_lib_loader_js_ref_3_2_vue_loader_lib_index_js_vue_loader_options_Gallery_vue_vue_type_style_index_0_id_7c0324d9_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_sass_loader_lib_loader_js_ref_3_2_vue_loader_lib_index_js_vue_loader_options_Gallery_vue_vue_type_style_index_0_id_7c0324d9_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_sass_loader_lib_loader_js_ref_3_2_vue_loader_lib_index_js_vue_loader_options_Gallery_vue_vue_type_style_index_0_id_7c0324d9_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_sass_loader_lib_loader_js_ref_3_2_vue_loader_lib_index_js_vue_loader_options_Gallery_vue_vue_type_style_index_0_id_7c0324d9_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));
 /* harmony default export */ __webpack_exports__["default"] = (_vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_sass_loader_lib_loader_js_ref_3_2_vue_loader_lib_index_js_vue_loader_options_Gallery_vue_vue_type_style_index_0_id_7c0324d9_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),

/***/ "../../node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=1&lang=css&":
/*!***************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=1&lang=css& ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_vue_loader_lib_index_js_vue_loader_options_Gallery_vue_vue_type_style_index_1_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../vue-style-loader!../css-loader!../vue-loader/lib/loaders/stylePostLoader.js!../vue-loader/lib??vue-loader-options!./Gallery.vue?vue&type=style&index=1&lang=css& */ "../../node_modules/vue-style-loader/index.js!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=1&lang=css&");
/* harmony import */ var _vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_vue_loader_lib_index_js_vue_loader_options_Gallery_vue_vue_type_style_index_1_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_vue_loader_lib_index_js_vue_loader_options_Gallery_vue_vue_type_style_index_1_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_vue_loader_lib_index_js_vue_loader_options_Gallery_vue_vue_type_style_index_1_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_vue_loader_lib_index_js_vue_loader_options_Gallery_vue_vue_type_style_index_1_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));
 /* harmony default export */ __webpack_exports__["default"] = (_vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_vue_loader_lib_index_js_vue_loader_options_Gallery_vue_vue_type_style_index_1_lang_css___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),

/***/ "../../node_modules/apopups-gallery/Gallery.vue?vue&type=template&id=7c0324d9&scoped=true&":
/*!*************************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Gallery.vue?vue&type=template&id=7c0324d9&scoped=true& ***!
  \*************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vue_loader_lib_loaders_templateLoader_js_vue_loader_options_vue_loader_lib_index_js_vue_loader_options_Gallery_vue_vue_type_template_id_7c0324d9_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../vue-loader/lib??vue-loader-options!./Gallery.vue?vue&type=template&id=7c0324d9&scoped=true& */ "../../node_modules/vue-loader/lib/loaders/templateLoader.js?!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Gallery.vue?vue&type=template&id=7c0324d9&scoped=true&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _vue_loader_lib_loaders_templateLoader_js_vue_loader_options_vue_loader_lib_index_js_vue_loader_options_Gallery_vue_vue_type_template_id_7c0324d9_scoped_true___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _vue_loader_lib_loaders_templateLoader_js_vue_loader_options_vue_loader_lib_index_js_vue_loader_options_Gallery_vue_vue_type_template_id_7c0324d9_scoped_true___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ }),

/***/ "../../node_modules/apopups-gallery/Wrap.vue":
/*!***************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Wrap.vue ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Wrap_vue_vue_type_template_id_65970f5a_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Wrap.vue?vue&type=template&id=65970f5a&scoped=true& */ "../../node_modules/apopups-gallery/Wrap.vue?vue&type=template&id=65970f5a&scoped=true&");
/* harmony import */ var _Wrap_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Wrap.vue?vue&type=script&lang=js& */ "../../node_modules/apopups-gallery/Wrap.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport *//* harmony import */ var _Wrap_vue_vue_type_style_index_0_id_65970f5a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Wrap.vue?vue&type=style&index=0&id=65970f5a&lang=scss&scoped=true& */ "../../node_modules/apopups-gallery/Wrap.vue?vue&type=style&index=0&id=65970f5a&lang=scss&scoped=true&");
/* harmony import */ var _vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../vue-loader/lib/runtime/componentNormalizer.js */ "../../node_modules/vue-loader/lib/runtime/componentNormalizer.js");






/* normalize component */

var component = Object(_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _Wrap_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Wrap_vue_vue_type_template_id_65970f5a_scoped_true___WEBPACK_IMPORTED_MODULE_0__["render"],
  _Wrap_vue_vue_type_template_id_65970f5a_scoped_true___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  false,
  null,
  "65970f5a",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "node_modules/apopups-gallery/Wrap.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "../../node_modules/apopups-gallery/Wrap.vue?vue&type=script&lang=js&":
/*!****************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Wrap.vue?vue&type=script&lang=js& ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_loader_lib_index_js_vue_loader_lib_index_js_vue_loader_options_Wrap_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../babel-loader/lib!../vue-loader/lib??vue-loader-options!./Wrap.vue?vue&type=script&lang=js& */ "../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Wrap.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_babel_loader_lib_index_js_vue_loader_lib_index_js_vue_loader_options_Wrap_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "../../node_modules/apopups-gallery/Wrap.vue?vue&type=style&index=0&id=65970f5a&lang=scss&scoped=true&":
/*!*************************************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Wrap.vue?vue&type=style&index=0&id=65970f5a&lang=scss&scoped=true& ***!
  \*************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_sass_loader_lib_loader_js_ref_3_2_vue_loader_lib_index_js_vue_loader_options_Wrap_vue_vue_type_style_index_0_id_65970f5a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../vue-style-loader!../css-loader!../vue-loader/lib/loaders/stylePostLoader.js!../sass-loader/lib/loader.js??ref--3-2!../vue-loader/lib??vue-loader-options!./Wrap.vue?vue&type=style&index=0&id=65970f5a&lang=scss&scoped=true& */ "../../node_modules/vue-style-loader/index.js!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/lib/loader.js?!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Wrap.vue?vue&type=style&index=0&id=65970f5a&lang=scss&scoped=true&");
/* harmony import */ var _vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_sass_loader_lib_loader_js_ref_3_2_vue_loader_lib_index_js_vue_loader_options_Wrap_vue_vue_type_style_index_0_id_65970f5a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_sass_loader_lib_loader_js_ref_3_2_vue_loader_lib_index_js_vue_loader_options_Wrap_vue_vue_type_style_index_0_id_65970f5a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_sass_loader_lib_loader_js_ref_3_2_vue_loader_lib_index_js_vue_loader_options_Wrap_vue_vue_type_style_index_0_id_65970f5a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_sass_loader_lib_loader_js_ref_3_2_vue_loader_lib_index_js_vue_loader_options_Wrap_vue_vue_type_style_index_0_id_65970f5a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));
 /* harmony default export */ __webpack_exports__["default"] = (_vue_style_loader_index_js_css_loader_index_js_vue_loader_lib_loaders_stylePostLoader_js_sass_loader_lib_loader_js_ref_3_2_vue_loader_lib_index_js_vue_loader_options_Wrap_vue_vue_type_style_index_0_id_65970f5a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),

/***/ "../../node_modules/apopups-gallery/Wrap.vue?vue&type=template&id=65970f5a&scoped=true&":
/*!**********************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Wrap.vue?vue&type=template&id=65970f5a&scoped=true& ***!
  \**********************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vue_loader_lib_loaders_templateLoader_js_vue_loader_options_vue_loader_lib_index_js_vue_loader_options_Wrap_vue_vue_type_template_id_65970f5a_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../vue-loader/lib??vue-loader-options!./Wrap.vue?vue&type=template&id=65970f5a&scoped=true& */ "../../node_modules/vue-loader/lib/loaders/templateLoader.js?!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Wrap.vue?vue&type=template&id=65970f5a&scoped=true&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _vue_loader_lib_loaders_templateLoader_js_vue_loader_options_vue_loader_lib_index_js_vue_loader_options_Wrap_vue_vue_type_template_id_65970f5a_scoped_true___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _vue_loader_lib_loaders_templateLoader_js_vue_loader_options_vue_loader_lib_index_js_vue_loader_options_Wrap_vue_vue_type_template_id_65970f5a_scoped_true___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ }),

/***/ "../../node_modules/apopups-gallery/node_modules/hammerjs/hammer.js":
/*!**************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/node_modules/hammerjs/hammer.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function (window, document, exportName, undefined) {
    'use strict';

    var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
    var TEST_ELEMENT = document.createElement('div');

    var TYPE_FUNCTION = 'function';

    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;

    /**
     * set a timeout with a given scope
     * @param {Function} fn
     * @param {Number} timeout
     * @param {Object} context
     * @returns {number}
     */
    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }

    /**
     * if the argument is an array, we want to execute the fn on each entry
     * if it aint an array we don't want to do a thing.
     * this is used by all the methods that accept a single and array argument.
     * @param {*|Array} arg
     * @param {String} fn
     * @param {Object} [context]
     * @returns {Boolean}
     */
    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }

    /**
     * walk objects and arrays
     * @param {Object} obj
     * @param {Function} iterator
     * @param {Object} context
     */
    function each(obj, iterator, context) {
        var i;

        if (!obj) {
            return;
        }

        if (obj.forEach) {
            obj.forEach(iterator, context);
        } else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else {
            for (i in obj) {
                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
        }
    }

    /**
     * wrap a method with a deprecation warning and stack trace
     * @param {Function} method
     * @param {String} name
     * @param {String} message
     * @returns {Function} A new function wrapping the supplied method.
     */
    function deprecate(method, name, message) {
        var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
        return function () {
            var e = new Error('get-stack-trace');
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

            var log = window.console && (window.console.warn || window.console.log);
            if (log) {
                log.call(window.console, deprecationMessage, stack);
            }
            return method.apply(this, arguments);
        };
    }

    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} target
     * @param {...Object} objects_to_assign
     * @returns {Object} target
     */
    var assign;
    if (typeof Object.assign !== 'function') {
        assign = function assign(target) {
            if (target === undefined || target === null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }

            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (source !== undefined && source !== null) {
                    for (var nextKey in source) {
                        if (source.hasOwnProperty(nextKey)) {
                            output[nextKey] = source[nextKey];
                        }
                    }
                }
            }
            return output;
        };
    } else {
        assign = Object.assign;
    }

    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} dest
     * @param {Object} src
     * @param {Boolean} [merge=false]
     * @returns {Object} dest
     */
    var extend = deprecate(function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || merge && dest[keys[i]] === undefined) {
                dest[keys[i]] = src[keys[i]];
            }
            i++;
        }
        return dest;
    }, 'extend', 'Use `assign`.');

    /**
     * merge the values from src in the dest.
     * means that properties that exist in dest will not be overwritten by src
     * @param {Object} dest
     * @param {Object} src
     * @returns {Object} dest
     */
    var merge = deprecate(function merge(dest, src) {
        return extend(dest, src, true);
    }, 'merge', 'Use `assign`.');

    /**
     * simple class inheritance
     * @param {Function} child
     * @param {Function} base
     * @param {Object} [properties]
     */
    function inherit(child, base, properties) {
        var baseP = base.prototype,
            childP;

        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;

        if (properties) {
            assign(childP, properties);
        }
    }

    /**
     * simple function bind
     * @param {Function} fn
     * @param {Object} context
     * @returns {Function}
     */
    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }

    /**
     * let a boolean value also be a function that must return a boolean
     * this first item in args will be used as the context
     * @param {Boolean|Function} val
     * @param {Array} [args]
     * @returns {Boolean}
     */
    function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined : undefined, args);
        }
        return val;
    }

    /**
     * use the val2 when val1 is undefined
     * @param {*} val1
     * @param {*} val2
     * @returns {*}
     */
    function ifUndefined(val1, val2) {
        return val1 === undefined ? val2 : val1;
    }

    /**
     * addEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function addEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
            target.addEventListener(type, handler, false);
        });
    }

    /**
     * removeEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function removeEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
            target.removeEventListener(type, handler, false);
        });
    }

    /**
     * find if a node is in the given parent
     * @method hasParent
     * @param {HTMLElement} node
     * @param {HTMLElement} parent
     * @return {Boolean} found
     */
    function hasParent(node, parent) {
        while (node) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }

    /**
     * small indexOf wrapper
     * @param {String} str
     * @param {String} find
     * @returns {Boolean} found
     */
    function inStr(str, find) {
        return str.indexOf(find) > -1;
    }

    /**
     * split string on whitespace
     * @param {String} str
     * @returns {Array} words
     */
    function splitStr(str) {
        return str.trim().split(/\s+/g);
    }

    /**
     * find if a array contains the object using indexOf or a simple polyFill
     * @param {Array} src
     * @param {String} find
     * @param {String} [findByKey]
     * @return {Boolean|Number} false when not found, or the index
     */
    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
            return src.indexOf(find);
        } else {
            var i = 0;
            while (i < src.length) {
                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                    return i;
                }
                i++;
            }
            return -1;
        }
    }

    /**
     * convert array-like objects to real arrays
     * @param {Object} obj
     * @returns {Array}
     */
    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }

    /**
     * unique array with objects based on a key (like 'id') or just by the array's value
     * @param {Array} src [{id:1},{id:2},{id:1}]
     * @param {String} [key]
     * @param {Boolean} [sort=False]
     * @returns {Array} [{id:1},{id:2}]
     */
    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;

        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
                results.push(src[i]);
            }
            values[i] = val;
            i++;
        }

        if (sort) {
            if (!key) {
                results = results.sort();
            } else {
                results = results.sort(function sortUniqueArray(a, b) {
                    return a[key] > b[key];
                });
            }
        }

        return results;
    }

    /**
     * get the prefixed property
     * @param {Object} obj
     * @param {String} property
     * @returns {String|Undefined} prefixed
     */
    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);

        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;

            if (prop in obj) {
                return prop;
            }
            i++;
        }
        return undefined;
    }

    /**
     * get a unique id
     * @returns {number} uniqueId
     */
    var _uniqueId = 1;
    function uniqueId() {
        return _uniqueId++;
    }

    /**
     * get the window object of an element
     * @param {HTMLElement} element
     * @returns {DocumentView|Window}
     */
    function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window;
    }

    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

    var SUPPORT_TOUCH = 'ontouchstart' in window;
    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

    var INPUT_TYPE_TOUCH = 'touch';
    var INPUT_TYPE_PEN = 'pen';
    var INPUT_TYPE_MOUSE = 'mouse';
    var INPUT_TYPE_KINECT = 'kinect';

    var COMPUTE_INTERVAL = 25;

    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;

    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;

    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

    var PROPS_XY = ['x', 'y'];
    var PROPS_CLIENT_XY = ['clientX', 'clientY'];

    /**
     * create new input type manager
     * @param {Manager} manager
     * @param {Function} callback
     * @returns {Input}
     * @constructor
     */
    function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;

        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function (ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
                self.handler(ev);
            }
        };

        this.init();
    }

    Input.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function () {},

        /**
         * bind the events
         */
        init: function () {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },

        /**
         * unbind the events
         */
        destroy: function () {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
    };

    /**
     * create new input type manager
     * called by the Manager constructor
     * @param {Hammer} manager
     * @returns {Input}
     */
    function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;

        if (inputClass) {
            Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
        } else {
            Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
    }

    /**
     * handle input events
     * @param {Manager} manager
     * @param {String} eventType
     * @param {Object} input
     */
    function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;

        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;

        if (isFirst) {
            manager.session = {};
        }

        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;

        // compute scale, rotation etc
        computeInputData(manager, input);

        // emit secret event
        manager.emit('hammer.input', input);

        manager.recognize(input);
        manager.session.prevInput = input;
    }

    /**
     * extend the data with some usable properties like scale, rotate, velocity etc
     * @param {Object} manager
     * @param {Object} input
     */
    function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;

        // store the first input to calculate the distance and direction
        if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
        }

        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
            session.firstMultiple = false;
        }

        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;

        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);

        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);

        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;

        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;

        computeIntervalInputData(session, input);

        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }

    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};

        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };

            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }

        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }

    /**
     * velocity is calculated every x ms
     * @param {Object} session
     * @param {Object} input
     */
    function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input,
            deltaTime = input.timeStamp - last.timeStamp,
            velocity,
            velocityX,
            velocityY,
            direction;

        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;

            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);

            session.lastInterval = input;
        } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }

        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }

    /**
     * create a simple clone from the input used for storage of firstInput and firstMultiple
     * @param {Object} input
     * @returns {Object} clonedInputData
     */
    function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }

        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }

    /**
     * get the center of all the pointers
     * @param {Array} pointers
     * @return {Object} center contains `x` and `y` properties
     */
    function getCenter(pointers) {
        var pointersLength = pointers.length;

        // no need to loop when only one touch
        if (pointersLength === 1) {
            return {
                x: round(pointers[0].clientX),
                y: round(pointers[0].clientY)
            };
        }

        var x = 0,
            y = 0,
            i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }

        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }

    /**
     * calculate the velocity between two points. unit is in px per ms.
     * @param {Number} deltaTime
     * @param {Number} x
     * @param {Number} y
     * @return {Object} velocity `x` and `y`
     */
    function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }

    /**
     * get the direction between two points
     * @param {Number} x
     * @param {Number} y
     * @return {Number} direction
     */
    function getDirection(x, y) {
        if (x === y) {
            return DIRECTION_NONE;
        }

        if (abs(x) >= abs(y)) {
            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }

    /**
     * calculate the absolute distance between two points
     * @param {Object} p1 {x, y}
     * @param {Object} p2 {x, y}
     * @param {Array} [props] containing x and y keys
     * @return {Number} distance
     */
    function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];

        return Math.sqrt(x * x + y * y);
    }

    /**
     * calculate the angle between two coordinates
     * @param {Object} p1
     * @param {Object} p2
     * @param {Array} [props] containing x and y keys
     * @return {Number} angle
     */
    function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }

    /**
     * calculate the rotation degrees between two pointersets
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} rotation
     */
    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }

    /**
     * calculate the scale factor between two pointersets
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} scale
     */
    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }

    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };

    var MOUSE_ELEMENT_EVENTS = 'mousedown';
    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

    /**
     * Mouse events input
     * @constructor
     * @extends Input
     */
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;

        this.pressed = false; // mousedown state

        Input.apply(this, arguments);
    }

    inherit(MouseInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP[ev.type];

            // on start we want to have the left mouse button down
            if (eventType & INPUT_START && ev.button === 0) {
                this.pressed = true;
            }

            if (eventType & INPUT_MOVE && ev.which !== 1) {
                eventType = INPUT_END;
            }

            // mouse must be down
            if (!this.pressed) {
                return;
            }

            if (eventType & INPUT_END) {
                this.pressed = false;
            }

            this.callback(this.manager, eventType, {
                pointers: [ev],
                changedPointers: [ev],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            });
        }
    });

    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };

    // in IE10 the pointer types is defined as an enum
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
    };

    var POINTER_ELEMENT_EVENTS = 'pointerdown';
    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

    // IE10 has prefixed support, and case-sensitive
    if (window.MSPointerEvent && !window.PointerEvent) {
        POINTER_ELEMENT_EVENTS = 'MSPointerDown';
        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
    }

    /**
     * Pointer events input
     * @constructor
     * @extends Input
     */
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;

        Input.apply(this, arguments);

        this.store = this.manager.session.pointerEvents = [];
    }

    inherit(PointerEventInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;

            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

            var isTouch = pointerType == INPUT_TYPE_TOUCH;

            // get index of the event in the store
            var storeIndex = inArray(store, ev.pointerId, 'pointerId');

            // start and mouse must be down
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                if (storeIndex < 0) {
                    store.push(ev);
                    storeIndex = store.length - 1;
                }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                removePointer = true;
            }

            // it not found, so the pointer hasn't been down (so it's probably a hover)
            if (storeIndex < 0) {
                return;
            }

            // update the event in the store
            store[storeIndex] = ev;

            this.callback(this.manager, eventType, {
                pointers: store,
                changedPointers: [ev],
                pointerType: pointerType,
                srcEvent: ev
            });

            if (removePointer) {
                // remove from the store
                store.splice(storeIndex, 1);
            }
        }
    });

    var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };

    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

    /**
     * Touch events input
     * @constructor
     * @extends Input
     */
    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;

        Input.apply(this, arguments);
    }

    inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

            // should we handle the touch events?
            if (type === INPUT_START) {
                this.started = true;
            }

            if (!this.started) {
                return;
            }

            var touches = normalizeSingleTouches.call(this, ev, type);

            // when done, reset the started state
            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                this.started = false;
            }

            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);

        if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), 'identifier', true);
        }

        return [all, changed];
    }

    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };

    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

    /**
     * Multi-user touch events input
     * @constructor
     * @extends Input
     */
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};

        Input.apply(this, arguments);
    }

    inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
                return;
            }

            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;

        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
        }

        var i,
            targetTouches,
            changedTouches = toArray(ev.changedTouches),
            changedTargetTouches = [],
            target = this.target;

        // get target touches from touches
        targetTouches = allTouches.filter(function (touch) {
            return hasParent(touch.target, target);
        });

        // collect touches
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }

        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
                changedTargetTouches.push(changedTouches[i]);
            }

            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) {
                delete targetIds[changedTouches[i].identifier];
            }
            i++;
        }

        if (!changedTargetTouches.length) {
            return;
        }

        return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
    }

    /**
     * Combined touch and mouse input
     *
     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
     * This because touch devices also emit mouse events while doing a touch.
     *
     * @constructor
     * @extends Input
     */

    var DEDUP_TIMEOUT = 2500;
    var DEDUP_DISTANCE = 25;

    function TouchMouseInput() {
        Input.apply(this, arguments);

        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);

        this.primaryTouch = null;
        this.lastTouches = [];
    }

    inherit(TouchMouseInput, Input, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
                isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;

            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
                return;
            }

            // when we're in a touch event, record touches to  de-dupe synthetic mouse event
            if (isTouch) {
                recordTouches.call(this, inputEvent, inputData);
            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
                return;
            }

            this.callback(manager, inputEvent, inputData);
        },

        /**
         * remove the event listeners
         */
        destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
        }
    });

    function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            setLastTouch.call(this, eventData);
        }
    }

    function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];

        if (touch.identifier === this.primaryTouch) {
            var lastTouch = { x: touch.clientX, y: touch.clientY };
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function () {
                var i = lts.indexOf(lastTouch);
                if (i > -1) {
                    lts.splice(i, 1);
                }
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
    }

    function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX,
            y = eventData.srcEvent.clientY;
        for (var i = 0; i < this.lastTouches.length; i++) {
            var t = this.lastTouches[i];
            var dx = Math.abs(x - t.x),
                dy = Math.abs(y - t.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
                return true;
            }
        }
        return false;
    }

    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

    // magical touchAction value
    var TOUCH_ACTION_COMPUTE = 'compute';
    var TOUCH_ACTION_AUTO = 'auto';
    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
    var TOUCH_ACTION_NONE = 'none';
    var TOUCH_ACTION_PAN_X = 'pan-x';
    var TOUCH_ACTION_PAN_Y = 'pan-y';
    var TOUCH_ACTION_MAP = getTouchActionProps();

    /**
     * Touch Action
     * sets the touchAction property or uses the js alternative
     * @param {Manager} manager
     * @param {String} value
     * @constructor
     */
    function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }

    TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function (value) {
            // find out the touch-action by the event handlers
            if (value == TOUCH_ACTION_COMPUTE) {
                value = this.compute();
            }

            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }
            this.actions = value.toLowerCase().trim();
        },

        /**
         * just re-set the touchAction value
         */
        update: function () {
            this.set(this.manager.options.touchAction);
        },

        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function () {
            var actions = [];
            each(this.manager.recognizers, function (recognizer) {
                if (boolOrFn(recognizer.options.enable, [recognizer])) {
                    actions = actions.concat(recognizer.getTouchAction());
                }
            });
            return cleanTouchActions(actions.join(' '));
        },

        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function (input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;

            // if the touch action did prevented once this session
            if (this.manager.session.prevented) {
                srcEvent.preventDefault();
                return;
            }

            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

            if (hasNone) {
                //do not prevent defaults if this is a tap gesture

                var isTapPointer = input.pointers.length === 1;
                var isTapMovement = input.distance < 2;
                var isTapTouchTime = input.deltaTime < 250;

                if (isTapPointer && isTapMovement && isTapTouchTime) {
                    return;
                }
            }

            if (hasPanX && hasPanY) {
                // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
                return;
            }

            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
                return this.preventSrc(srcEvent);
            }
        },

        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function (srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
        }
    };

    /**
     * when the touchActions are collected they are not a valid value, so we need to clean things up. *
     * @param {String} actions
     * @returns {*}
     */
    function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
        }

        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

        // if both pan-x and pan-y are set (different recognizers
        // for different directions, e.g. horizontal pan but vertical swipe?)
        // we need none (as otherwise with pan-x pan-y combined none of these
        // recognizers will work, since the browser would handle all panning
        if (hasPanX && hasPanY) {
            return TOUCH_ACTION_NONE;
        }

        // pan-x OR pan-y
        if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }

        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
        }

        return TOUCH_ACTION_AUTO;
    }

    function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
            return false;
        }
        var touchMap = {};
        var cssSupports = window.CSS && window.CSS.supports;
        ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {

            // If css.supports is not supported but there is native touch-action assume it supports
            // all values. This is the case for IE 10 and 11.
            touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
        });
        return touchMap;
    }

    /**
     * Recognizer flow explained; *
     * All recognizers have the initial state of POSSIBLE when a input session starts.
     * The definition of a input session is from the first input until the last input, with all it's movement in it. *
     * Example session for mouse-input: mousedown -> mousemove -> mouseup
     *
     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
     * which determines with state it should be.
     *
     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
     * POSSIBLE to give it another change on the next cycle.
     *
     *               Possible
     *                  |
     *            +-----+---------------+
     *            |                     |
     *      +-----+-----+               |
     *      |           |               |
     *   Failed      Cancelled          |
     *                          +-------+------+
     *                          |              |
     *                      Recognized       Began
     *                                         |
     *                                      Changed
     *                                         |
     *                                  Ended/Recognized
     */
    var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;

    /**
     * Recognizer
     * Every recognizer needs to extend from this class.
     * @constructor
     * @param {Object} options
     */
    function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});

        this.id = uniqueId();

        this.manager = null;

        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);

        this.state = STATE_POSSIBLE;

        this.simultaneous = {};
        this.requireFail = [];
    }

    Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},

        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function (options) {
            assign(this.options, options);

            // also update the touchAction, in case something changed about the directions/enabled state
            this.manager && this.manager.touchAction.update();
            return this;
        },

        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function (otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                return this;
            }

            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
                simultaneous[otherRecognizer.id] = otherRecognizer;
                otherRecognizer.recognizeWith(this);
            }
            return this;
        },

        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function (otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                return this;
            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
        },

        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function (otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                return this;
            }

            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
                requireFail.push(otherRecognizer);
                otherRecognizer.requireFailure(this);
            }
            return this;
        },

        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function (otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                return this;
            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) {
                this.requireFail.splice(index, 1);
            }
            return this;
        },

        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function () {
            return this.requireFail.length > 0;
        },

        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function (otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
        },

        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function (input) {
            var self = this;
            var state = this.state;

            function emit(event) {
                self.manager.emit(event, input);
            }

            // 'panstart' and 'panmove'
            if (state < STATE_ENDED) {
                emit(self.options.event + stateStr(state));
            }

            emit(self.options.event); // simple 'eventName' events

            if (input.additionalEvent) {
                // additional event(panleft, panright, pinchin, pinchout...)
                emit(input.additionalEvent);
            }

            // panend and pancancel
            if (state >= STATE_ENDED) {
                emit(self.options.event + stateStr(state));
            }
        },

        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function (input) {
            if (this.canEmit()) {
                return this.emit(input);
            }
            // it's failing anyway
            this.state = STATE_FAILED;
        },

        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function () {
            var i = 0;
            while (i < this.requireFail.length) {
                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                    return false;
                }
                i++;
            }
            return true;
        },

        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function (inputData) {
            // make a new copy of the inputData
            // so we can change the inputData without messing up the other recognizers
            var inputDataClone = assign({}, inputData);

            // is is enabled and allow recognizing?
            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                this.reset();
                this.state = STATE_FAILED;
                return;
            }

            // reset when we've reached the end
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                this.state = STATE_POSSIBLE;
            }

            this.state = this.process(inputDataClone);

            // the recognizer has recognized a gesture
            // so trigger an event
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                this.tryEmit(inputDataClone);
            }
        },

        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function (inputData) {}, // jshint ignore:line

        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function () {},

        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function () {}
    };

    /**
     * get a usable string, used as event postfix
     * @param {Const} state
     * @returns {String} state
     */
    function stateStr(state) {
        if (state & STATE_CANCELLED) {
            return 'cancel';
        } else if (state & STATE_ENDED) {
            return 'end';
        } else if (state & STATE_CHANGED) {
            return 'move';
        } else if (state & STATE_BEGAN) {
            return 'start';
        }
        return '';
    }

    /**
     * direction cons to string
     * @param {Const} direction
     * @returns {String}
     */
    function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
            return 'down';
        } else if (direction == DIRECTION_UP) {
            return 'up';
        } else if (direction == DIRECTION_LEFT) {
            return 'left';
        } else if (direction == DIRECTION_RIGHT) {
            return 'right';
        }
        return '';
    }

    /**
     * get a recognizer by name if it is bound to a manager
     * @param {Recognizer|String} otherRecognizer
     * @param {Recognizer} recognizer
     * @returns {Recognizer}
     */
    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
            return manager.get(otherRecognizer);
        }
        return otherRecognizer;
    }

    /**
     * This recognizer is just used as a base for the simple attribute recognizers.
     * @constructor
     * @extends Recognizer
     */
    function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }

    inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
            /**
             * @type {Number}
             * @default 1
             */
            pointers: 1
        },

        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function (input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
        },

        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function (input) {
            var state = this.state;
            var eventType = input.eventType;

            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);

            // on cancel input and we've recognized before, return STATE_CANCELLED
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
                if (eventType & INPUT_END) {
                    return state | STATE_ENDED;
                } else if (!(state & STATE_BEGAN)) {
                    return STATE_BEGAN;
                }
                return state | STATE_CHANGED;
            }
            return STATE_FAILED;
        }
    });

    /**
     * Pan
     * Recognized when the pointer is down and moved in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);

        this.pX = null;
        this.pY = null;
    }

    inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
            event: 'pan',
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },

        getTouchAction: function () {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
                actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
                actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
        },

        directionTest: function (input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;

            // lock to axis?
            if (!(direction & options.direction)) {
                if (options.direction & DIRECTION_HORIZONTAL) {
                    direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs(input.deltaX);
                } else {
                    direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs(input.deltaY);
                }
            }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
        },

        attrTest: function (input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },

        emit: function (input) {

            this.pX = input.deltaX;
            this.pY = input.deltaY;

            var direction = directionStr(input.direction);

            if (direction) {
                input.additionalEvent = this.options.event + direction;
            }
            this._super.emit.call(this, input);
        }
    });

    /**
     * Pinch
     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
     * @constructor
     * @extends AttrRecognizer
     */
    function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'pinch',
            threshold: 0,
            pointers: 2
        },

        getTouchAction: function () {
            return [TOUCH_ACTION_NONE];
        },

        attrTest: function (input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },

        emit: function (input) {
            if (input.scale !== 1) {
                var inOut = input.scale < 1 ? 'in' : 'out';
                input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
        }
    });

    /**
     * Press
     * Recognized when the pointer is down for x ms without any movement.
     * @constructor
     * @extends Recognizer
     */
    function PressRecognizer() {
        Recognizer.apply(this, arguments);

        this._timer = null;
        this._input = null;
    }

    inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
            event: 'press',
            pointers: 1,
            time: 251, // minimal time of the pointer to be pressed
            threshold: 9 // a minimal movement is ok, but keep it low
        },

        getTouchAction: function () {
            return [TOUCH_ACTION_AUTO];
        },

        process: function (input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;

            this._input = input;

            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
                this.reset();
            } else if (input.eventType & INPUT_START) {
                this.reset();
                this._timer = setTimeoutContext(function () {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                }, options.time, this);
            } else if (input.eventType & INPUT_END) {
                return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
        },

        reset: function () {
            clearTimeout(this._timer);
        },

        emit: function (input) {
            if (this.state !== STATE_RECOGNIZED) {
                return;
            }

            if (input && input.eventType & INPUT_END) {
                this.manager.emit(this.options.event + 'up', input);
            } else {
                this._input.timeStamp = now();
                this.manager.emit(this.options.event, this._input);
            }
        }
    });

    /**
     * Rotate
     * Recognized when two or more pointer are moving in a circular motion.
     * @constructor
     * @extends AttrRecognizer
     */
    function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
            event: 'rotate',
            threshold: 0,
            pointers: 2
        },

        getTouchAction: function () {
            return [TOUCH_ACTION_NONE];
        },

        attrTest: function (input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
    });

    /**
     * Swipe
     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
            event: 'swipe',
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },

        getTouchAction: function () {
            return PanRecognizer.prototype.getTouchAction.call(this);
        },

        attrTest: function (input) {
            var direction = this.options.direction;
            var velocity;

            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                velocity = input.overallVelocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
                velocity = input.overallVelocityX;
            } else if (direction & DIRECTION_VERTICAL) {
                velocity = input.overallVelocityY;
            }

            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },

        emit: function (input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) {
                this.manager.emit(this.options.event + direction, input);
            }

            this.manager.emit(this.options.event, input);
        }
    });

    /**
     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
     * between the given interval and position. The delay option can be used to recognize multi-taps without firing
     * a single tap.
     *
     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
     * multi-taps being recognized.
     * @constructor
     * @extends Recognizer
     */
    function TapRecognizer() {
        Recognizer.apply(this, arguments);

        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;

        this._timer = null;
        this._input = null;
        this.count = 0;
    }

    inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'tap',
            pointers: 1,
            taps: 1,
            interval: 300, // max time between the multi-tap taps
            time: 250, // max time of the pointer to be down (like finger on the screen)
            threshold: 9, // a minimal movement is ok, but keep it low
            posThreshold: 10 // a multi-tap can be a bit off the initial position
        },

        getTouchAction: function () {
            return [TOUCH_ACTION_MANIPULATION];
        },

        process: function (input) {
            var options = this.options;

            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;

            this.reset();

            if (input.eventType & INPUT_START && this.count === 0) {
                return this.failTimeout();
            }

            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (validMovement && validTouchTime && validPointers) {
                if (input.eventType != INPUT_END) {
                    return this.failTimeout();
                }

                var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

                this.pTime = input.timeStamp;
                this.pCenter = input.center;

                if (!validMultiTap || !validInterval) {
                    this.count = 1;
                } else {
                    this.count += 1;
                }

                this._input = input;

                // if tap count matches we have recognized it,
                // else it has began recognizing...
                var tapCount = this.count % options.taps;
                if (tapCount === 0) {
                    // no failing requirements, immediately trigger the tap event
                    // or wait as long as the multitap interval to trigger
                    if (!this.hasRequireFailures()) {
                        return STATE_RECOGNIZED;
                    } else {
                        this._timer = setTimeoutContext(function () {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.interval, this);
                        return STATE_BEGAN;
                    }
                }
            }
            return STATE_FAILED;
        },

        failTimeout: function () {
            this._timer = setTimeoutContext(function () {
                this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
        },

        reset: function () {
            clearTimeout(this._timer);
        },

        emit: function () {
            if (this.state == STATE_RECOGNIZED) {
                this._input.tapCount = this.count;
                this.manager.emit(this.options.event, this._input);
            }
        }
    });

    /**
     * Simple way to create a manager with a default set of recognizers.
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }

    /**
     * @const {string}
     */
    Hammer.VERSION = '2.0.7';

    /**
     * default settings
     * @namespace
     */
    Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,

        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,

        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,

        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,

        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,

        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, { enable: false }], [PinchRecognizer, { enable: false }, ['rotate']], [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }], [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']], [TapRecognizer], [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']], [PressRecognizer]],

        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
            /**
             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userSelect: 'none',

            /**
             * Disable the Windows Phone grippers when pressing an element.
             * @type {String}
             * @default 'none'
             */
            touchSelect: 'none',

            /**
             * Disables the default callout shown when you touch and hold a touch target.
             * On iOS, when you touch and hold a touch target such as a link, Safari displays
             * a callout containing information about the link. This property allows you to disable that callout.
             * @type {String}
             * @default 'none'
             */
            touchCallout: 'none',

            /**
             * Specifies whether zooming is enabled. Used by IE10>
             * @type {String}
             * @default 'none'
             */
            contentZooming: 'none',

            /**
             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userDrag: 'none',

            /**
             * Overrides the highlight color shown when the user taps a link or a JavaScript
             * clickable element in iOS. This property obeys the alpha value, if specified.
             * @type {String}
             * @default 'rgba(0,0,0,0)'
             */
            tapHighlightColor: 'rgba(0,0,0,0)'
        }
    };

    var STOP = 1;
    var FORCED_STOP = 2;

    /**
     * Manager
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Manager(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});

        this.options.inputTarget = this.options.inputTarget || element;

        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};

        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);

        toggleCssProps(this, true);

        each(this.options.recognizers, function (item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }

    Manager.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function (options) {
            assign(this.options, options);

            // Options that need a little more setup
            if (options.touchAction) {
                this.touchAction.update();
            }
            if (options.inputTarget) {
                // Clean up existing event listeners and reinitialize
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init();
            }
            return this;
        },

        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function (force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
        },

        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function (inputData) {
            var session = this.session;
            if (session.stopped) {
                return;
            }

            // run the touch-action polyfill
            this.touchAction.preventDefaults(inputData);

            var recognizer;
            var recognizers = this.recognizers;

            // this holds the recognizer that is being recognized.
            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
            // if no recognizer is detecting a thing, it is set to `null`
            var curRecognizer = session.curRecognizer;

            // reset when the last recognizer is recognized
            // or when we're in a new session
            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
                curRecognizer = session.curRecognizer = null;
            }

            var i = 0;
            while (i < recognizers.length) {
                recognizer = recognizers[i];

                // find out if we are allowed try to recognize the input for this one.
                // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                //      that is being recognized.
                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                //      this can be setup with the `recognizeWith()` method on the recognizer.
                if (session.stopped !== FORCED_STOP && ( // 1
                !curRecognizer || recognizer == curRecognizer || // 2
                recognizer.canRecognizeWith(curRecognizer))) {
                    // 3
                    recognizer.recognize(inputData);
                } else {
                    recognizer.reset();
                }

                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                // current active recognizer. but only if we don't already have an active recognizer
                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                    curRecognizer = session.curRecognizer = recognizer;
                }
                i++;
            }
        },

        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function (recognizer) {
            if (recognizer instanceof Recognizer) {
                return recognizer;
            }

            var recognizers = this.recognizers;
            for (var i = 0; i < recognizers.length; i++) {
                if (recognizers[i].options.event == recognizer) {
                    return recognizers[i];
                }
            }
            return null;
        },

        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function (recognizer) {
            if (invokeArrayArg(recognizer, 'add', this)) {
                return this;
            }

            // remove existing
            var existing = this.get(recognizer.options.event);
            if (existing) {
                this.remove(existing);
            }

            this.recognizers.push(recognizer);
            recognizer.manager = this;

            this.touchAction.update();
            return recognizer;
        },

        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function (recognizer) {
            if (invokeArrayArg(recognizer, 'remove', this)) {
                return this;
            }

            recognizer = this.get(recognizer);

            // let's make sure this recognizer exists
            if (recognizer) {
                var recognizers = this.recognizers;
                var index = inArray(recognizers, recognizer);

                if (index !== -1) {
                    recognizers.splice(index, 1);
                    this.touchAction.update();
                }
            }

            return this;
        },

        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function (events, handler) {
            if (events === undefined) {
                return;
            }
            if (handler === undefined) {
                return;
            }

            var handlers = this.handlers;
            each(splitStr(events), function (event) {
                handlers[event] = handlers[event] || [];
                handlers[event].push(handler);
            });
            return this;
        },

        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function (events, handler) {
            if (events === undefined) {
                return;
            }

            var handlers = this.handlers;
            each(splitStr(events), function (event) {
                if (!handler) {
                    delete handlers[event];
                } else {
                    handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
                }
            });
            return this;
        },

        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function (event, data) {
            // we also want to trigger dom events
            if (this.options.domEvents) {
                triggerDomEvent(event, data);
            }

            // no handlers, so skip it all
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
                return;
            }

            data.type = event;
            data.preventDefault = function () {
                data.srcEvent.preventDefault();
            };

            var i = 0;
            while (i < handlers.length) {
                handlers[i](data);
                i++;
            }
        },

        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function () {
            this.element && toggleCssProps(this, false);

            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
        }
    };

    /**
     * add/remove the css properties as defined in manager.options.cssProps
     * @param {Manager} manager
     * @param {Boolean} add
     */
    function toggleCssProps(manager, add) {
        var element = manager.element;
        if (!element.style) {
            return;
        }
        var prop;
        each(manager.options.cssProps, function (value, name) {
            prop = prefixed(element.style, name);
            if (add) {
                manager.oldCssProps[prop] = element.style[prop];
                element.style[prop] = value;
            } else {
                element.style[prop] = manager.oldCssProps[prop] || '';
            }
        });
        if (!add) {
            manager.oldCssProps = {};
        }
    }

    /**
     * trigger dom event
     * @param {String} event
     * @param {Object} data
     */
    function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }

    assign(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,

        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,

        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,

        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,

        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,

        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,

        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        assign: assign,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    });

    // this prevents errors when Hammer is loaded in the presence of an AMD
    //  style loader but by script tag, not by the loader.
    var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line
    freeGlobal.Hammer = Hammer;

    if (true) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
            return Hammer;
        }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
})(window, document, 'Hammer');

/***/ }),

/***/ "../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Gallery.vue?vue&type=script&lang=js&":
/*!*************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/babel-loader/lib!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib??vue-loader-options!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Gallery.vue?vue&type=script&lang=js& ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Wrap_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Wrap.vue */ "../../node_modules/apopups-gallery/Wrap.vue");
/* harmony import */ var _Gallery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Gallery */ "../../node_modules/apopups-gallery/Gallery.js");
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




const windowHeight = window.innerHeight;
const windowWidth = window.innerWidth;
/* harmony default export */ __webpack_exports__["default"] = ({
    props: ['show', 'title', 'mediaDatas', 'index'],
    components: {
        WrapVue: _Wrap_vue__WEBPACK_IMPORTED_MODULE_0__["default"]
    },
    mounted() {
        let gallery = new _Gallery__WEBPACK_IMPORTED_MODULE_1__["default"](this.$refs.mediaRef, this.mediaDatas);
        gallery.updateImageIndex(this.index || 0);
        let centerVal = null;
        gallery.on('pinch', obj => {
            let result = obj.result;
            this.zoom(result.scale);
            this.translate = result.slide;
            this.renderer();
            if (result.lastActionData <= 1) {
                this.wrapOpacity = (result.scale - 0.5) / 0.5;
                this.wrapNoTransition = true;
            }
            // this.debug(JSON.stringify(result));
        });
        gallery.on('slide', obj => {
            let result = obj.result;
            let slide = result.slide;
            let slideX = slide.x;
            let curSlideX = this.translate.x;
            let diff = slideX - curSlideX;
            if (result.bound.x.isOver && obj.e.pointers.length === 1) {
                this.imageAttr.next.translate += diff;
                this.imageAttr.previous.translate += diff;
            }
            this.translate = slide;
            let boundY = result.bound.y;
            if (boundY.isOver && slide.y > 0) {
                const touchArea = this.getTouchAreaSize();
                this.wrapOpacity = 1 - Math.abs(boundY.number) / ((touchArea.x || windowHeight) / 2);
                this.wrapNoTransition = true;
            }
            this.renderer();
            // this.debug(JSON.stringify(result)+'_'+obj.e.pointers.length);
        });
        gallery.on('actionend', obj => {
            let result = obj.result;
            let switched = this.imageSwitch(result.switchObj);
            if (!switched && result.correct) {
                this.imageAttrReset(result.scale, result.slide);
            }
            this.wrapNoTransition = false;
            this.wrapOpacity = 1;
        });
        gallery.on('doubletap', obj => {
            let result = obj.result;
            this.doImgTransition(() => {
                this.zoom(result.scale);
                this.translate = result.slide;
                this.renderer();
            });
        });
        gallery.on('swipe', obj => {
            let result = obj.result;
            if (result.switchObj) {
                this.imageSwitch(result.switchObj);
                return;
            }
            let slide = result.slide;
            if (slide) {
                slide = slide.slice();
                this.doImgTransition(() => {
                    this.translate = slide;
                    this.renderer();
                }).then(() => {
                    let result = this.gallery.correct();
                    if (result.correct) {
                        this.doImgTransition(() => {
                            this.translate = result.slide;
                            this.renderer();
                        });
                    }
                });
            }
        });
        gallery.on('close', obj => {
            this.wrapNoTransition = false;
            this.onClose().then(() => {
                this.imageAttrReset(0);
            });
        });
        this.gallery = gallery;
    },
    data() {
        let imageIndex = this.index || 0;
        return {
            showWrap: false,
            wrapNoTransition: false,
            wrapOpacity: 1,
            //内部标志，用于实现动画效果
            visible: false,
            gbOpacity: 0,
            window: window,
            gallery: null,
            transition: {
                img: {
                    enable: false,
                    timerId: null
                }
            },
            imageAttr: {
                show: false,
                index: imageIndex,
                width: 0,
                height: 0,
                scale: 1,
                translate: { x: 0, y: 0 },
                sizes: {},
                next: {
                    translate: windowWidth + 40
                },
                previous: {
                    translate: 0 - windowWidth - 40
                },
                other: {
                    translate: 2 * windowWidth
                },
                created: [],
                style: `transform: translate(0px, 0px); width: 0; height: 0;`
            }
        };
    },
    methods: {
        onClose() {
            return new Promise((reslove, reject) => {
                this.$emit('onClose');
                setTimeout(() => {
                    reslove();
                }, 310);
            });
        },
        imgLoaded(index, event) {
            let imgEl = event.target;
            let height = imgEl.naturalHeight;
            let width = imgEl.naturalWidth;
            const touchArea = this.getTouchAreaSize();
            let ratioX = touchArea.x / width;
            let ratioY = touchArea.y / height;
            let ratio = 1;
            // if((height > innerHeight && windowWidth > innerHeight) 
            //     || (height < innerHeight && height > width && (height-windowWidth) > width)
            //     || (height > width && (height-width) > width)){
            if (height > width && height - width > width) {
                ratio = width * ratioY > touchArea.x ? ratioX : ratioY;
            } else {
                ratio = height * ratioX > touchArea.y ? ratioY : ratioX;
            }
            width *= ratio;
            height *= ratio;
            this.imageAttr.sizes[index] = [Math.round(width), Math.round(height)];
            if (index === this.imageAttr.index) {
                this.showImage(true, index);
            }
        },
        doImgTransition(func) {
            return new Promise((reslove, reject) => {
                clearTimeout(this.transition.img.timerId);
                this.transition.img.enable = true;
                if (func && func instanceof Function) {
                    func();
                }
                this.transition.img.timerId = setTimeout(() => {
                    this.transition.img.enable = false;
                    reslove();
                }, 310);
            });
        },
        debug(info) {
            this.$refs.text.innerHTML = info;
        },
        getImgSize(index, attr) {
            if (this.imageAttr.index === index) {
                return this.imageAttr[attr] + 'px';
            }
            let size = this.imageAttr.sizes[index];
            if (size) {
                return size[attr === 'width' ? 0 : 1] + 'px';
            }
            return 0;
        },
        imageAttrReset(scale, slide) {
            return this.doImgTransition(() => {
                this.zoom(scale >= 0 ? scale : 1);
                this.translate = slide || { x: 0, y: 0 };
                this.nextIamgeReset();
                this.renderer();
            });
        },
        nextIamgeReset() {
            const touchArea = this.getTouchAreaSize();
            this.imageAttr.previous.translate = 0 - touchArea.x - 40;
            this.imageAttr.next.translate = touchArea.x + 40;
        },
        showImage(bool, index) {
            let size = this.imageAttr.sizes[index];
            if (bool && size) {
                this.imageAttr.index = index;
                setTimeout(() => {
                    this.doImgTransition(() => {
                        this.imageAttr.width = size[0];
                        this.imageAttr.height = size[1];
                        this.renderer();
                    });
                }, 10);
            }
            if (!bool) {
                this.doImgTransition(() => {
                    this.imageAttr.width = 0;
                    this.imageAttr.height = 0;
                    this.renderer();
                }).then(() => {
                    this.imageAttr.index = -1;
                });
            }
        },
        isCreated(index) {
            let created = this.imageAttr.created;
            if (created[index]) {
                return true;
            }
            if (index === this.imageAttr.index || index === this.imageAttr.index + 1 || index === this.imageAttr.index + 2 || index === this.imageAttr.index - 1) {
                return created[index] = true;
            }
            return false;
        },
        imageSwitch(switchObj) {
            if (!switchObj.switch) {
                return false;
            }
            switchObj.next ? this.imageAttr.index++ : this.imageAttr.index--;
            let curImgSize = this.imageAttr.sizes[this.imageAttr.index];
            this.imageAttr.width = curImgSize[0];
            this.imageAttr.height = curImgSize[1];
            this.gallery.updateImageIndex(this.imageAttr.index);
            this.imageAttrReset();
            return true;
        },
        renderer() {
            let translate = this.imageAttr.translate;
            let width = this.imageAttr.width;
            let height = this.imageAttr.height;
            this.imageAttr.style = `transform: translate(${translate.x}px, ${translate.y}px); width: ${width}px; height: ${height}px;`;
        },
        otherImgStyle(index) {
            let translate = this.imageAttr.index + 1 === index ? this.imageAttr.next.translate : index > this.imageAttr.index ? this.imageAttr.other.translate : this.imageAttr.index - 1 === index ? this.imageAttr.previous.translate : null;
            let width = this.getImgSize(index, 'width');
            let height = this.getImgSize(index, 'height');
            return `transform: translate(${translate}px); width: ${width}; height: ${height};`;
        },
        zoom(scale) {
            if (this.imageAttr.scale === scale) {
                return;
            }
            this.imageAttr.scale = scale;
            this.imageAttr.width = Number.parseInt(this.imageAttr.sizes[this.imageAttr.index][0] * scale);
            this.imageAttr.height = Number.parseInt(this.imageAttr.sizes[this.imageAttr.index][1] * scale);
        },
        getTouchAreaSize() {
            const touchAreaX = this.$refs.mediaRef.clientWidth;
            const touchAreaY = this.$refs.mediaRef.clientHeight;
            return { x: touchAreaX, y: touchAreaY };
        }
    },
    computed: {
        translate: {
            set(newVal) {
                this.imageAttr.translate.x = newVal.x;
                this.imageAttr.translate.y = newVal.y;
            },
            get() {
                return this.imageAttr.translate;
            }
        }
    },
    watch: {
        show(val) {
            if (val) {
                this.visible = val;
                /**
                 * 此次等待是为了等待dialog显示后再显示wrap
                 */
                setTimeout(() => {
                    this.showWrap = val;
                    setTimeout(() => {
                        //先等Wrap的动画执行到一半的时候再显示内容块
                        this.showImage(true, this.index || 0);
                        this.gbOpacity = 1;
                    }, 150);
                    this.nextIamgeReset();
                }, 150);
            } else {
                this.showWrap = false;
                this.gbOpacity = 0;
                this.showImage(false);
                setTimeout(() => {
                    this.visible = false;
                    this.imageAttr.index = 0;
                }, 310);
            }
        },
        /**
         * 监听缩放比率，然后调整图片大小
         */
        'imageAttr.scale': function (newVal, oldVal) {
            if (newVal === oldVal || newVal <= 0) {
                return;
            }
            this.imageAttr.width = Number.parseInt(this.imageAttr.sizes[this.imageAttr.index][0] * newVal);
            this.imageAttr.height = Number.parseInt(this.imageAttr.sizes[this.imageAttr.index][1] * newVal);
        },
        mediaDatas(datas) {
            let length = datas.length;
            this.imageAttr.length = length;
            this.imageAttr.created = new Array(length);
            this.gallery.setImagesNumber(length);
        }
    }
});

/***/ }),

/***/ "../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Wrap.vue?vue&type=script&lang=js&":
/*!**********************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/babel-loader/lib!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib??vue-loader-options!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Wrap.vue?vue&type=script&lang=js& ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
    created() {},
    props: ['showWrap', 'position', 'opacity', 'noTransition'],
    data() {
        const defaultBkColorHide = 'rgba(0, 0, 0, 0)';
        return {
            backgroundColor: defaultBkColorHide,
            defaultBkColorShow: `rgba(0, 0, 0, ${this.opacity ? this.opacity : 0.5})`,
            defaultBkColorHide
        };
    },
    methods: {
        close() {
            /**
             * 将关闭的控制权交由引用者
             */
            this.$emit('onCloseWrap');
        }
    },
    watch: {
        showWrap(val) {
            /**
             * 该方法用于显示wrap和隐藏wrap的动画操作
             */
            if (val) {
                this.backgroundColor = this.defaultBkColorShow;
            } else {
                this.backgroundColor = this.defaultBkColorHide;
            }
        },
        opacity(val) {
            if (this.showWrap) {
                this.backgroundColor = `rgba(0, 0, 0, ${val ? val : 0.5})`;
            }
        }
    }
});

/***/ }),

/***/ "../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/lib/index.js?!./index/index.vue?vue&type=script&lang=js&":
/*!********************************************************************************************************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/babel-loader/lib!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib??vue-loader-options!./index/index.vue?vue&type=script&lang=js& ***!
  \********************************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var apopups_gallery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apopups-gallery */ "../../node_modules/apopups-gallery/Gallery.vue");
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ __webpack_exports__["default"] = ({
    name: "App",
    components: {
        gallery: apopups_gallery__WEBPACK_IMPORTED_MODULE_0__["default"]
    },
    data() {
        return {
            imageData: [[__webpack_require__(/*! @/imgs/animal-3.jpg */ "../imgs/animal-3.jpg"), __webpack_require__(/*! @/imgs/animal-1.jpg */ "../imgs/animal-1.jpg"), __webpack_require__(/*! @/imgs/animal-2.jpg */ "../imgs/animal-2.jpg"), __webpack_require__(/*! @/imgs/person-2.jpg */ "../imgs/person-2.jpg"), __webpack_require__(/*! @/imgs/person-1.jpg */ "../imgs/person-1.jpg"), __webpack_require__(/*! @/imgs/1.jpg */ "../imgs/1.jpg"), __webpack_require__(/*! @/imgs/2.jpg */ "../imgs/2.jpg"), __webpack_require__(/*! @/imgs/3.jpg */ "../imgs/3.jpg"), __webpack_require__(/*! @/imgs/4.jpg */ "../imgs/4.jpg")], []],
            galleryDatas: [],
            isShow: false
        };
    },
    methods: {
        showGallery(index) {
            this.galleryDatas = this.imageData[index];
            this.isShow = true;
        }
    },
    computed: {}
});

/***/ }),

/***/ "../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/lib/loader.js?!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=0&id=7c0324d9&lang=scss&scoped=true&":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/css-loader!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib/loaders/stylePostLoader.js!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/sass-loader/lib/loader.js??ref--3-2!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib??vue-loader-options!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=0&id=7c0324d9&lang=scss&scoped=true& ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../css-loader/lib/css-base.js */ "../../node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "\n.media-content[data-v-7c0324d9] {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-wrap: nowrap;\n  overflow: hidden;\n  height: 100%;\n  width: 100%;\n  margin: auto;\n}\n.media-content img[data-v-7c0324d9] {\n    height: 0%;\n    width: 0%;\n    display: block;\n    position: absolute;\n}\n.media-content img.width-ratio[data-v-7c0324d9] {\n      height: auto;\n      width: 100%;\n}\n.media-content img.height-ratio[data-v-7c0324d9] {\n      height: 100%;\n      width: auto;\n}\n.media-content img.img-transition[data-v-7c0324d9] {\n      transition: width 0.3s, height 0.3s, transform 0.3s;\n}\n.gallery-bar[data-v-7c0324d9] {\n  transition: opacity 0.3s;\n  position: fixed;\n  bottom: 0;\n  background-color: rgba(0, 0, 0, 0.5);\n  color: white;\n  width: 100%;\n  font-size: 1.3rem;\n  padding-bottom: constant(safe-area-inset-bottom);\n  padding-bottom: env(safe-area-inset-bottom);\n}\n.gallery-bar ul li[data-v-7c0324d9] {\n    padding: 1rem;\n}\n", ""]);

// exports


/***/ }),

/***/ "../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/lib/loader.js?!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Wrap.vue?vue&type=style&index=0&id=65970f5a&lang=scss&scoped=true&":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/css-loader!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib/loaders/stylePostLoader.js!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/sass-loader/lib/loader.js??ref--3-2!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib??vue-loader-options!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Wrap.vue?vue&type=style&index=0&id=65970f5a&lang=scss&scoped=true& ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../css-loader/lib/css-base.js */ "../../node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "\n.wrap .cover[data-v-65970f5a] {\n  z-index: 100;\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.wrap .cover.transition[data-v-65970f5a] {\n    transition: background-color 0.3s;\n}\n.wrap .container[data-v-65970f5a] {\n  width: 100%;\n  position: fixed;\n  z-index: 101;\n  top: 0;\n}\n", ""]);

// exports


/***/ }),

/***/ "../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/lib/loader.js?!../../node_modules/vue-loader/lib/index.js?!./index/index.vue?vue&type=style&index=0&lang=scss&":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/css-loader!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib/loaders/stylePostLoader.js!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/sass-loader/lib/loader.js??ref--3-2!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib??vue-loader-options!./index/index.vue?vue&type=style&index=0&lang=scss& ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ "../../node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "\nhtml, body {\n  font-size: 13px;\n  margin: 0 0;\n  height: 100%;\n  width: 100%;\n  line-height: 1.6rem;\n  text-size-adjust: 100%;\n  background-color: #eaeaea;\n}\nul, ol {\n  list-style-type: none;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  flex-direction: row;\n  flex-wrap: nowrap;\n}\nul, ol, p {\n  padding: 0;\n  margin: 0;\n}\na:visited, a {\n  color: #009fff;\n}\na {\n  text-decoration: none;\n}\ninput[type=button], input[type=submit], input[type=text], input[type=password] {\n  -webkit-appearance: none;\n  outline: none;\n}\n@media screen and (orientation: landscape) {\nhtml, body {\n    padding-top: constant(safe-area-inset-top);\n    padding-top: env(safe-area-inset-top);\n    padding-left: constant(safe-area-inset-left);\n    padding-left: env(safe-area-inset-left);\n    padding-right: constant(safe-area-inset-right);\n    padding-right: env(safe-area-inset-right);\n}\n}\n.top {\n  width: 85%;\n  margin: 2rem auto;\n}\n.top .log {\n    font-weight: bold;\n    font-size: 2rem;\n}\n.top p {\n    color: #dd3c3c;\n    padding: 1rem 0;\n}\n.content {\n  margin-top: 1rem;\n}\n.content .image-list {\n    margin: auto;\n    border-bottom: 0.1rem solid #c5c5c50a;\n    margin-top: 2rem;\n    text-align: center;\n}\n.content .image-list .image-div {\n      margin: 1rem 0;\n      max-height: 20rem;\n      overflow: hidden;\n}\n.content .image-list .image-div img {\n        display: block;\n        width: 100%;\n}\n.doc {\n  max-width: 1200px;\n  background-color: white;\n  padding: 1rem 1rem;\n  margin: auto;\n}\n.doc pre {\n    background-color: #e4e4e4;\n    overflow: auto;\n    padding: 1rem;\n}\n.doc table td {\n    padding: 0.5rem 1rem;\n}\n.doc table td:nth-of-type(1) {\n      font-weight: bold;\n}\n.bootom {\n  padding: 2rem;\n  text-align: center;\n}\n", ""]);

// exports


/***/ }),

/***/ "../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=1&lang=css&":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/css-loader!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib/loaders/stylePostLoader.js!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib??vue-loader-options!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=1&lang=css& ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../css-loader/lib/css-base.js */ "../../node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "\n.wrap .container {\n    height: 100%;\n}\n", ""]);

// exports


/***/ }),

/***/ "../../node_modules/css-loader/lib/css-base.js":
/*!*****************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/css-loader/lib/css-base.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),

/***/ "../../node_modules/process/browser.js":
/*!*********************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/process/browser.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),

/***/ "../../node_modules/setimmediate/setImmediate.js":
/*!*******************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/setimmediate/setImmediate.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function (handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function (event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function (handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function (handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function (handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function (handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../node_modules/timers-browserify/main.js":
/*!****************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/timers-browserify/main.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "../../node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../node_modules/vue-loader/lib/loaders/templateLoader.js?!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Gallery.vue?vue&type=template&id=7c0324d9&scoped=true&":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib??vue-loader-options!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Gallery.vue?vue&type=template&id=7c0324d9&scoped=true& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      directives: [
        {
          name: "show",
          rawName: "v-show",
          value: _vm.visible,
          expression: "visible"
        }
      ],
      ref: "view"
    },
    [
      _c(
        "WrapVue",
        {
          attrs: {
            noTransition: _vm.wrapNoTransition,
            opacity: _vm.wrapOpacity,
            showWrap: _vm.showWrap
          },
          on: { onCloseWrap: _vm.onClose }
        },
        [
          _c(
            "div",
            {
              ref: "mediaRef",
              staticClass: "media-content",
              on: {
                dragstart: function($event) {
                  $event.preventDefault()
                }
              }
            },
            _vm._l(_vm.mediaDatas, function(item, index) {
              return _vm.isCreated(index)
                ? _c("img", {
                    key: index,
                    ref: "imgRefs" + index,
                    refInFor: true,
                    class: [{ "img-transition": _vm.transition.img.enable }],
                    style:
                      index === _vm.imageAttr.index
                        ? _vm.imageAttr.style
                        : _vm.otherImgStyle(index),
                    attrs: { src: item },
                    on: {
                      load: function($event) {
                        _vm.imgLoaded(index, $event)
                      }
                    }
                  })
                : _vm._e()
            })
          ),
          _vm._v(" "),
          _c(
            "div",
            {
              directives: [
                {
                  name: "show",
                  rawName: "v-show",
                  value: _vm.gbOpacity,
                  expression: "gbOpacity"
                }
              ],
              staticClass: "gallery-bar",
              style: { opacity: _vm.gbOpacity }
            },
            [
              _c("ul", [
                _c("li", { on: { click: _vm.onClose } }, [
                  _c("img", {
                    staticStyle: { height: "1.5rem", width: "1.5rem" },
                    attrs: {
                      src:
                        "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAERSURBVGhD7ZlBDoMwDAS5lGv/2kf2WYCNshIHiEKINw7ySKgo1N6dc6YgCIL3sa7rJ73SaZYti77Lsvzl+aUjGpqp2dohHdUBCfndYcpoVorV3HoZGZyPEoAhc5QAqcuc/nKPs4WKpYxZJlPGPIshw8jYsQyiSQCLQLoEaBncTQK0KNBdAjwp4kYC1BRyJwHuFHMrAUoKupcAuaLDSICrwme4lQAlMu4lQE5mGAnlFSI5CeBepkQCuJW5ktDz3Lc07oOSou5l7hR0K1NTzJ3Mk0JuZFoU6S7TskA3GYtguoxlIE2GEWSewZAAZllMCdA8U2bfc60gg+Nf9ABdoIuYEkAzm0gAWTT+ZWgQBIEjpmkDLkjTj6GOoUkAAAAASUVORK5CYII="
                    }
                  })
                ]),
                _vm._v(" "),
                _c("li", [
                  _vm._v(
                    _vm._s(_vm.imageAttr.index + 1) +
                      "/" +
                      _vm._s(_vm.mediaDatas.length)
                  )
                ])
              ])
            ]
          )
        ]
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "../../node_modules/vue-loader/lib/loaders/templateLoader.js?!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Wrap.vue?vue&type=template&id=65970f5a&scoped=true&":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib??vue-loader-options!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Wrap.vue?vue&type=template&id=65970f5a&scoped=true& ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "wrap" }, [
    _c("div", {
      class: ["cover", { transition: !_vm.noTransition }],
      style: { "background-color": _vm.backgroundColor },
      on: { click: _vm.close }
    }),
    _vm._v(" "),
    _c(
      "div",
      { class: ["container", _vm.position ? _vm.position : "center"] },
      [_vm._t("default")],
      2
    )
  ])
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "../../node_modules/vue-loader/lib/loaders/templateLoader.js?!../../node_modules/vue-loader/lib/index.js?!./index/index.vue?vue&type=template&id=4a49fab7&":
/*!**********************************************************************************************************************************************************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib??vue-loader-options!./index/index.vue?vue&type=template&id=4a49fab7& ***!
  \**********************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", [
    _vm._m(0),
    _vm._v(" "),
    _c(
      "div",
      { staticClass: "content" },
      [
        _c("div", { staticClass: "image-list" }, [
          _c("img", {
            attrs: { src: __webpack_require__(/*! @/imgs/thumbnail-1.jpg */ "../imgs/thumbnail-1.jpg") },
            on: {
              click: function($event) {
                _vm.showGallery(0)
              }
            }
          }),
          _vm._v(" "),
          _c("p", [_vm._v("tap this picture")])
        ]),
        _vm._v(" "),
        _c("gallery", {
          attrs: { mediaDatas: _vm.galleryDatas, index: 0, show: _vm.isShow },
          on: {
            onClose: function($event) {
              _vm.isShow = false
            }
          }
        })
      ],
      1
    ),
    _vm._v(" "),
    _vm._m(1),
    _vm._v(" "),
    _vm._m(2)
  ])
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "top" }, [
      _c("div", { staticClass: "log" }, [
        _vm._v("\n            APopups-Gallery\n        ")
      ]),
      _vm._v(" "),
      _c("p", [_vm._v("Current version: 1.0.0 beta")])
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "doc" }, [
      _c("div", { staticClass: "warning" }, [
        _c("h2", [_vm._v("Before starting")]),
        _vm._v("\n            Before using, you need to know about "),
        _c("span", { staticStyle: { color: "red" } }, [_vm._v("vuejs")]),
        _vm._v(" and "),
        _c("span", { staticStyle: { color: "red" } }, [
          _vm._v("vue's single-file component")
        ]),
        _vm._v(" development\n        ")
      ]),
      _vm._v(" "),
      _c("div", { staticClass: "getting-started" }, [
        _c("h2", [_vm._v("Getting started")]),
        _vm._v(" "),
        _c("h4", [_vm._v("Step1: install by npm")]),
        _vm._v(" "),
        _c("p", [
          _c("pre", [_c("code", [_vm._v("npm install popups-gallery-vue")])])
        ]),
        _vm._v(" "),
        _c("h4", [_vm._v("Step2: import gallery vue component")]),
        _vm._v(" "),
        _c("p", [
          _c("pre", [
            _c("code", [
              _vm._v('import gallery from "popups-gallery";'),
              _c("br")
            ])
          ])
        ]),
        _vm._v(" "),
        _c("h4", [_vm._v("Step3: Add to vuejs components")]),
        _vm._v(" "),
        _c("p", [
          _c("pre", [_c("code", [_vm._v("components: { gallery }"), _c("br")])])
        ]),
        _vm._v(" "),
        _c("h4", [_vm._v("Step4: useing gallery component on your vue page")]),
        _vm._v(" "),
        _c("p", [
          _c("pre", [
            _c("code", [
              _vm._v(
                '<gallery :imageDatas="imageDatas" :index="0" :show="isShow" @onClose="isShow=false"></gallery>'
              )
            ])
          ])
        ]),
        _vm._v(" "),
        _c("h4", [_vm._v("Parameter:")]),
        _vm._v(" "),
        _c("table", [
          _c("thead", [
            _c("th", [_vm._v("Name")]),
            _vm._v(" "),
            _c("th", [_vm._v("Type")]),
            _vm._v(" "),
            _c("th", [_vm._v("Required")]),
            _vm._v(" "),
            _c("th", [_vm._v("Description")])
          ]),
          _vm._v(" "),
          _c("tbody", [
            _c("tr", [
              _c("td", [_vm._v("imageDatas")]),
              _vm._v(" "),
              _c("td", [_vm._v("array")]),
              _vm._v(" "),
              _c("td", [_vm._v("true")]),
              _vm._v(" "),
              _c("td", [_vm._v("The images you want to show")])
            ]),
            _vm._v(" "),
            _c("tr", [
              _c("td", [_vm._v("index")]),
              _vm._v(" "),
              _c("td", [_vm._v("number")]),
              _vm._v(" "),
              _c("td", [_vm._v("false")]),
              _vm._v(" "),
              _c("td", [
                _vm._v("The index of the images shown starts at 0. "),
                _c("span", { staticStyle: { color: "red" } }, [
                  _vm._v("defualt: 0")
                ])
              ])
            ]),
            _vm._v(" "),
            _c("tr", [
              _c("td", [_vm._v("show")]),
              _vm._v(" "),
              _c("td", [_vm._v("boolean")]),
              _vm._v(" "),
              _c("td", [_vm._v("true")]),
              _vm._v(" "),
              _c("td", [_vm._v("Display and close flags")])
            ]),
            _vm._v(" "),
            _c("tr", [
              _c("td", [_vm._v("onClose")]),
              _vm._v(" "),
              _c("td", [_vm._v("function")]),
              _vm._v(" "),
              _c("td", [_vm._v("true")]),
              _vm._v(" "),
              _c("td", [
                _vm._v(
                  "You must change the show value to false inside the function"
                )
              ])
            ])
          ])
        ])
      ])
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "bootom" }, [
      _vm._v("\n        License: MIT "),
      _c("a", { staticStyle: { "margin-left": "2rem" } }, [_vm._v("Github")]),
      _vm._v(" "),
      _c(
        "a",
        {
          staticStyle: { "margin-left": "2rem" },
          attrs: { href: "mailto:8019893@qq.com" }
        },
        [_vm._v("8019893@qq.com")]
      )
    ])
  }
]
render._withStripped = true



/***/ }),

/***/ "../../node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "../../node_modules/vue-style-loader/index.js!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/lib/loader.js?!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=0&id=7c0324d9&lang=scss&scoped=true&":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-style-loader!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/css-loader!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib/loaders/stylePostLoader.js!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/sass-loader/lib/loader.js??ref--3-2!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib??vue-loader-options!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=0&id=7c0324d9&lang=scss&scoped=true& ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../css-loader!../vue-loader/lib/loaders/stylePostLoader.js!../sass-loader/lib/loader.js??ref--3-2!../vue-loader/lib??vue-loader-options!./Gallery.vue?vue&type=style&index=0&id=7c0324d9&lang=scss&scoped=true& */ "../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/lib/loader.js?!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=0&id=7c0324d9&lang=scss&scoped=true&");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! ../vue-style-loader/lib/addStylesClient.js */ "../../node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("5741b11d", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "../../node_modules/vue-style-loader/index.js!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/lib/loader.js?!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Wrap.vue?vue&type=style&index=0&id=65970f5a&lang=scss&scoped=true&":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-style-loader!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/css-loader!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib/loaders/stylePostLoader.js!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/sass-loader/lib/loader.js??ref--3-2!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib??vue-loader-options!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Wrap.vue?vue&type=style&index=0&id=65970f5a&lang=scss&scoped=true& ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../css-loader!../vue-loader/lib/loaders/stylePostLoader.js!../sass-loader/lib/loader.js??ref--3-2!../vue-loader/lib??vue-loader-options!./Wrap.vue?vue&type=style&index=0&id=65970f5a&lang=scss&scoped=true& */ "../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/lib/loader.js?!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Wrap.vue?vue&type=style&index=0&id=65970f5a&lang=scss&scoped=true&");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! ../vue-style-loader/lib/addStylesClient.js */ "../../node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("2db74d4c", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "../../node_modules/vue-style-loader/index.js!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/lib/loader.js?!../../node_modules/vue-loader/lib/index.js?!./index/index.vue?vue&type=style&index=0&lang=scss&":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-style-loader!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/css-loader!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib/loaders/stylePostLoader.js!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/sass-loader/lib/loader.js??ref--3-2!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib??vue-loader-options!./index/index.vue?vue&type=style&index=0&lang=scss& ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../../../node_modules/css-loader!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/sass-loader/lib/loader.js??ref--3-2!../../../node_modules/vue-loader/lib??vue-loader-options!./index.vue?vue&type=style&index=0&lang=scss& */ "../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/lib/loader.js?!../../node_modules/vue-loader/lib/index.js?!./index/index.vue?vue&type=style&index=0&lang=scss&");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! ../../../node_modules/vue-style-loader/lib/addStylesClient.js */ "../../node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("5aa450a0", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "../../node_modules/vue-style-loader/index.js!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=1&lang=css&":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-style-loader!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/css-loader!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib/loaders/stylePostLoader.js!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-loader/lib??vue-loader-options!/Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=1&lang=css& ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../css-loader!../vue-loader/lib/loaders/stylePostLoader.js!../vue-loader/lib??vue-loader-options!./Gallery.vue?vue&type=style&index=1&lang=css& */ "../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/vue-loader/lib/index.js?!../../node_modules/apopups-gallery/Gallery.vue?vue&type=style&index=1&lang=css&");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! ../vue-style-loader/lib/addStylesClient.js */ "../../node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("012c1aec", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "../../node_modules/vue-style-loader/lib/addStylesClient.js":
/*!******************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-style-loader/lib/addStylesClient.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return addStylesClient; });
/* harmony import */ var _listToStyles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./listToStyles */ "../../node_modules/vue-style-loader/lib/listToStyles.js");
/* harmony import */ var _listToStyles__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_listToStyles__WEBPACK_IMPORTED_MODULE_0__);
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/



var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

function addStylesClient (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = _listToStyles__WEBPACK_IMPORTED_MODULE_0___default()(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = _listToStyles__WEBPACK_IMPORTED_MODULE_0___default()(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),

/***/ "../../node_modules/vue-style-loader/lib/listToStyles.js":
/*!***************************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue-style-loader/lib/listToStyles.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = listToStyles;
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles(parentId, list) {
  var styles = [];
  var newStyles = {};
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = item[0];
    var css = item[1];
    var media = item[2];
    var sourceMap = item[3];
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    };
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] });
    } else {
      newStyles[id].parts.push(part);
    }
  }
  return styles;
}

/***/ }),

/***/ "../../node_modules/vue/dist/vue.runtime.esm.js":
/*!******************************************************************************************!*\
  !*** /Users/ouwei/Desktop/APopups-Gallery-Demo/node_modules/vue/dist/vue.runtime.esm.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!
 * Vue.js v2.5.17
 * (c) 2014-2018 Evan You
 * Released under the MIT License.
 */
/*  */

var emptyObject = Object.freeze({});

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}

/**
 * Check if value is primitive
 */
function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' ||
  // $flow-disable-line
  typeof value === 'symbol' || typeof value === 'boolean';
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}

/**
 * Get the raw type string of a value e.g. [object Object]
 */
var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString(val) {
  return val == null ? '' : typeof val === 'object' ? JSON.stringify(val, null, 2) : String(val);
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array
 */
function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});

/**
 * Simple bind polyfill for environments that do not support it... e.g.
 * PhantomJS 1.x. Technically we don't need this anymore since native bind is
 * now more performant in most browsers, but removing it would be breaking for
 * code that was able to run in PhantomJS 1.x, so this must be kept for
 * backwards compatibility.
 */

/* istanbul ignore next */
function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind = Function.prototype.bind ? nativeBind : polyfillBind;

/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}

/**
 * Mix properties into target object.
 */
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop(a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) {
  return false;
};

/**
 * Return same value
 */
var identity = function (_) {
  return _;
};

/**
 * Generate a static keys string from compiler modules.
 */

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
  if (a === b) {
    return true;
  }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}

function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }
  return -1;
}

/**
 * Ensure a function is called only once.
 */
function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = ['component', 'directive', 'filter'];

var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured'];

/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};

/*  */

/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}

/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }
      obj = obj[segments[i]];
    }
    return obj;
  };
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = {}.watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer;
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = function () {
    function Set() {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };
    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = noop; // work around flow check
var formatComponentName = noop;

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }
    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) {
        res += str;
      }
      if (n > 1) {
        str += str;
      }
      n >>= 1;
    }
    return res;
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}

/*  */

var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget(_target) {
  if (Dep.target) {
    targetStack.push(Dep.target);
  }
  Dep.target = _target;
}

function popTarget() {
  Dep.target = targetStack.pop();
}

/*  */

var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function (text) {
  if (text === void 0) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.isCloned = true;
  return cloned;
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;
    while (len--) args[len] = arguments[len];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) {
      ob.observeArray(inserted);
    }
    // notify change
    ob.dep.notify();
    return result;
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;

function toggleObserving(value) {
  shouldObserve = value;
}

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto ? protoAugment : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive(obj, keys[i]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment(target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return;
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob;
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive(obj, key, val, customSetter, shallow) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  if (!getter && arguments.length === 2) {
    val = obj[key];
  }
  var setter = property && property.set;

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */
      if ("development" !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set(target, key, val) {
  if ("development" !== 'production' && (isUndef(target) || isPrimitive(target))) {
    warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    "development" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }
  if (!ob) {
    target[key] = val;
    return val;
  }
  defineReactive(ob.value, key, val);
  ob.dep.notify();
  return val;
}

/**
 * Delete a property and trigger change if necessary.
 */
function del(target, key) {
  if ("development" !== 'production' && (isUndef(target) || isPrimitive(target))) {
    warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    "development" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }
  if (!hasOwn(target, key)) {
    return;
  }
  delete target[key];
  if (!ob) {
    return;
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }
    return defaultStrat(parent, child);
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from) {
  if (!from) {
    return to;
  }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}

/**
 * Data
 */
function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      "development" !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);

      return parentVal;
    }
    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook(parentVal, childVal) {
  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    "development" !== 'production' && assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }
  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (true) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }
  return ret;
};

/**
 * Other object hashes.
 */
strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) {
    extend(ret, childVal);
  }
  return ret;
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};

/**
 * Validate component names
 */
function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!/^[a-zA-Z][\w-]*$/.test(name)) {
    warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options, vm) {
  var props = options.props;
  if (!props) {
    return;
  }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (true) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : { type: val };
    }
  } else if (true) {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject(options, vm) {
  var inject = options.inject;
  if (!inject) {
    return;
  }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };
    }
  } else if (true) {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives(options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options;
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) {
    return assets[id];
  }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if ("development" !== 'production' && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }
  return res;
}

/*  */

function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // boolean casting
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  if (true) {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if ("development" !== 'production' && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}

/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn("Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ') + ", got " + toRawType(value) + ".", vm);
    return;
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  };
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }
  return -1;
}

/*  */

function handleError(err, vm, info) {
  if (vm) {
    var cur = vm;
    while (cur = cur.$parent) {
      var hooks = cur.$options.errorCaptured;
      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;
            if (capture) {
              return;
            }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }
  globalHandleError(err, vm, info);
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      logError(e, null, 'config.errorHandler');
    }
  }
  logError(err, vm, info);
}

function logError(err, vm, info) {
  if (true) {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}

/*  */
/* globals MessageChannel */

var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using both microtasks and (macro) tasks.
// In < 2.4 we used microtasks everywhere, but there are some scenarios where
// microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690) or even between bubbling of the same
// event (#6566). However, using (macro) tasks everywhere also has subtle problems
// when state is changed right before repaint (e.g. #6813, out-in transitions).
// Here we use microtask by default, but expose a way to force (macro) task when
// needed (e.g. in event handlers attached by v-on).
var microTimerFunc;
var macroTimerFunc;
var useMacroTask = false;

// Determine (macro) task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.
/* istanbul ignore if */
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) ||
// PhantomJS
MessageChannel.toString() === '[object MessageChannelConstructor]')) {
  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = flushCallbacks;
  macroTimerFunc = function () {
    port.postMessage(1);
  };
} else {
  /* istanbul ignore next */
  macroTimerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

// Determine microtask defer implementation.
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  microTimerFunc = function () {
    p.then(flushCallbacks);
    // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) {
      setTimeout(noop);
    }
  };
} else {
  // fallback to macro
  microTimerFunc = macroTimerFunc;
}

/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a (macro) task instead of a microtask.
 */
function withMacroTask(fn) {
  return fn._withTask || (fn._withTask = function () {
    useMacroTask = true;
    var res = fn.apply(null, arguments);
    useMacroTask = false;
    return res;
  });
}

function nextTick(cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    if (useMacroTask) {
      macroTimerFunc();
    } else {
      microTimerFunc();
    }
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}

/*  */

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (true) {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed;
    }
  };

  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse(val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns) {
  function invoker() {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments);
    }
  }
  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, vm) {
  var name, def, cur, old, event;
  for (name in on) {
    def = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    /* istanbul ignore if */
    if (isUndef(cur)) {
      "development" !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return;
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (true) {
        var keyInLowerCase = key.toLowerCase();
        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }
  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true;
    }
  }
  return false;
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }
  return children;
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i);
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res;
}

/*  */

function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }
  return isObject(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node;
}

function resolveAsyncComponent(factory, baseCtor, context) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function () {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      "development" !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject( true ? "timeout (" + res.timeout + "ms)" : undefined);
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}

/*  */

function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}

/*  */

function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}

/*  */

/*  */

function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn, once) {
  if (once) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$off(event[i], fn);
      }
      return vm;
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm;
    }
    if (!fn) {
      vm._events[event] = null;
      return vm;
    }
    if (fn) {
      // specific handler
      var cb;
      var i$1 = cbs.length;
      while (i$1--) {
        cb = cbs[i$1];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i$1, 1);
          break;
        }
      }
    }
    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (true) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, "event handler for \"" + event + "\"");
        }
      }
    }
    return vm;
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
  var slots = {};
  if (!children) {
    return slots;
  }
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}

function resolveScopedSlots(fns, // see flow/vnode
res) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res;
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle(vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
      , vm.$options._parentElm, vm.$options._refElm);
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return;
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (true) {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if ("development" !== 'production' && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if (true) {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  parentVnode.data.scopedSlots || // has new scoped slots
  vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?
      props[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners);

  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (true) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }
  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return;
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, hook + " hook");
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (true) {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) {
    return a.id - b.id;
  });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if ("development" !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$1 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$1; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true ? expOrFn.toString() : undefined;
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      "development" !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }
  this.value = this.lazy ? undefined : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value;
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();
    if (value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown() {
  var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) {
    initProps(vm, opts.props);
  }
  if (opts.methods) {
    initMethods(vm, opts.methods);
  }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) {
    initComputed(vm, opts.computed);
  }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (true) {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }
      defineReactive(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {}
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);
  toggleObserving(true);
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
  if (!isPlainObject(data)) {
    data = {};
    "development" !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }
    if (props && hasOwn(props, key)) {
      "development" !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData(data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();
  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if ("development" !== 'production' && getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
  }
  if ("development" !== 'production' && sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (true) {
      if (methods[key] == null) {
        warn("Method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
      }
      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }
      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () {
    return this._data;
  };
  var propsDef = {};
  propsDef.get = function () {
    return this._props;
  };
  if (true) {
    dataDef.set = function (newData) {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };
}

/*  */

function initProvide(vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      } else {}
    });
    toggleObserving(true);
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {
      /* istanbul ignore next */
      return Object.getOwnPropertyDescriptor(inject, key).enumerable;
    }) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break;
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else if (true) {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }
    return result;
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    ret._isVList = true;
  }
  return ret;
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      if ("development" !== 'production' && !isObject(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes) {
      if ("development" !== 'production' && slotNodes._rendered) {
        warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
      }
      slotNodes._rendered = true;
    }
    nodes = slotNodes || fallback;
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes);
  } else {
    return nodes;
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}

/*  */

function isKeyNotMatch(expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject(value)) {
      "development" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function (key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on["update:" + key] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop(key);
    }
  }
  return data;
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.
  if (tree && !isInFor) {
    return tree;
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__" + index, false);
  return tree;
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      "development" !== 'production' && warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data;
}

/*  */

function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
}

/*  */

function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var options = Ctor.options;
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm;
  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent);
    // $flow-disable-line
    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent;
    // $flow-disable-line
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () {
    return resolveSlots(children, parent);
  };

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = data.scopedSlots || emptyObject;
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }
    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options);
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);
    }
    return res;
  }
}

function cloneAndMarkFunctionalResult(vnode, data, contextVm, options) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

// Register the component hook to weex native render engine.
// The hook will be triggered by native, not javascript.


// Updates the state of the component to weex native render engine.

/*  */

// https://github.com/Hanks10100/weex-native-directive/tree/master/component

// listening on native callback

/*  */

/*  */

// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init(vnode, hydrating, parentElm, refElm) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },

  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },

  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (true) {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);

  // Weex specific: invoke recycle-list optimized @render function for
  // extracting cell-slot template.
  // https://github.com/Hanks10100/weex-native-directive/tree/master/component
  /* istanbul ignore if */
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent, // activeInstance in lifecycle state
parentElm, refElm) {
  var options = {
    _isComponent: true,
    parent: parent,
    _parentVnode: vnode,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options);
}

function installComponentHooks(data) {
  var hooks = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    hooks[key] = componentVNodeHooks[key];
  }
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    "development" !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  }
  // warn against non-primitive key
  if ("development" !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns)) {
      applyNS(vnode, ns);
    }
    if (isDef(data)) {
      registerDeepBindings(data);
    }
    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
        applyNS(child, ns, force);
      }
    }
  }
}

// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings(data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}

/*  */

function initRender(vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (true) {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {}
}

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    // reset _rendered flag on slots for duplicate slot check
    if (true) {
      for (var key in vm.$slots) {
        // $flow-disable-line
        vm.$slots[key]._rendered = false;
      }
    }

    if (_parentVnode) {
      vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject;
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (true) {
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } else {}
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if ("development" !== 'production' && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode;
  };
}

/*  */

var uid$3 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$3++;

    var startTag, endTag;
    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */
    if (true) {
      initProxy(vm);
    } else {}
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified;
}

function dedupe(latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res;
  } else {
    return latest;
  }
}

function Vue(options) {
  if ("development" !== 'production' && !(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);

/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this;
  };
}

/*  */

function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}

/*  */

function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;
    if ("development" !== 'production' && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if ("development" !== 'production' && type === 'component') {
          validateComponentName(id);
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}

/*  */

function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */
  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var cached$$1 = cache[key];
  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed() {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache, key, this$1.keys);
    }
  },

  mounted: function mounted() {
    var this$1 = this;

    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) {
        return matches(val, name);
      });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) {
        return !matches(val, name);
      });
    });
  },

  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
      // not included
      include && (!name || !matches(include, name)) ||
      // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
      // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode || slot && slot[0];
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive

  /*  */

};function initGlobalAPI(Vue) {
  // config
  var configDef = {};
  configDef.get = function () {
    return config;
  };
  if (true) {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
});

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});

Vue.version = '2.5.17';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};

/*  */

function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */
  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }
  if (isObject(value)) {
    return stringifyObject(value);
  }
  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */
  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }
      res += stringified;
    }
  }
  return res;
}

function stringifyObject(value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }
      res += key;
    }
  }
  return res;
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }
  if (isReservedTag(tag)) {
    return false;
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      "development" !== 'production' && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }
    return selected;
  } else {
    return el;
  }
}

/*  */

function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm;
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps = Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});

/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!isDef(key)) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) {
      map[key] = i;
    }
  }
  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove() {
      if (--remove.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove.listeners = listeners;
    return remove;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;

  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }

      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if ("development" !== 'production' && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break;
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (true) {
        checkDuplicateKeys(children);
      }
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }
      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope(vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }
      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    if (true) {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};
    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return;
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }
      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    }
    // assert node match
    if (true) {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true /* hydrating */);
      }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ("development" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ("development" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false;
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }
      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (true) {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);

        // create new node
        createElm(vnode, insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);
  if (!dirs) {
    // $flow-disable-line
    return res;
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  // $flow-disable-line
  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];

/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.
    /* istanbul ignore if */
    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && !el.__ieph) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };
      el.addEventListener('input', blocker);
      // $flow-disable-line
      el.__ieph = true; /* IE placeholder patched */
    }
    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs

  /*  */

};function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass

  /*  */

  /*  */

  // add a raw attr (use this in preTransforms)


  // note: this only removes the attr from the Array (attrsList) so that it
  // doesn't get processed by processAttrs.
  // By default it does NOT remove it from the map (attrsMap) because the map is
  // needed during codegen.

  /*  */

  /**
   * Cross-platform code generation for component v-model
   */

  /**
   * Cross-platform codegen helper for generating v-model value assignment code.
   */

  /*  */

  // in some cases, the event used has to be determined at runtime
  // so we used some reserved tokens during compile.
};var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler(handler, event, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler() {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
}

function add$1(event, handler, once$$1, capture, passive) {
  handler = withMacroTask(handler);
  if (once$$1) {
    handler = createOnceHandler(handler, event, capture);
  }
  target$1.addEventListener(event, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
}

function remove$2(event, handler, capture, _target) {
  (_target || target$1).removeEventListener(event, handler._withTask || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners

  /*  */

};function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }
      if (cur === oldProps[key]) {
        continue;
      }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}

function isNotInFocusAndDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}
  return notInFocus && elm.value !== checkVal;
}

function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers)) {
    if (modifiers.lazy) {
      // inputs with lazy should only be updated when not in focus
      return false;
    }
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }
  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps

  /*  */

};var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle ? extend(data.staticStyle, style) : style;
}

// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }
  return bindingStyle;
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res;
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle

  /*  */

  /**
   * Add class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */
};function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition(def) {
  if (!def) {
    return;
  }
  /* istanbul ignore else */
  if (typeof def === 'object') {
    var res = {};
    if (def.css !== false) {
      extend(res, autoCssTransition(def.name || 'v'));
    }
    extend(res, def);
    return res;
  } else if (typeof def === 'string') {
    return autoCssTransition(def);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : /* istanbul ignore next */function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) {
    return cb();
  }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}

function toMs(s) {
  return Number(s.slice(0, -1)) * 1000;
}

/*  */

function enter(vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return;
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if ("development" !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);
      if (!cb.cancelled) {
        addTransitionClass(el, toClass);
        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if ("development" !== 'production' && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [attrs, klass, events, domProps, style, transition];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd);
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    "development" !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return;
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (!value === !oldValue) {
      return;
    }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: directive,
  show: show

  /*  */

  // Provides transition support for a single element/component.
  // supports transition mode (out-in / in-out)

};var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render(h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return;
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) {
      return c.tag || isAsyncPlaceholder(c);
    });
    /* istanbul ignore if */
    if (!children.length) {
      return;
    }

    // warn multiple elements
    if ("development" !== 'production' && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode;

    // warn invalid mode
    if ("development" !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) {
      return d.name === 'show';
    })) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) &&
    // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }
        var delayedLeave;
        var performLeave = function () {
          delayedLeave();
        };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }

  /*  */

  // Provides transition support for list items.
  // supports move transitions using the FLIP technique.

  // Because the vdom's children update algorithm is "unstable" - i.e.
  // it doesn't guarantee the relative positioning of removed elements,
  // we force transition-group to update its children into two passes:
  // in the first pass, we remove all nodes that need to be removed,
  // triggering their leaving transition; in the second pass, we insert/move
  // into the final desired state. This way in the second pass removed
  // nodes will remain where they should be.

};var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
        } else if (true) {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },

  beforeUpdate: function beforeUpdate() {
    // force removing pass
    this.__patch__(this._vnode, this.kept, false, // hydrating
    true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove;
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup

  /*  */

  // install platform specific utils
};Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
};

// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if ("development" !== 'production' && "development" !== 'test' && isChrome) {
        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
      }
    }
    if ("development" !== 'production' && "development" !== 'test' && config.productionTip !== false && typeof console !== 'undefined') {
      console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);
}

/*  */

/* harmony default export */ __webpack_exports__["default"] = (Vue);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "../../node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),

/***/ "../imgs/1.jpg":
/*!*********************!*\
  !*** ../imgs/1.jpg ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "imgs/fba734e0a4306df3e979997611351c49.jpg";

/***/ }),

/***/ "../imgs/2.jpg":
/*!*********************!*\
  !*** ../imgs/2.jpg ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "imgs/0490971dc8a28391a69f114755298dac.jpg";

/***/ }),

/***/ "../imgs/3.jpg":
/*!*********************!*\
  !*** ../imgs/3.jpg ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "imgs/b99c7664631c1308c84ba999644729a5.jpg";

/***/ }),

/***/ "../imgs/4.jpg":
/*!*********************!*\
  !*** ../imgs/4.jpg ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "imgs/9aea93f1c3cb18404b9c44ba0aa36bde.jpg";

/***/ }),

/***/ "../imgs/animal-1.jpg":
/*!****************************!*\
  !*** ../imgs/animal-1.jpg ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "imgs/651f27f321246163f6bcd433e36dba59.jpg";

/***/ }),

/***/ "../imgs/animal-2.jpg":
/*!****************************!*\
  !*** ../imgs/animal-2.jpg ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "imgs/69106d33f9f298fba6c8ad9a7989a2d8.jpg";

/***/ }),

/***/ "../imgs/animal-3.jpg":
/*!****************************!*\
  !*** ../imgs/animal-3.jpg ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "imgs/f74fdd1c93811cceca0c83128300b8a6.jpg";

/***/ }),

/***/ "../imgs/person-1.jpg":
/*!****************************!*\
  !*** ../imgs/person-1.jpg ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "imgs/10da7f8fb943f4c43670e5f776a233c3.jpg";

/***/ }),

/***/ "../imgs/person-2.jpg":
/*!****************************!*\
  !*** ../imgs/person-2.jpg ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "imgs/02140c3a61fb6855ec3ce038fe5ef674.jpg";

/***/ }),

/***/ "../imgs/thumbnail-1.jpg":
/*!*******************************!*\
  !*** ../imgs/thumbnail-1.jpg ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "imgs/aa490c2b3566075a63e8c6331657dc6e.jpg";

/***/ }),

/***/ "./index/index.js":
/*!************************!*\
  !*** ./index/index.js ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "../../node_modules/vue/dist/vue.runtime.esm.js");
/* harmony import */ var _index_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.vue */ "./index/index.vue");



new vue__WEBPACK_IMPORTED_MODULE_0__["default"]({
    el: "#app",
    components: { Index: _index_vue__WEBPACK_IMPORTED_MODULE_1__["default"] },
    render(h) {
        return h('Index');
    }
});

/***/ }),

/***/ "./index/index.vue":
/*!*************************!*\
  !*** ./index/index.vue ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_vue_vue_type_template_id_4a49fab7___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.vue?vue&type=template&id=4a49fab7& */ "./index/index.vue?vue&type=template&id=4a49fab7&");
/* harmony import */ var _index_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.vue?vue&type=script&lang=js& */ "./index/index.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport *//* harmony import */ var _index_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.vue?vue&type=style&index=0&lang=scss& */ "./index/index.vue?vue&type=style&index=0&lang=scss&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "../../node_modules/vue-loader/lib/runtime/componentNormalizer.js");






/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _index_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _index_vue_vue_type_template_id_4a49fab7___WEBPACK_IMPORTED_MODULE_0__["render"],
  _index_vue_vue_type_template_id_4a49fab7___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "index/index.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./index/index.vue?vue&type=script&lang=js&":
/*!**************************************************!*\
  !*** ./index/index.vue?vue&type=script&lang=js& ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib!../../../node_modules/vue-loader/lib??vue-loader-options!./index.vue?vue&type=script&lang=js& */ "../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/lib/index.js?!./index/index.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./index/index.vue?vue&type=style&index=0&lang=scss&":
/*!***********************************************************!*\
  !*** ./index/index.vue?vue&type=style&index=0&lang=scss& ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_ref_3_2_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-style-loader!../../../node_modules/css-loader!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/sass-loader/lib/loader.js??ref--3-2!../../../node_modules/vue-loader/lib??vue-loader-options!./index.vue?vue&type=style&index=0&lang=scss& */ "../../node_modules/vue-style-loader/index.js!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/lib/loader.js?!../../node_modules/vue-loader/lib/index.js?!./index/index.vue?vue&type=style&index=0&lang=scss&");
/* harmony import */ var _node_modules_vue_style_loader_index_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_ref_3_2_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_ref_3_2_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_ref_3_2_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_vue_style_loader_index_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_ref_3_2_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_vue_style_loader_index_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_ref_3_2_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),

/***/ "./index/index.vue?vue&type=template&id=4a49fab7&":
/*!********************************************************!*\
  !*** ./index/index.vue?vue&type=template&id=4a49fab7& ***!
  \********************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_4a49fab7___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib??vue-loader-options!./index.vue?vue&type=template&id=4a49fab7& */ "../../node_modules/vue-loader/lib/loaders/templateLoader.js?!../../node_modules/vue-loader/lib/index.js?!./index/index.vue?vue&type=template&id=4a49fab7&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_4a49fab7___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_4a49fab7___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9vdXdlaS9EZXNrdG9wL0FQb3B1cHMtR2FsbGVyeS1EZW1vL25vZGVfbW9kdWxlcy9hcG9wdXBzLWdhbGxlcnkvR2FsbGVyeS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL291d2VpL0Rlc2t0b3AvQVBvcHVwcy1HYWxsZXJ5LURlbW8vbm9kZV9tb2R1bGVzL2Fwb3B1cHMtZ2FsbGVyeS9HYWxsZXJ5LnZ1ZSIsIndlYnBhY2s6Ly8vL1VzZXJzL291d2VpL0Rlc2t0b3AvQVBvcHVwcy1HYWxsZXJ5LURlbW8vbm9kZV9tb2R1bGVzL2Fwb3B1cHMtZ2FsbGVyeS9HYWxsZXJ5LnZ1ZT8yM2ZhIiwid2VicGFjazovLy8vVXNlcnMvb3V3ZWkvRGVza3RvcC9BUG9wdXBzLUdhbGxlcnktRGVtby9ub2RlX21vZHVsZXMvYXBvcHVwcy1nYWxsZXJ5L0dhbGxlcnkudnVlPzI1YzQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9vdXdlaS9EZXNrdG9wL0FQb3B1cHMtR2FsbGVyeS1EZW1vL25vZGVfbW9kdWxlcy9hcG9wdXBzLWdhbGxlcnkvR2FsbGVyeS52dWU/ZDk5NCIsIndlYnBhY2s6Ly8vL1VzZXJzL291d2VpL0Rlc2t0b3AvQVBvcHVwcy1HYWxsZXJ5LURlbW8vbm9kZV9tb2R1bGVzL2Fwb3B1cHMtZ2FsbGVyeS9HYWxsZXJ5LnZ1ZT8zZDgyIiwid2VicGFjazovLy8vVXNlcnMvb3V3ZWkvRGVza3RvcC9BUG9wdXBzLUdhbGxlcnktRGVtby9ub2RlX21vZHVsZXMvYXBvcHVwcy1nYWxsZXJ5L1dyYXAudnVlIiwid2VicGFjazovLy8vVXNlcnMvb3V3ZWkvRGVza3RvcC9BUG9wdXBzLUdhbGxlcnktRGVtby9ub2RlX21vZHVsZXMvYXBvcHVwcy1nYWxsZXJ5L1dyYXAudnVlPzVmYTMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9vdXdlaS9EZXNrdG9wL0FQb3B1cHMtR2FsbGVyeS1EZW1vL25vZGVfbW9kdWxlcy9hcG9wdXBzLWdhbGxlcnkvV3JhcC52dWU/ODU3YyIsIndlYnBhY2s6Ly8vL1VzZXJzL291d2VpL0Rlc2t0b3AvQVBvcHVwcy1HYWxsZXJ5LURlbW8vbm9kZV9tb2R1bGVzL2Fwb3B1cHMtZ2FsbGVyeS9XcmFwLnZ1ZT8wNmUyIiwid2VicGFjazovLy8vVXNlcnMvb3V3ZWkvRGVza3RvcC9BUG9wdXBzLUdhbGxlcnktRGVtby9ub2RlX21vZHVsZXMvYXBvcHVwcy1nYWxsZXJ5L25vZGVfbW9kdWxlcy9oYW1tZXJqcy9oYW1tZXIuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9hcG9wdXBzLWdhbGxlcnkvR2FsbGVyeS52dWUiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9hcG9wdXBzLWdhbGxlcnkvV3JhcC52dWUiLCJ3ZWJwYWNrOi8vL2luZGV4L2luZGV4LnZ1ZSIsIndlYnBhY2s6Ly8vL1VzZXJzL291d2VpL0Rlc2t0b3AvQVBvcHVwcy1HYWxsZXJ5LURlbW8vbm9kZV9tb2R1bGVzL2Fwb3B1cHMtZ2FsbGVyeS9HYWxsZXJ5LnZ1ZT8wYmUyIiwid2VicGFjazovLy8vVXNlcnMvb3V3ZWkvRGVza3RvcC9BUG9wdXBzLUdhbGxlcnktRGVtby9ub2RlX21vZHVsZXMvYXBvcHVwcy1nYWxsZXJ5L1dyYXAudnVlPzJlNTUiLCJ3ZWJwYWNrOi8vLy4vaW5kZXgvaW5kZXgudnVlP2Y1ODkiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9vdXdlaS9EZXNrdG9wL0FQb3B1cHMtR2FsbGVyeS1EZW1vL25vZGVfbW9kdWxlcy9hcG9wdXBzLWdhbGxlcnkvR2FsbGVyeS52dWU/Y2UxNCIsIndlYnBhY2s6Ly8vL1VzZXJzL291d2VpL0Rlc2t0b3AvQVBvcHVwcy1HYWxsZXJ5LURlbW8vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8vVXNlcnMvb3V3ZWkvRGVza3RvcC9BUG9wdXBzLUdhbGxlcnktRGVtby9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8vVXNlcnMvb3V3ZWkvRGVza3RvcC9BUG9wdXBzLUdhbGxlcnktRGVtby9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL291d2VpL0Rlc2t0b3AvQVBvcHVwcy1HYWxsZXJ5LURlbW8vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9vdXdlaS9EZXNrdG9wL0FQb3B1cHMtR2FsbGVyeS1EZW1vL25vZGVfbW9kdWxlcy9hcG9wdXBzLWdhbGxlcnkvR2FsbGVyeS52dWU/OGI0YSIsIndlYnBhY2s6Ly8vL1VzZXJzL291d2VpL0Rlc2t0b3AvQVBvcHVwcy1HYWxsZXJ5LURlbW8vbm9kZV9tb2R1bGVzL2Fwb3B1cHMtZ2FsbGVyeS9XcmFwLnZ1ZT81YTEwIiwid2VicGFjazovLy8uL2luZGV4L2luZGV4LnZ1ZT81ZTlkIiwid2VicGFjazovLy8vVXNlcnMvb3V3ZWkvRGVza3RvcC9BUG9wdXBzLUdhbGxlcnktRGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzIiwid2VicGFjazovLy8vVXNlcnMvb3V3ZWkvRGVza3RvcC9BUG9wdXBzLUdhbGxlcnktRGVtby9ub2RlX21vZHVsZXMvYXBvcHVwcy1nYWxsZXJ5L0dhbGxlcnkudnVlP2MxYjMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9vdXdlaS9EZXNrdG9wL0FQb3B1cHMtR2FsbGVyeS1EZW1vL25vZGVfbW9kdWxlcy9hcG9wdXBzLWdhbGxlcnkvV3JhcC52dWU/Y2YzZiIsIndlYnBhY2s6Ly8vLi9pbmRleC9pbmRleC52dWU/NGFhZiIsIndlYnBhY2s6Ly8vL1VzZXJzL291d2VpL0Rlc2t0b3AvQVBvcHVwcy1HYWxsZXJ5LURlbW8vbm9kZV9tb2R1bGVzL2Fwb3B1cHMtZ2FsbGVyeS9HYWxsZXJ5LnZ1ZT9iMDA0Iiwid2VicGFjazovLy8vVXNlcnMvb3V3ZWkvRGVza3RvcC9BUG9wdXBzLUdhbGxlcnktRGVtby9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzIiwid2VicGFjazovLy8vVXNlcnMvb3V3ZWkvRGVza3RvcC9BUG9wdXBzLUdhbGxlcnktRGVtby9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzIiwid2VicGFjazovLy8vVXNlcnMvb3V3ZWkvRGVza3RvcC9BUG9wdXBzLUdhbGxlcnktRGVtby9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuZXNtLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltZ3MvMS5qcGciLCJ3ZWJwYWNrOi8vLy4uL2ltZ3MvMi5qcGciLCJ3ZWJwYWNrOi8vLy4uL2ltZ3MvMy5qcGciLCJ3ZWJwYWNrOi8vLy4uL2ltZ3MvNC5qcGciLCJ3ZWJwYWNrOi8vLy4uL2ltZ3MvYW5pbWFsLTEuanBnIiwid2VicGFjazovLy8uLi9pbWdzL2FuaW1hbC0yLmpwZyIsIndlYnBhY2s6Ly8vLi4vaW1ncy9hbmltYWwtMy5qcGciLCJ3ZWJwYWNrOi8vLy4uL2ltZ3MvcGVyc29uLTEuanBnIiwid2VicGFjazovLy8uLi9pbWdzL3BlcnNvbi0yLmpwZyIsIndlYnBhY2s6Ly8vLi4vaW1ncy90aHVtYm5haWwtMS5qcGciLCJ3ZWJwYWNrOi8vLy4vaW5kZXgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaW5kZXgvaW5kZXgudnVlIiwid2VicGFjazovLy8uL2luZGV4L2luZGV4LnZ1ZT9iYTBiIiwid2VicGFjazovLy8uL2luZGV4L2luZGV4LnZ1ZT9mMmE1Iiwid2VicGFjazovLy8uL2luZGV4L2luZGV4LnZ1ZT80MGZhIl0sIm5hbWVzIjpbIkRFRkFVTFRfT1BUSU9OUyIsIm1heFNjYWxlIiwibWluU2NhbGUiLCJjbG9zZVRocmVzaG9sZCIsIkFYSVNfU1lNQk9MIiwiR2FsbGVyeSIsImNvbnN0cnVjdG9yIiwidG91Y2hBcmVhIiwib3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsImNhbGN1bGF0b3IiLCJHZXN0dXJlQ2FsY3VsYXRvciIsImluaXQiLCJtYW5hZ2VyIiwiSGFtbWVyIiwiTWFuYWdlciIsImFkZCIsIlBhbiIsInRocmVzaG9sZCIsInBvaW50ZXJzIiwiUGluY2giLCJyZWNvZ25pemVXaXRoIiwiZ2V0IiwiU3dpcGUiLCJUYXAiLCJldmVudCIsInRhcHMiLCJvbiIsImV2ZW50TmFtZSIsImNhbGxiYWNrIiwicHJveHkiLCJldmVudHMiLCJFcnJvciIsImNhbGxiYWNrcyIsImNhbGwiLCJ1cGRhdGVJbWFnZUluZGV4IiwibmV3SW5kZXgiLCJjdXJJbWdJbmRleCIsInNldEltYWdlc051bWJlciIsIm51bWJlciIsImltYWdlc051bWJlciIsImluaXRWYWx1ZXMiLCJ0cmlnZ2VyIiwiZSIsImV2ZW50RnVuYyIsImZ1bmN0aW9ucyIsInJlc3VsdCIsInByZXZlbnREZWZhdWx0IiwiY29ycmVjdCIsInNjYWxlIiwic2xpZGUiLCJyZXNldEdhbGxlcnkiLCJmbiIsInByb3RvdHlwZSIsInBpbmNoIiwic3dpcGUiLCJkb3VibGV0YXAiLCJhY3Rpb25lbmQiLCJjbG9zZSIsImlzTG9jayIsImlzU3RhcnQiLCJ0eXBlIiwiZGVsdGFYIiwiZGVsdGFZIiwiYm91bmQiLCJjaGVja0JvdW5kIiwicG9zaXRpb24iLCJjZW50ZXIiLCJ6b29tIiwiTnVtYmVyIiwicGFyc2VGbG9hdCIsImxhc3RBY3Rpb25EYXRhIiwiZ2V0TGFzdEFjdGlvbkRhdGEiLCJzbGlkZVN0YXJ0RGF0YVgiLCJ4IiwiYm91bmRYIiwieSIsInN3aXRjaFRocmVzaG9sZCIsImlzT3ZlciIsIk1hdGgiLCJhYnMiLCJkaXJlY3Rpb24iLCJESVJFQ1RJT05fTEVGVCIsIkRJUkVDVElPTl9SSUdIVCIsInN3aXRjaE9iaiIsInN3aXRjaCIsImRlbHRhVGltZSIsInNldFRpbWVvdXQiLCJiZWZvcmUiLCJzbGljZSIsImxlbmd0aCIsImlzU3dpdGNoIiwic2xpZGVZIiwidG91Y2hBcmVhU2l6ZSIsImdldFRvdWNoQXJlYVNpemUiLCJ3aW5kb3ciLCJpbm5lckhlaWdodCIsIkNhbGN1bGF0b3IiLCJkYXRhcyIsImxhc3RTY2FsZSIsImxhc3RBY3Rpb25EYXRhcyIsInRyYWNrIiwicm91bmQiLCJudW0iLCJ2YWwiLCJpc05hTiIsInRvRml4ZWQiLCJzaXplIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJnZXRJbWdTaXplIiwiem9vbVNjYWxlIiwiZWwiLCJjaGlsZE5vZGVzIiwicGFyc2VJbnQiLCJzbGlkZUFycmF5Iiwibm9EaWZmZXJlbmNlIiwicmVzdWx0T2JqIiwiZWFjaEF4aXMiLCJheGlzIiwiem9vbVVwIiwiZ2V0Qm91bmQiLCJzbGlkZVZhbCIsIm92ZXJOdW0iLCJnZXRJbWFnZVNpemVEaWZmVmFsIiwiaW1nU2l6ZSIsImVsU2l6ZSIsInNjYWxlViIsImZsYWciLCJjaGVja2VkIiwibmV3U2xpZGVWYWwiLCJyZXN1bHRBcnJheSIsImRpZmZWYWwiLCJhZGRTbGlkZSIsImZ1bmMiLCJmb3JFYWNoIiwiaW5kZXgiLCJhZGRTY2FsZSIsImtleSIsImNvbnNvbGUiLCJhc3NlcnQiLCJzZXRMYXN0QWN0aW9uRGF0YSIsImNoZWNrIiwiZXJyb3IiLCJwb3NpdGlvblZhbCIsInNsaWRlU3RhcnRWYWwiLCJwaW5jaFN0YXJ0VmFsIiwic3dpdGNoTG9ja2VkIiwiYXJncyIsImFyZ3VtZW50cyIsImRpc3RhbmNlIiwic3RhcnRWYWwiLCJuZXdWYWwiLCJhcHBseSIsInRhU2l6ZSIsImF4aXNTaXplIiwiY3VyQXhpc1NpemUiLCJjZW50ZXJWYWwiLCJjYWwiLCJtb3ZlIiwiY3VyU2NhbGUiLCJvbGQiLCJiYXNlU2NhbGUiLCJuZXh0IiwicHJldmlvdXMiLCJyYXRlIiwibmV3U2xpZGUiLCJkb2N1bWVudCIsImV4cG9ydE5hbWUiLCJ1bmRlZmluZWQiLCJWRU5ET1JfUFJFRklYRVMiLCJURVNUX0VMRU1FTlQiLCJjcmVhdGVFbGVtZW50IiwiVFlQRV9GVU5DVElPTiIsIm5vdyIsIkRhdGUiLCJzZXRUaW1lb3V0Q29udGV4dCIsInRpbWVvdXQiLCJjb250ZXh0IiwiYmluZEZuIiwiaW52b2tlQXJyYXlBcmciLCJhcmciLCJBcnJheSIsImlzQXJyYXkiLCJlYWNoIiwib2JqIiwiaXRlcmF0b3IiLCJpIiwiaGFzT3duUHJvcGVydHkiLCJkZXByZWNhdGUiLCJtZXRob2QiLCJuYW1lIiwibWVzc2FnZSIsImRlcHJlY2F0aW9uTWVzc2FnZSIsInN0YWNrIiwicmVwbGFjZSIsImxvZyIsIndhcm4iLCJ0YXJnZXQiLCJUeXBlRXJyb3IiLCJvdXRwdXQiLCJzb3VyY2UiLCJuZXh0S2V5IiwiZXh0ZW5kIiwiZGVzdCIsInNyYyIsIm1lcmdlIiwia2V5cyIsImluaGVyaXQiLCJjaGlsZCIsImJhc2UiLCJwcm9wZXJ0aWVzIiwiYmFzZVAiLCJjaGlsZFAiLCJjcmVhdGUiLCJfc3VwZXIiLCJib3VuZEZuIiwiYm9vbE9yRm4iLCJpZlVuZGVmaW5lZCIsInZhbDEiLCJ2YWwyIiwiYWRkRXZlbnRMaXN0ZW5lcnMiLCJ0eXBlcyIsImhhbmRsZXIiLCJzcGxpdFN0ciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYXNQYXJlbnQiLCJub2RlIiwicGFyZW50IiwicGFyZW50Tm9kZSIsImluU3RyIiwic3RyIiwiZmluZCIsImluZGV4T2YiLCJ0cmltIiwic3BsaXQiLCJpbkFycmF5IiwiZmluZEJ5S2V5IiwidG9BcnJheSIsInVuaXF1ZUFycmF5Iiwic29ydCIsInJlc3VsdHMiLCJ2YWx1ZXMiLCJwdXNoIiwic29ydFVuaXF1ZUFycmF5IiwiYSIsImIiLCJwcmVmaXhlZCIsInByb3BlcnR5IiwicHJlZml4IiwicHJvcCIsImNhbWVsUHJvcCIsInRvVXBwZXJDYXNlIiwiX3VuaXF1ZUlkIiwidW5pcXVlSWQiLCJnZXRXaW5kb3dGb3JFbGVtZW50IiwiZWxlbWVudCIsImRvYyIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsInBhcmVudFdpbmRvdyIsIk1PQklMRV9SRUdFWCIsIlNVUFBPUlRfVE9VQ0giLCJTVVBQT1JUX1BPSU5URVJfRVZFTlRTIiwiU1VQUE9SVF9PTkxZX1RPVUNIIiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIklOUFVUX1RZUEVfVE9VQ0giLCJJTlBVVF9UWVBFX1BFTiIsIklOUFVUX1RZUEVfTU9VU0UiLCJJTlBVVF9UWVBFX0tJTkVDVCIsIkNPTVBVVEVfSU5URVJWQUwiLCJJTlBVVF9TVEFSVCIsIklOUFVUX01PVkUiLCJJTlBVVF9FTkQiLCJJTlBVVF9DQU5DRUwiLCJESVJFQ1RJT05fTk9ORSIsIkRJUkVDVElPTl9VUCIsIkRJUkVDVElPTl9ET1dOIiwiRElSRUNUSU9OX0hPUklaT05UQUwiLCJESVJFQ1RJT05fVkVSVElDQUwiLCJESVJFQ1RJT05fQUxMIiwiUFJPUFNfWFkiLCJQUk9QU19DTElFTlRfWFkiLCJJbnB1dCIsInNlbGYiLCJpbnB1dFRhcmdldCIsImRvbUhhbmRsZXIiLCJldiIsImVuYWJsZSIsImV2RWwiLCJldlRhcmdldCIsImV2V2luIiwiZGVzdHJveSIsImNyZWF0ZUlucHV0SW5zdGFuY2UiLCJUeXBlIiwiaW5wdXRDbGFzcyIsIlBvaW50ZXJFdmVudElucHV0IiwiVG91Y2hJbnB1dCIsIk1vdXNlSW5wdXQiLCJUb3VjaE1vdXNlSW5wdXQiLCJpbnB1dEhhbmRsZXIiLCJldmVudFR5cGUiLCJpbnB1dCIsInBvaW50ZXJzTGVuIiwiY2hhbmdlZFBvaW50ZXJzTGVuIiwiY2hhbmdlZFBvaW50ZXJzIiwiaXNGaXJzdCIsImlzRmluYWwiLCJzZXNzaW9uIiwiY29tcHV0ZUlucHV0RGF0YSIsImVtaXQiLCJyZWNvZ25pemUiLCJwcmV2SW5wdXQiLCJwb2ludGVyc0xlbmd0aCIsImZpcnN0SW5wdXQiLCJzaW1wbGVDbG9uZUlucHV0RGF0YSIsImZpcnN0TXVsdGlwbGUiLCJvZmZzZXRDZW50ZXIiLCJnZXRDZW50ZXIiLCJ0aW1lU3RhbXAiLCJhbmdsZSIsImdldEFuZ2xlIiwiZ2V0RGlzdGFuY2UiLCJjb21wdXRlRGVsdGFYWSIsIm9mZnNldERpcmVjdGlvbiIsImdldERpcmVjdGlvbiIsIm92ZXJhbGxWZWxvY2l0eSIsImdldFZlbG9jaXR5Iiwib3ZlcmFsbFZlbG9jaXR5WCIsIm92ZXJhbGxWZWxvY2l0eVkiLCJnZXRTY2FsZSIsInJvdGF0aW9uIiwiZ2V0Um90YXRpb24iLCJtYXhQb2ludGVycyIsImNvbXB1dGVJbnRlcnZhbElucHV0RGF0YSIsInNyY0V2ZW50Iiwib2Zmc2V0Iiwib2Zmc2V0RGVsdGEiLCJwcmV2RGVsdGEiLCJsYXN0IiwibGFzdEludGVydmFsIiwidmVsb2NpdHkiLCJ2ZWxvY2l0eVgiLCJ2ZWxvY2l0eVkiLCJ2IiwiY2xpZW50WCIsImNsaWVudFkiLCJwMSIsInAyIiwicHJvcHMiLCJzcXJ0IiwiYXRhbjIiLCJQSSIsInN0YXJ0IiwiZW5kIiwiTU9VU0VfSU5QVVRfTUFQIiwibW91c2Vkb3duIiwibW91c2Vtb3ZlIiwibW91c2V1cCIsIk1PVVNFX0VMRU1FTlRfRVZFTlRTIiwiTU9VU0VfV0lORE9XX0VWRU5UUyIsInByZXNzZWQiLCJNRWhhbmRsZXIiLCJidXR0b24iLCJ3aGljaCIsInBvaW50ZXJUeXBlIiwiUE9JTlRFUl9JTlBVVF9NQVAiLCJwb2ludGVyZG93biIsInBvaW50ZXJtb3ZlIiwicG9pbnRlcnVwIiwicG9pbnRlcmNhbmNlbCIsInBvaW50ZXJvdXQiLCJJRTEwX1BPSU5URVJfVFlQRV9FTlVNIiwiUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyIsIlBPSU5URVJfV0lORE9XX0VWRU5UUyIsIk1TUG9pbnRlckV2ZW50IiwiUG9pbnRlckV2ZW50Iiwic3RvcmUiLCJwb2ludGVyRXZlbnRzIiwiUEVoYW5kbGVyIiwicmVtb3ZlUG9pbnRlciIsImV2ZW50VHlwZU5vcm1hbGl6ZWQiLCJ0b0xvd2VyQ2FzZSIsImlzVG91Y2giLCJzdG9yZUluZGV4IiwicG9pbnRlcklkIiwic3BsaWNlIiwiU0lOR0xFX1RPVUNIX0lOUFVUX01BUCIsInRvdWNoc3RhcnQiLCJ0b3VjaG1vdmUiLCJ0b3VjaGVuZCIsInRvdWNoY2FuY2VsIiwiU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMiLCJTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyIsIlNpbmdsZVRvdWNoSW5wdXQiLCJzdGFydGVkIiwiVEVoYW5kbGVyIiwidG91Y2hlcyIsIm5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMiLCJhbGwiLCJjaGFuZ2VkIiwiY2hhbmdlZFRvdWNoZXMiLCJjb25jYXQiLCJUT1VDSF9JTlBVVF9NQVAiLCJUT1VDSF9UQVJHRVRfRVZFTlRTIiwidGFyZ2V0SWRzIiwiTVRFaGFuZGxlciIsImdldFRvdWNoZXMiLCJhbGxUb3VjaGVzIiwiaWRlbnRpZmllciIsInRhcmdldFRvdWNoZXMiLCJjaGFuZ2VkVGFyZ2V0VG91Y2hlcyIsImZpbHRlciIsInRvdWNoIiwiREVEVVBfVElNRU9VVCIsIkRFRFVQX0RJU1RBTkNFIiwibW91c2UiLCJwcmltYXJ5VG91Y2giLCJsYXN0VG91Y2hlcyIsIlRNRWhhbmRsZXIiLCJpbnB1dEV2ZW50IiwiaW5wdXREYXRhIiwiaXNNb3VzZSIsInNvdXJjZUNhcGFiaWxpdGllcyIsImZpcmVzVG91Y2hFdmVudHMiLCJyZWNvcmRUb3VjaGVzIiwiaXNTeW50aGV0aWNFdmVudCIsImV2ZW50RGF0YSIsInNldExhc3RUb3VjaCIsImxhc3RUb3VjaCIsImx0cyIsInJlbW92ZUxhc3RUb3VjaCIsInQiLCJkeCIsImR5IiwiUFJFRklYRURfVE9VQ0hfQUNUSU9OIiwic3R5bGUiLCJOQVRJVkVfVE9VQ0hfQUNUSU9OIiwiVE9VQ0hfQUNUSU9OX0NPTVBVVEUiLCJUT1VDSF9BQ1RJT05fQVVUTyIsIlRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04iLCJUT1VDSF9BQ1RJT05fTk9ORSIsIlRPVUNIX0FDVElPTl9QQU5fWCIsIlRPVUNIX0FDVElPTl9QQU5fWSIsIlRPVUNIX0FDVElPTl9NQVAiLCJnZXRUb3VjaEFjdGlvblByb3BzIiwiVG91Y2hBY3Rpb24iLCJ2YWx1ZSIsInNldCIsImNvbXB1dGUiLCJhY3Rpb25zIiwidXBkYXRlIiwidG91Y2hBY3Rpb24iLCJyZWNvZ25pemVycyIsInJlY29nbml6ZXIiLCJnZXRUb3VjaEFjdGlvbiIsImNsZWFuVG91Y2hBY3Rpb25zIiwiam9pbiIsInByZXZlbnREZWZhdWx0cyIsInByZXZlbnRlZCIsImhhc05vbmUiLCJoYXNQYW5ZIiwiaGFzUGFuWCIsImlzVGFwUG9pbnRlciIsImlzVGFwTW92ZW1lbnQiLCJpc1RhcFRvdWNoVGltZSIsInByZXZlbnRTcmMiLCJ0b3VjaE1hcCIsImNzc1N1cHBvcnRzIiwiQ1NTIiwic3VwcG9ydHMiLCJTVEFURV9QT1NTSUJMRSIsIlNUQVRFX0JFR0FOIiwiU1RBVEVfQ0hBTkdFRCIsIlNUQVRFX0VOREVEIiwiU1RBVEVfUkVDT0dOSVpFRCIsIlNUQVRFX0NBTkNFTExFRCIsIlNUQVRFX0ZBSUxFRCIsIlJlY29nbml6ZXIiLCJkZWZhdWx0cyIsImlkIiwic3RhdGUiLCJzaW11bHRhbmVvdXMiLCJyZXF1aXJlRmFpbCIsIm90aGVyUmVjb2duaXplciIsImdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIiLCJkcm9wUmVjb2duaXplV2l0aCIsInJlcXVpcmVGYWlsdXJlIiwiZHJvcFJlcXVpcmVGYWlsdXJlIiwiaGFzUmVxdWlyZUZhaWx1cmVzIiwiY2FuUmVjb2duaXplV2l0aCIsInN0YXRlU3RyIiwiYWRkaXRpb25hbEV2ZW50IiwidHJ5RW1pdCIsImNhbkVtaXQiLCJpbnB1dERhdGFDbG9uZSIsInJlc2V0IiwicHJvY2VzcyIsImRpcmVjdGlvblN0ciIsIkF0dHJSZWNvZ25pemVyIiwiYXR0clRlc3QiLCJvcHRpb25Qb2ludGVycyIsImlzUmVjb2duaXplZCIsImlzVmFsaWQiLCJQYW5SZWNvZ25pemVyIiwicFgiLCJwWSIsImRpcmVjdGlvblRlc3QiLCJoYXNNb3ZlZCIsIlBpbmNoUmVjb2duaXplciIsImluT3V0IiwiUHJlc3NSZWNvZ25pemVyIiwiX3RpbWVyIiwiX2lucHV0IiwidGltZSIsInZhbGlkUG9pbnRlcnMiLCJ2YWxpZE1vdmVtZW50IiwidmFsaWRUaW1lIiwiY2xlYXJUaW1lb3V0IiwiUm90YXRlUmVjb2duaXplciIsIlN3aXBlUmVjb2duaXplciIsIlRhcFJlY29nbml6ZXIiLCJwVGltZSIsInBDZW50ZXIiLCJjb3VudCIsImludGVydmFsIiwicG9zVGhyZXNob2xkIiwidmFsaWRUb3VjaFRpbWUiLCJmYWlsVGltZW91dCIsInZhbGlkSW50ZXJ2YWwiLCJ2YWxpZE11bHRpVGFwIiwidGFwQ291bnQiLCJwcmVzZXQiLCJWRVJTSU9OIiwiZG9tRXZlbnRzIiwiY3NzUHJvcHMiLCJ1c2VyU2VsZWN0IiwidG91Y2hTZWxlY3QiLCJ0b3VjaENhbGxvdXQiLCJjb250ZW50Wm9vbWluZyIsInVzZXJEcmFnIiwidGFwSGlnaGxpZ2h0Q29sb3IiLCJTVE9QIiwiRk9SQ0VEX1NUT1AiLCJoYW5kbGVycyIsIm9sZENzc1Byb3BzIiwidG9nZ2xlQ3NzUHJvcHMiLCJpdGVtIiwic3RvcCIsImZvcmNlIiwic3RvcHBlZCIsImN1clJlY29nbml6ZXIiLCJleGlzdGluZyIsInJlbW92ZSIsIm9mZiIsImRhdGEiLCJ0cmlnZ2VyRG9tRXZlbnQiLCJnZXN0dXJlRXZlbnQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImdlc3R1cmUiLCJkaXNwYXRjaEV2ZW50IiwiUm90YXRlIiwiUHJlc3MiLCJmcmVlR2xvYmFsIiwiZGVmaW5lIiwibW9kdWxlIiwiZXhwb3J0cyIsInVzZVNvdXJjZU1hcCIsImxpc3QiLCJ0b1N0cmluZyIsIm1hcCIsImNvbnRlbnQiLCJjc3NXaXRoTWFwcGluZ1RvU3RyaW5nIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwiY3NzTWFwcGluZyIsImJ0b2EiLCJzb3VyY2VNYXBwaW5nIiwidG9Db21tZW50Iiwic291cmNlVVJMcyIsInNvdXJjZXMiLCJzb3VyY2VSb290Iiwic291cmNlTWFwIiwiYmFzZTY0IiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJKU09OIiwic3RyaW5naWZ5IiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiSXRlbSIsImFycmF5IiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsImdsb2JhbCIsInNldEltbWVkaWF0ZSIsIm5leHRIYW5kbGUiLCJ0YXNrc0J5SGFuZGxlIiwiY3VycmVudGx5UnVubmluZ0FUYXNrIiwicmVnaXN0ZXJJbW1lZGlhdGUiLCJGdW5jdGlvbiIsInRhc2siLCJjbGVhckltbWVkaWF0ZSIsImhhbmRsZSIsInJ1bklmUHJlc2VudCIsImluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uIiwiY2FuVXNlUG9zdE1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsImltcG9ydFNjcmlwdHMiLCJwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzIiwib2xkT25NZXNzYWdlIiwib25tZXNzYWdlIiwiaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24iLCJtZXNzYWdlUHJlZml4IiwicmFuZG9tIiwib25HbG9iYWxNZXNzYWdlIiwiYXR0YWNoRXZlbnQiLCJpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImNoYW5uZWwiLCJNZXNzYWdlQ2hhbm5lbCIsInBvcnQxIiwicG9ydDIiLCJpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uIiwiaHRtbCIsImRvY3VtZW50RWxlbWVudCIsInNjcmlwdCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlbW92ZUNoaWxkIiwiYXBwZW5kQ2hpbGQiLCJpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uIiwiYXR0YWNoVG8iLCJnZXRQcm90b3R5cGVPZiIsInNjb3BlIiwiVGltZW91dCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImNsZWFyRm4iLCJfaWQiLCJfY2xlYXJGbiIsInVucmVmIiwicmVmIiwiZW5yb2xsIiwibXNlY3MiLCJfaWRsZVRpbWVvdXRJZCIsIl9pZGxlVGltZW91dCIsInVuZW5yb2xsIiwiX3VucmVmQWN0aXZlIiwiYWN0aXZlIiwib25UaW1lb3V0IiwiX29uVGltZW91dCIsInJlcXVpcmUiLCJsaXN0VG9TdHlsZXMiLCJwYXJlbnRJZCIsInN0eWxlcyIsIm5ld1N0eWxlcyIsImNzcyIsIm1lZGlhIiwicGFydCIsInBhcnRzIiwiZW1wdHlPYmplY3QiLCJmcmVlemUiLCJpc1VuZGVmIiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJpc09iamVjdCIsIl90b1N0cmluZyIsInRvUmF3VHlwZSIsImlzUGxhaW5PYmplY3QiLCJpc1JlZ0V4cCIsImlzVmFsaWRBcnJheUluZGV4IiwibiIsIlN0cmluZyIsImZsb29yIiwiaXNGaW5pdGUiLCJ0b051bWJlciIsIm1ha2VNYXAiLCJleHBlY3RzTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsImFyciIsImhhc093biIsImNhY2hlZCIsImNhY2hlIiwiY2FjaGVkRm4iLCJoaXQiLCJjYW1lbGl6ZVJFIiwiY2FtZWxpemUiLCJfIiwiYyIsImNhcGl0YWxpemUiLCJjaGFyQXQiLCJoeXBoZW5hdGVSRSIsImh5cGhlbmF0ZSIsInBvbHlmaWxsQmluZCIsImN0eCIsImwiLCJfbGVuZ3RoIiwibmF0aXZlQmluZCIsImJpbmQiLCJyZXQiLCJ0byIsIl9mcm9tIiwidG9PYmplY3QiLCJyZXMiLCJubyIsImlkZW50aXR5IiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImlzQXJyYXlBIiwiaXNBcnJheUIiLCJldmVyeSIsImtleXNBIiwia2V5c0IiLCJsb29zZUluZGV4T2YiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwiY29uZmlnIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsImRldnRvb2xzIiwicGVyZm9ybWFuY2UiLCJlcnJvckhhbmRsZXIiLCJ3YXJuSGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJfbGlmZWN5Y2xlSG9va3MiLCJpc1Jlc2VydmVkIiwiY2hhckNvZGVBdCIsImRlZiIsImVudW1lcmFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiYmFpbFJFIiwicGFyc2VQYXRoIiwicGF0aCIsInNlZ21lbnRzIiwiaGFzUHJvdG8iLCJpbkJyb3dzZXIiLCJpbldlZXgiLCJXWEVudmlyb25tZW50IiwicGxhdGZvcm0iLCJ3ZWV4UGxhdGZvcm0iLCJVQSIsImlzSUUiLCJpc0lFOSIsImlzRWRnZSIsImlzQW5kcm9pZCIsImlzSU9TIiwiaXNDaHJvbWUiLCJuYXRpdmVXYXRjaCIsIndhdGNoIiwic3VwcG9ydHNQYXNzaXZlIiwib3B0cyIsIl9pc1NlcnZlciIsImlzU2VydmVyUmVuZGVyaW5nIiwiVlVFX0VOViIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpc05hdGl2ZSIsIkN0b3IiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsIl9TZXQiLCJTZXQiLCJoYXMiLCJjbGVhciIsInRpcCIsImdlbmVyYXRlQ29tcG9uZW50VHJhY2UiLCJmb3JtYXRDb21wb25lbnROYW1lIiwiaGFzQ29uc29sZSIsImNsYXNzaWZ5UkUiLCJjbGFzc2lmeSIsIm1zZyIsInZtIiwidHJhY2UiLCJpbmNsdWRlRmlsZSIsIiRyb290IiwiY2lkIiwiX2lzVnVlIiwiJG9wdGlvbnMiLCJfY29tcG9uZW50VGFnIiwiZmlsZSIsIl9fZmlsZSIsIm1hdGNoIiwicmVwZWF0IiwiJHBhcmVudCIsInRyZWUiLCJjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UiLCJ1aWQiLCJEZXAiLCJzdWJzIiwiYWRkU3ViIiwic3ViIiwicmVtb3ZlU3ViIiwiZGVwZW5kIiwiYWRkRGVwIiwibm90aWZ5IiwidGFyZ2V0U3RhY2siLCJwdXNoVGFyZ2V0IiwiX3RhcmdldCIsInBvcFRhcmdldCIsInBvcCIsIlZOb2RlIiwidGFnIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZWxtIiwiY29tcG9uZW50T3B0aW9ucyIsImFzeW5jRmFjdG9yeSIsIm5zIiwiZm5Db250ZXh0IiwiZm5PcHRpb25zIiwiZm5TY29wZUlkIiwiY29tcG9uZW50SW5zdGFuY2UiLCJyYXciLCJpc1N0YXRpYyIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiYXN5bmNNZXRhIiwiaXNBc3luY1BsYWNlaG9sZGVyIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwidm5vZGUiLCJjbG9uZWQiLCJhcnJheVByb3RvIiwiYXJyYXlNZXRob2RzIiwibWV0aG9kc1RvUGF0Y2giLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInNob3VsZE9ic2VydmUiLCJ0b2dnbGVPYnNlcnZpbmciLCJPYnNlcnZlciIsInZtQ291bnQiLCJhdWdtZW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUiLCJpdGVtcyIsIm9ic2VydmUiLCJfX3Byb3RvX18iLCJhc1Jvb3REYXRhIiwiaXNFeHRlbnNpYmxlIiwiY3VzdG9tU2V0dGVyIiwic2hhbGxvdyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJtYXgiLCJkZWwiLCJzdHJhdHMiLCJwcm9wc0RhdGEiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJmcm9tIiwidG9WYWwiLCJmcm9tVmFsIiwibWVyZ2VEYXRhT3JGbiIsInBhcmVudFZhbCIsImNoaWxkVmFsIiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkSW5zdGFuY2VEYXRhRm4iLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIm1lcmdlSG9vayIsImhvb2siLCJtZXJnZUFzc2V0cyIsImFzc2VydE9iamVjdFR5cGUiLCJrZXkkMSIsIm1ldGhvZHMiLCJpbmplY3QiLCJjb21wdXRlZCIsInByb3ZpZGUiLCJjaGVja0NvbXBvbmVudHMiLCJjb21wb25lbnRzIiwidmFsaWRhdGVDb21wb25lbnROYW1lIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVJbmplY3QiLCJub3JtYWxpemVkIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwibWVyZ2VPcHRpb25zIiwiZXh0ZW5kc0Zyb20iLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwiYWJzZW50IiwiYm9vbGVhbkluZGV4IiwiZ2V0VHlwZUluZGV4IiwiQm9vbGVhbiIsInN0cmluZ0luZGV4IiwiZ2V0UHJvcERlZmF1bHRWYWx1ZSIsInByZXZTaG91bGRPYnNlcnZlIiwiYXNzZXJ0UHJvcCIsImRlZmF1bHQiLCJfcHJvcHMiLCJnZXRUeXBlIiwicmVxdWlyZWQiLCJ2YWxpZCIsImV4cGVjdGVkVHlwZXMiLCJhc3NlcnRlZFR5cGUiLCJhc3NlcnRUeXBlIiwiZXhwZWN0ZWRUeXBlIiwidmFsaWRhdG9yIiwic2ltcGxlQ2hlY2tSRSIsImlzU2FtZVR5cGUiLCJoYW5kbGVFcnJvciIsImVyciIsImluZm8iLCJjdXIiLCJob29rcyIsImVycm9yQ2FwdHVyZWQiLCJjYXB0dXJlIiwiZ2xvYmFsSGFuZGxlRXJyb3IiLCJsb2dFcnJvciIsInBlbmRpbmciLCJmbHVzaENhbGxiYWNrcyIsImNvcGllcyIsIm1pY3JvVGltZXJGdW5jIiwibWFjcm9UaW1lckZ1bmMiLCJ1c2VNYWNyb1Rhc2siLCJwb3J0IiwiUHJvbWlzZSIsInAiLCJyZXNvbHZlIiwidGhlbiIsIndpdGhNYWNyb1Rhc2siLCJfd2l0aFRhc2siLCJjYiIsIl9yZXNvbHZlIiwiaW5pdFByb3h5IiwiYWxsb3dlZEdsb2JhbHMiLCJ3YXJuTm9uUHJlc2VudCIsImhhc1Byb3h5IiwiUHJveHkiLCJpc0J1aWx0SW5Nb2RpZmllciIsImhhc0hhbmRsZXIiLCJpc0FsbG93ZWQiLCJnZXRIYW5kbGVyIiwicmVuZGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsInNlZW5PYmplY3RzIiwidHJhdmVyc2UiLCJfdHJhdmVyc2UiLCJzZWVuIiwiaXNBIiwiaXNGcm96ZW4iLCJkZXBJZCIsIm1hcmsiLCJtZWFzdXJlIiwicGVyZiIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwic3RhcnRUYWciLCJlbmRUYWciLCJub3JtYWxpemVFdmVudCIsInBhc3NpdmUiLCJvbmNlJCQxIiwiY3JlYXRlRm5JbnZva2VyIiwiZm5zIiwiaW52b2tlciIsImFyZ3VtZW50cyQxIiwidXBkYXRlTGlzdGVuZXJzIiwib2xkT24iLCJyZW1vdmUkJDEiLCJwYXJhbXMiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsImhhc2giLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4IiwibGFzdEluZGV4Iiwic2hpZnQiLCJfaXNWTGlzdCIsImVuc3VyZUN0b3IiLCJjb21wIiwiX19lc01vZHVsZSIsInRvU3RyaW5nVGFnIiwiY3JlYXRlQXN5bmNQbGFjZWhvbGRlciIsImZhY3RvcnkiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJiYXNlQ3RvciIsImVycm9yQ29tcCIsInJlc29sdmVkIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwiY29udGV4dHMiLCJzeW5jIiwiZm9yY2VSZW5kZXIiLCIkZm9yY2VVcGRhdGUiLCJyZWplY3QiLCJyZWFzb24iLCJjb21wb25lbnQiLCJkZWxheSIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJfcGFyZW50TGlzdGVuZXJzIiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwiJG9uY2UiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsIlZ1ZSIsImhvb2tSRSIsInRoaXMkMSIsImNicyIsImkkMSIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsInNsb3QiLCJuYW1lJDEiLCJpc1doaXRlc3BhY2UiLCJyZXNvbHZlU2NvcGVkU2xvdHMiLCJhY3RpdmVJbnN0YW5jZSIsImlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCIsImluaXRMaWZlY3ljbGUiLCJhYnN0cmFjdCIsIiRjaGlsZHJlbiIsIiRyZWZzIiwiX3dhdGNoZXIiLCJfaW5hY3RpdmUiLCJfZGlyZWN0SW5hY3RpdmUiLCJfaXNNb3VudGVkIiwiX2lzRGVzdHJveWVkIiwiX2lzQmVpbmdEZXN0cm95ZWQiLCJsaWZlY3ljbGVNaXhpbiIsIl91cGRhdGUiLCJoeWRyYXRpbmciLCJjYWxsSG9vayIsInByZXZFbCIsIiRlbCIsInByZXZWbm9kZSIsIl92bm9kZSIsInByZXZBY3RpdmVJbnN0YW5jZSIsIl9fcGF0Y2hfXyIsIl9wYXJlbnRFbG0iLCJfcmVmRWxtIiwiX192dWVfXyIsIiR2bm9kZSIsIiRkZXN0cm95IiwidGVhcmRvd24iLCJfd2F0Y2hlcnMiLCJfZGF0YSIsIm1vdW50Q29tcG9uZW50IiwidGVtcGxhdGUiLCJ1cGRhdGVDb21wb25lbnQiLCJfbmFtZSIsIl91aWQiLCJfcmVuZGVyIiwiV2F0Y2hlciIsInVwZGF0ZUNoaWxkQ29tcG9uZW50IiwicGFyZW50Vm5vZGUiLCJyZW5kZXJDaGlsZHJlbiIsImhhc0NoaWxkcmVuIiwiX3JlbmRlckNoaWxkcmVuIiwic2NvcGVkU2xvdHMiLCIkc2NvcGVkU2xvdHMiLCJfcGFyZW50Vm5vZGUiLCIkYXR0cnMiLCIkbGlzdGVuZXJzIiwicHJvcEtleXMiLCJfcHJvcEtleXMiLCIkc2xvdHMiLCJpc0luSW5hY3RpdmVUcmVlIiwiYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImRpcmVjdCIsImRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImoiLCJNQVhfVVBEQVRFX0NPVU5UIiwiYWN0aXZhdGVkQ2hpbGRyZW4iLCJjaXJjdWxhciIsIndhaXRpbmciLCJmbHVzaGluZyIsInJlc2V0U2NoZWR1bGVyU3RhdGUiLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInVzZXIiLCJleHByZXNzaW9uIiwiYWN0aXZhdGVkUXVldWUiLCJ1cGRhdGVkUXVldWUiLCJjYWxsQWN0aXZhdGVkSG9va3MiLCJjYWxsVXBkYXRlZEhvb2tzIiwicXVldWVBY3RpdmF0ZWRDb21wb25lbnQiLCJxdWV1ZVdhdGNoZXIiLCJ1aWQkMSIsImV4cE9yRm4iLCJpc1JlbmRlcldhdGNoZXIiLCJkZWVwIiwibGF6eSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJjbGVhbnVwRGVwcyIsInRtcCIsIm9sZFZhbHVlIiwiZXZhbHVhdGUiLCJzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24iLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsInByb3BzT3B0aW9ucyIsImlzUm9vdCIsImxvb3AiLCJoeXBoZW5hdGVkS2V5IiwiZ2V0RGF0YSIsImNvbXB1dGVkV2F0Y2hlck9wdGlvbnMiLCJ3YXRjaGVycyIsIl9jb21wdXRlZFdhdGNoZXJzIiwiaXNTU1IiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCIkZGF0YSIsInNob3VsZENhY2hlIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjb21wdXRlZEdldHRlciIsImNyZWF0ZVdhdGNoZXIiLCIkd2F0Y2giLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwibmV3RGF0YSIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwiaW5pdFByb3ZpZGUiLCJfcHJvdmlkZWQiLCJpbml0SW5qZWN0aW9ucyIsInJlc29sdmVJbmplY3QiLCJwcm92aWRlS2V5IiwicHJvdmlkZURlZmF1bHQiLCJyZW5kZXJMaXN0IiwicmVuZGVyU2xvdCIsImZhbGxiYWNrIiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsIm5vZGVzIiwic2xvdE5vZGVzIiwiX3JlbmRlcmVkIiwiJGNyZWF0ZUVsZW1lbnQiLCJyZXNvbHZlRmlsdGVyIiwiaXNLZXlOb3RNYXRjaCIsImV4cGVjdCIsImFjdHVhbCIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluS2V5Q29kZSIsImV2ZW50S2V5TmFtZSIsImJ1aWx0SW5LZXlOYW1lIiwibWFwcGVkS2V5Q29kZSIsImJpbmRPYmplY3RQcm9wcyIsImFzUHJvcCIsImlzU3luYyIsImRvbVByb3BzIiwiJGV2ZW50IiwicmVuZGVyU3RhdGljIiwiaXNJbkZvciIsIl9zdGF0aWNUcmVlcyIsInN0YXRpY1JlbmRlckZucyIsIm1hcmtTdGF0aWMiLCJtYXJrT25jZSIsIm1hcmtTdGF0aWNOb2RlIiwiYmluZE9iamVjdExpc3RlbmVycyIsIm91cnMiLCJpbnN0YWxsUmVuZGVySGVscGVycyIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsIkZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IiwiY29udGV4dFZtIiwiX29yaWdpbmFsIiwiaXNDb21waWxlZCIsIl9jb21waWxlZCIsIm5lZWROb3JtYWxpemF0aW9uIiwiaW5qZWN0aW9ucyIsIl9zY29wZUlkIiwiX2MiLCJkIiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm1lcmdlUHJvcHMiLCJyZW5kZXJDb250ZXh0IiwiY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCIsInZub2RlcyIsImNsb25lIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsInBhcmVudEVsbSIsInJlZkVsbSIsImtlZXBBbGl2ZSIsIm1vdW50ZWROb2RlIiwicHJlcGF0Y2giLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiJG1vdW50Iiwib2xkVm5vZGUiLCJpbnNlcnQiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJfYmFzZSIsInJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMiLCJtb2RlbCIsInRyYW5zZm9ybU1vZGVsIiwiZnVuY3Rpb25hbCIsIm5hdGl2ZU9uIiwiaW5zdGFsbENvbXBvbmVudEhvb2tzIiwiX2lzQ29tcG9uZW50IiwiaW5saW5lVGVtcGxhdGUiLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsImFwcGx5TlMiLCJyZWdpc3RlckRlZXBCaW5kaW5ncyIsImNsYXNzIiwiaW5pdFJlbmRlciIsInBhcmVudERhdGEiLCJyZW5kZXJNaXhpbiIsIiRuZXh0VGljayIsInJlbmRlckVycm9yIiwidWlkJDMiLCJpbml0TWl4aW4iLCJfaW5pdCIsImluaXRJbnRlcm5hbENvbXBvbmVudCIsIl9zZWxmIiwidm5vZGVDb21wb25lbnRPcHRpb25zIiwic3VwZXIiLCJzdXBlck9wdGlvbnMiLCJjYWNoZWRTdXBlck9wdGlvbnMiLCJtb2RpZmllZE9wdGlvbnMiLCJyZXNvbHZlTW9kaWZpZWRPcHRpb25zIiwiZXh0ZW5kT3B0aW9ucyIsIm1vZGlmaWVkIiwibGF0ZXN0IiwiZXh0ZW5kZWQiLCJzZWFsZWQiLCJzZWFsZWRPcHRpb25zIiwiZGVkdXBlIiwiaW5pdFVzZSIsInVzZSIsInBsdWdpbiIsImluc3RhbGxlZFBsdWdpbnMiLCJfaW5zdGFsbGVkUGx1Z2lucyIsInVuc2hpZnQiLCJpbnN0YWxsIiwiaW5pdE1peGluJDEiLCJtaXhpbiIsImluaXRFeHRlbmQiLCJTdXBlciIsIlN1cGVySWQiLCJjYWNoZWRDdG9ycyIsIl9DdG9yIiwiU3ViIiwiVnVlQ29tcG9uZW50IiwiaW5pdFByb3BzJDEiLCJpbml0Q29tcHV0ZWQkMSIsIkNvbXAiLCJpbml0QXNzZXRSZWdpc3RlcnMiLCJkZWZpbml0aW9uIiwiZ2V0Q29tcG9uZW50TmFtZSIsIm1hdGNoZXMiLCJwYXR0ZXJuIiwicHJ1bmVDYWNoZSIsImtlZXBBbGl2ZUluc3RhbmNlIiwiY2FjaGVkTm9kZSIsInBydW5lQ2FjaGVFbnRyeSIsImN1cnJlbnQiLCJjYWNoZWQkJDEiLCJwYXR0ZXJuVHlwZXMiLCJSZWdFeHAiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiZXhjbHVkZSIsImNyZWF0ZWQiLCJkZXN0cm95ZWQiLCJtb3VudGVkIiwicmVmJDEiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVsZXRlIiwic3NyQ29udGV4dCIsImFjY2VwdFZhbHVlIiwiYXR0ciIsImlzRW51bWVyYXRlZEF0dHIiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJpc0ZhbHN5QXR0clZhbHVlIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwicmVuZGVyQ2xhc3MiLCJzdGF0aWNDbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsInVua25vd25FbGVtZW50Q2FjaGUiLCJIVE1MVW5rbm93bkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzVGV4dElucHV0VHlwZSIsInF1ZXJ5Iiwic2VsZWN0ZWQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsIm11bHRpcGxlIiwic2V0QXR0cmlidXRlIiwiY3JlYXRlRWxlbWVudE5TIiwibmFtZXNwYWNlIiwiY3JlYXRlVGV4dE5vZGUiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJuZXh0U2libGluZyIsInNldFRleHRDb250ZW50IiwidGV4dENvbnRlbnQiLCJzZXRTdHlsZVNjb3BlIiwic2NvcGVJZCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsInNhbWVWbm9kZSIsInNhbWVJbnB1dFR5cGUiLCJ0eXBlQSIsInR5cGVCIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsImNyZWF0ZVBhdGNoRnVuY3Rpb24iLCJiYWNrZW5kIiwiZW1wdHlOb2RlQXQiLCJjcmVhdGVSbUNiIiwiY2hpbGRFbG0iLCJyZW1vdmVOb2RlIiwiaXNVbmtub3duRWxlbWVudCQkMSIsImluVlByZSIsInNvbWUiLCJpZ25vcmUiLCJjcmVhdGluZ0VsbUluVlByZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsIm5lc3RlZCIsIm93bmVyQXJyYXkiLCJwcmUiLCJzZXRTY29wZSIsImNyZWF0ZUNoaWxkcmVuIiwiaW52b2tlQ3JlYXRlSG9va3MiLCJpc1JlYWN0aXZhdGVkIiwiaW5pdENvbXBvbmVudCIsInJlYWN0aXZhdGVDb21wb25lbnQiLCJwZW5kaW5nSW5zZXJ0IiwiaXNQYXRjaGFibGUiLCJpbm5lck5vZGUiLCJ0cmFuc2l0aW9uIiwiYWN0aXZhdGUiLCJyZWYkJDEiLCJjaGVja0R1cGxpY2F0ZUtleXMiLCJhbmNlc3RvciIsImFkZFZub2RlcyIsInN0YXJ0SWR4IiwiaW52b2tlRGVzdHJveUhvb2siLCJyZW1vdmVWbm9kZXMiLCJjaCIsInJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2siLCJybSIsInVwZGF0ZUNoaWxkcmVuIiwib2xkQ2giLCJuZXdDaCIsInJlbW92ZU9ubHkiLCJvbGRTdGFydElkeCIsIm5ld1N0YXJ0SWR4Iiwib2xkRW5kSWR4Iiwib2xkU3RhcnRWbm9kZSIsIm9sZEVuZFZub2RlIiwibmV3RW5kSWR4IiwibmV3U3RhcnRWbm9kZSIsIm5ld0VuZFZub2RlIiwib2xkS2V5VG9JZHgiLCJpZHhJbk9sZCIsInZub2RlVG9Nb3ZlIiwiY2FuTW92ZSIsInBhdGNoVm5vZGUiLCJmaW5kSWR4SW5PbGQiLCJzZWVuS2V5cyIsImh5ZHJhdGUiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImh5ZHJhdGlvbkJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJhc3NlcnROb2RlTWF0Y2giLCJoYXNDaGlsZE5vZGVzIiwiaW5uZXJIVE1MIiwiY2hpbGRyZW5NYXRjaCIsImZpcnN0Q2hpbGQiLCJmdWxsSW52b2tlIiwibm9kZVR5cGUiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9sZEVsbSIsInBhcmVudEVsbSQxIiwiX2xlYXZlQ2IiLCJwYXRjaGFibGUiLCJpJDIiLCJ1cGRhdGVEaXJlY3RpdmVzIiwidW5iaW5kRGlyZWN0aXZlcyIsImlzQ3JlYXRlIiwiaXNEZXN0cm95Iiwib2xkRGlycyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMkMSIsIm5ld0RpcnMiLCJkaXJzV2l0aEluc2VydCIsImRpcnNXaXRoUG9zdHBhdGNoIiwib2xkRGlyIiwiY2FsbEhvb2skMSIsImNvbXBvbmVudFVwZGF0ZWQiLCJjYWxsSW5zZXJ0IiwiZW1wdHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImJhc2VNb2R1bGVzIiwidXBkYXRlQXR0cnMiLCJpbmhlcml0QXR0cnMiLCJvbGRBdHRycyIsInNldEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsImJhc2VTZXRBdHRyIiwic2V0QXR0cmlidXRlTlMiLCJfX2llcGgiLCJibG9ja2VyIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwiY2xzIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsImtsYXNzIiwiUkFOR0VfVE9LRU4iLCJDSEVDS0JPWF9SQURJT19UT0tFTiIsIm5vcm1hbGl6ZUV2ZW50cyIsImNoYW5nZSIsInRhcmdldCQxIiwiY3JlYXRlT25jZUhhbmRsZXIiLCJvbmNlSGFuZGxlciIsInJlbW92ZSQyIiwiYWRkJDEiLCJ1cGRhdGVET01MaXN0ZW5lcnMiLCJ1cGRhdGVET01Qcm9wcyIsIm9sZFByb3BzIiwiX3ZhbHVlIiwic3RyQ3VyIiwic2hvdWxkVXBkYXRlVmFsdWUiLCJjaGVja1ZhbCIsImNvbXBvc2luZyIsImlzTm90SW5Gb2N1c0FuZERpcnR5IiwiaXNEaXJ0eVdpdGhNb2RpZmllcnMiLCJub3RJbkZvY3VzIiwiYWN0aXZlRWxlbWVudCIsIl92TW9kaWZpZXJzIiwicGFyc2VTdHlsZVRleHQiLCJjc3NUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsInNldFByb3BlcnR5Iiwibm9ybWFsaXplZE5hbWUiLCJub3JtYWxpemUiLCJ2ZW5kb3JOYW1lcyIsImVtcHR5U3R5bGUiLCJjYXBOYW1lIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm5vcm1hbGl6ZWRTdHlsZSIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJhZGRDbGFzcyIsImNsYXNzTGlzdCIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInRyYW5zaXRpb25DbGFzc2VzIiwicmVtb3ZlVHJhbnNpdGlvbkNsYXNzIiwid2hlblRyYW5zaXRpb25FbmRzIiwiZ2V0VHJhbnNpdGlvbkluZm8iLCJwcm9wQ291bnQiLCJlbmRlZCIsIm9uRW5kIiwidHJhbnNmb3JtUkUiLCJnZXRDb21wdXRlZFN0eWxlIiwidHJhbnNpdGlvbkRlbGF5cyIsInRyYW5zaXRpb25EdXJhdGlvbnMiLCJ0cmFuc2l0aW9uVGltZW91dCIsImdldFRpbWVvdXQiLCJhbmltYXRpb25EZWxheXMiLCJhbmltYXRpb25EdXJhdGlvbnMiLCJhbmltYXRpb25UaW1lb3V0IiwiaGFzVHJhbnNmb3JtIiwiZGVsYXlzIiwiZHVyYXRpb25zIiwidG9NcyIsInMiLCJlbnRlciIsInRvZ2dsZURpc3BsYXkiLCJjYW5jZWxsZWQiLCJfZW50ZXJDYiIsImFwcGVhckNsYXNzIiwiYXBwZWFyVG9DbGFzcyIsImFwcGVhckFjdGl2ZUNsYXNzIiwiYmVmb3JlRW50ZXIiLCJhZnRlckVudGVyIiwiZW50ZXJDYW5jZWxsZWQiLCJiZWZvcmVBcHBlYXIiLCJhcHBlYXIiLCJhZnRlckFwcGVhciIsImFwcGVhckNhbmNlbGxlZCIsImR1cmF0aW9uIiwidHJhbnNpdGlvbk5vZGUiLCJpc0FwcGVhciIsInN0YXJ0Q2xhc3MiLCJhY3RpdmVDbGFzcyIsInRvQ2xhc3MiLCJiZWZvcmVFbnRlckhvb2siLCJlbnRlckhvb2siLCJhZnRlckVudGVySG9vayIsImVudGVyQ2FuY2VsbGVkSG9vayIsImV4cGxpY2l0RW50ZXJEdXJhdGlvbiIsImNoZWNrRHVyYXRpb24iLCJleHBlY3RzQ1NTIiwidXNlcldhbnRzQ29udHJvbCIsImdldEhvb2tBcmd1bWVudHNMZW5ndGgiLCJzaG93IiwicGVuZGluZ05vZGUiLCJfcGVuZGluZyIsImlzVmFsaWREdXJhdGlvbiIsImxlYXZlIiwiYmVmb3JlTGVhdmUiLCJhZnRlckxlYXZlIiwibGVhdmVDYW5jZWxsZWQiLCJkZWxheUxlYXZlIiwiZXhwbGljaXRMZWF2ZUR1cmF0aW9uIiwicGVyZm9ybUxlYXZlIiwiaW52b2tlckZucyIsIl9lbnRlciIsInBsYXRmb3JtTW9kdWxlcyIsInZtb2RlbCIsImRpcmVjdGl2ZSIsIl92T3B0aW9ucyIsInNldFNlbGVjdGVkIiwiZ2V0VmFsdWUiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uRW5kIiwicHJldk9wdGlvbnMiLCJjdXJPcHRpb25zIiwibyIsIm5lZWRSZXNldCIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJhY3R1YWxseVNldFNlbGVjdGVkIiwiaXNNdWx0aXBsZSIsIm9wdGlvbiIsInNlbGVjdGVkSW5kZXgiLCJsb2NhdGVOb2RlIiwidHJhbnNpdGlvbiQkMSIsIm9yaWdpbmFsRGlzcGxheSIsIl9fdk9yaWdpbmFsRGlzcGxheSIsImRpc3BsYXkiLCJ1bmJpbmQiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJtb2RlIiwiZ2V0UmVhbENoaWxkIiwiY29tcE9wdGlvbnMiLCJleHRyYWN0VHJhbnNpdGlvbkRhdGEiLCJwbGFjZWhvbGRlciIsImgiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwia2VwdCIsInJlbW92ZWQiLCJjJDEiLCJwb3MiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJiZWZvcmVVcGRhdGUiLCJ1cGRhdGVkIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiX3JlZmxvdyIsImJvZHkiLCJvZmZzZXRIZWlnaHQiLCJtb3ZlZCIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsImNsb25lTm9kZSIsIm5ld1BvcyIsIm9sZFBvcyIsImxlZnQiLCJ0b3AiLCJwbGF0Zm9ybUNvbXBvbmVudHMiLCJnIiwiZXZhbCJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQTBDLGdDQUFnQztBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUF3RCxrQkFBa0I7QUFDMUU7QUFDQSx5REFBaUQsY0FBYztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQXlDLGlDQUFpQztBQUMxRSx3SEFBZ0gsbUJBQW1CLEVBQUU7QUFDckk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBOzs7QUFHQSxNQUFN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QVc7QUFDVCxlQUFPQSxFQUFFLE9BQUYsQ0FBUDtBQUNEO0FBTEcsQ0FBUixFOzs7Ozs7Ozs7Ozs7QUNIQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQW9GO0FBQzNCO0FBQ0w7QUFDYzs7O0FBR2xFO0FBQzZGO0FBQzdGLGdCQUFnQiwyR0FBVTtBQUMxQixFQUFFLDJFQUFNO0FBQ1IsRUFBRSxnRkFBTTtBQUNSLEVBQUUseUZBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJLEtBQVUsRUFBRSxZQWlCZjtBQUNEO0FBQ2UsZ0Y7Ozs7Ozs7Ozs7OztBQ3ZDZjtBQUFBO0FBQUEsd0NBQTJLLENBQWdCLHlPQUFHLEVBQUMsQzs7Ozs7Ozs7Ozs7O0FDQS9MO0FBQUE7QUFBQTtBQUFBO0FBQXdWLENBQWdCLHdYQUFHLEVBQUMsQzs7Ozs7Ozs7Ozs7O0FDQTVXO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSIsImZpbGUiOiJqcy9pbmRleC5iMmY3Y2FkZjFkZGYwZmEzM2RlYy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2Rpc3QvXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vaW5kZXgvaW5kZXguanNcIik7XG4iLCJpbXBvcnQgSGFtbWVyIGZyb20gXCJoYW1tZXJqc1wiO1xyXG5cclxuLyoqXHJcbiAqIOmFjee9rlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiDmnIDlpKfnvKnmlL7mr5TkvotcclxuICAgICAqL1xyXG4gICAgbWF4U2NhbGU6IDMsXHJcbiAgICAvKipcclxuICAgICAqIOacgOWwj+e8qeaUvuavlOS+i1xyXG4gICAgICovXHJcbiAgICBtaW5TY2FsZTogMCxcclxuICAgIC8qKlxyXG4gICAgICog5LiL5ouJ5YWz6Zet55qE6Kem5Y+R55qE6ZiA5YC877yM55m+5YiG5q+U77yMMC0xXHJcbiAgICAgKi9cclxuICAgIGNsb3NlVGhyZXNob2xkOiAwLjFcclxufTtcclxuLyoqXHJcbiAqIOW4uOmHj1xyXG4gKi9cclxuY29uc3QgQVhJU19TWU1CT0wgPSBbJ3gnLCAneSddO1xyXG5cclxuLyoqXHJcbiAqIGdhbGxlcnnnsbvvvIzkuLvopoHmiYvlir/lpITnkIbvvIzmlbDlgLzorqHnrpfvvIzku6Xlj4rliqjkvZzpmZDliLbvvIzkuI3lgZpET03mk43kvZzjgIJcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbGxlcnkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRvdWNoQXJlYSBcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIOiHquWumuS5iemFjee9rlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih0b3VjaEFyZWEsIG9wdGlvbnMpe1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOinpuaRuOS6pOS6kuWMuuWfn1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudG91Y2hBcmVhID0gdG91Y2hBcmVhO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOmFjee9ruWPguaVsFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWunuS+i+WMluaJi+WKv+iuoeeul+WZqFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRvciA9IG5ldyBHZXN0dXJlQ2FsY3VsYXRvcih0aGlzLnRvdWNoQXJlYSwgdGhpcy5vcHRpb25zKTtcclxuXHJcbiAgICAgICAgdGhpcy5pbml0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdCgpe1xyXG4gICAgICAgIGlmKHRoaXMubWFuYWdlcil7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbmV3IEhhbW1lci5NYW5hZ2VyKHRoaXMudG91Y2hBcmVhKTtcclxuICAgICAgICB0aGlzLm1hbmFnZXIuYWRkKG5ldyBIYW1tZXIuUGFuKHt0aHJlc2hvbGQ6IDAsIHBvaW50ZXJzOiAwfSkpO1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5hZGQobmV3IEhhbW1lci5QaW5jaCh7IHRocmVzaG9sZDogMC4wNSB9KSkucmVjb2duaXplV2l0aCh0aGlzLm1hbmFnZXIuZ2V0KCdwYW4nKSk7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmFkZChuZXcgSGFtbWVyLlN3aXBlKCkpLnJlY29nbml6ZVdpdGgodGhpcy5tYW5hZ2VyLmdldCgncGFuJykpO1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5hZGQoIG5ldyBIYW1tZXIuVGFwKHsgZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyIH0pICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnu5HlrprmiYvlir/kuovku7ZcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUg6ZyA6KaB57uR5a6a55qE5LqL5Lu25ZCN56ewXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBcclxuICAgICAqL1xyXG4gICAgb24oZXZlbnROYW1lLCBjYWxsYmFjayl7XHJcbiAgICAgICAgbGV0IHByb3h5ID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXTtcclxuICAgICAgICBpZighcHJveHkpe1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgdW5rbm93biBldmVudCAnJHtldmVudE5hbWV9J2ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmV2ZW50cy5jYWxsYmFja3NbZXZlbnROYW1lXSA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHByb3h5LmNhbGwodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlSW1hZ2VJbmRleChuZXdJbmRleCl7XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdG9yLmN1ckltZ0luZGV4ID0gbmV3SW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0SW1hZ2VzTnVtYmVyKG51bWJlcil7XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdG9yLmltYWdlc051bWJlciA9IG51bWJlcjtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0b3IuaW5pdFZhbHVlcygpO1xyXG4gICAgfVxyXG5cclxuICAgIHRyaWdnZXIoZXZlbnROYW1lLCBlKXtcclxuICAgICAgICBsZXQgZXZlbnRGdW5jID0gdGhpcy5ldmVudHMuZnVuY3Rpb25zW2V2ZW50TmFtZV07XHJcbiAgICAgICAgbGV0IGNhbGxiYWNrID0gdGhpcy5ldmVudHMuY2FsbGJhY2tzW2V2ZW50TmFtZV07XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50RnVuYy5jYWxsKHRoaXMsIChyZXN1bHQpPT57XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHtyZXN1bHQsIGV9KTtcclxuICAgICAgICB9LCBlKTtcclxuICAgIH1cclxuXHJcbiAgICBjb3JyZWN0KCl7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29ycmVjdDogdGhpcy5jYWxjdWxhdG9yLmNvcnJlY3QoKS5jb3JyZWN0LCBcclxuICAgICAgICAgICAgc2NhbGU6IHRoaXMuY2FsY3VsYXRvci5nZXQoJ3NjYWxlJyksIFxyXG4gICAgICAgICAgICBzbGlkZTogdGhpcy5jYWxjdWxhdG9yLmdldCgnc2xpZGUnKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmVzZXRHYWxsZXJ5KCl7XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdG9yLmluaXRWYWx1ZXMoKTtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0b3IuY3VySW1nSW5kZXggPSAwO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBmbiA9IEdhbGxlcnkucHJvdG90eXBlO1xyXG5cclxuLyoqXHJcbiAqIGV2ZW50c1xyXG4gKi9cclxuZm4uZXZlbnRzID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiDmu5Hliqjkuovku7ZcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHtkaXN0YW5jZTpbeCx5XSwgb3JnfSBcclxuICAgICAqIG9yZyDmmK8gaGFtbWVyanPnmoTkuovku7blr7nosaFcclxuICAgICAqL1xyXG4gICAgc2xpZGUoKXtcclxuICAgICAgICB0aGlzLm1hbmFnZXIub24oJ3BhbnN0YXJ0IHBhbm1vdmUnLCBlPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3NsaWRlJywgZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiDmjY/nmoTmiYvlir/kuovku7ZcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFxyXG4gICAgICovXHJcbiAgICBwaW5jaCgpe1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5vbigncGluY2hzdGFydCBwaW5jaG1vdmUnLCBlPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3BpbmNoJywgZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgc3dpcGUoKXtcclxuICAgICAgICB0aGlzLm1hbmFnZXIub24oJ3N3aXBlJywgZT0+e1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3N3aXBlJywgZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgZG91YmxldGFwKCl7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLm9uKCdkb3VibGV0YXAnLCBlPT57XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZG91YmxldGFwJywgZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgYWN0aW9uZW5kKCl7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLm9uKCdwaW5jaGNhbmNlbCBwaW5jaGVuZCcsIGU9PntcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdhY3Rpb25lbmQnLCBlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1hbmFnZXIub24oJ3BhbmNhbmNlbCBwYW5lbmQnLCBlPT57XHJcbiAgICAgICAgICAgIGlmKCF0aGlzLnRyaWdnZXIoJ2Nsb3NlJywgZSkpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYWN0aW9uZW5kJywgZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgY2xvc2UoKXtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIOS6i+S7tuaJgOWvueW6lOeahOWkhOeQhuaWueazleOAguWIhuW8gOeahOWlveWkhOaYr+WPr+S7pemaj+aEj+inpuWPkeWvueW6lOeahOS6i+S7tuaWueazleOAglxyXG4gKi9cclxuZm4uZXZlbnRzLmZ1bmN0aW9ucyA9IHt9O1xyXG5PYmplY3QuYXNzaWduKGZuLmV2ZW50cy5mdW5jdGlvbnMsIHtcclxuICAgIC8qKlxyXG4gICAgICog5ruR5Yqo5LqL5Lu25pa55rOVXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZSBcclxuICAgICAqL1xyXG4gICAgc2xpZGUoY2FsbGJhY2ssIGUpe1xyXG4gICAgICAgIGlmKHRoaXMuaXNMb2NrKXtyZXR1cm47fVxyXG4gICAgICAgIGNvbnN0IGlzU3RhcnQgPSBlLnR5cGU9PT0ncGFuc3RhcnQnO1xyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRvci5zbGlkZShlLmRlbHRhWCwgZS5kZWx0YVksIGlzU3RhcnQpO1xyXG4gICAgICAgIGNhbGxiYWNrKHtzbGlkZTp0aGlzLmNhbGN1bGF0b3IuZ2V0KCdzbGlkZScpLCBib3VuZDogdGhpcy5jYWxjdWxhdG9yLmNoZWNrQm91bmQobnVsbCwgbnVsbCwgdHJ1ZSl9KTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIOaNj+eahOS6i+S7tuaWueazlVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGUgXHJcbiAgICAgKi9cclxuICAgIHBpbmNoKGNhbGxiYWNrLCBlKXtcclxuICAgICAgICBjb25zdCBpc1N0YXJ0ID0gZS50eXBlPT09J3BpbmNoc3RhcnQnO1xyXG4gICAgICAgIGlmKGlzU3RhcnQpe3RoaXMuY2FsY3VsYXRvci5wb3NpdGlvbihlLmNlbnRlcik7fVxyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRvci56b29tKE51bWJlci5wYXJzZUZsb2F0KGUuc2NhbGUpLCBpc1N0YXJ0KTtcclxuICAgICAgICBjYWxsYmFjayh7bGFzdEFjdGlvbkRhdGE6IHRoaXMuY2FsY3VsYXRvci5nZXRMYXN0QWN0aW9uRGF0YSgnc2NhbGUnKSwgc2NhbGU6IHRoaXMuY2FsY3VsYXRvci5nZXQoJ3NjYWxlJyksIFxyXG4gICAgICAgICAgICBzbGlkZTogdGhpcy5jYWxjdWxhdG9yLmdldCgnc2xpZGUnKX0pO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICog5b+r6YCf5ruR5Yqo55qE5LqL5Lu25pa55rOVXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZSBcclxuICAgICAqL1xyXG4gICAgc3dpcGUoY2FsbGJhY2ssIGUpe1xyXG4gICAgICAgIGxldCBzbGlkZVN0YXJ0RGF0YVggPSB0aGlzLmNhbGN1bGF0b3IuZ2V0TGFzdEFjdGlvbkRhdGEoJ3NsaWRlJykueDtcclxuICAgICAgICBsZXQgYm91bmRYID0gdGhpcy5jYWxjdWxhdG9yLmNoZWNrQm91bmQobnVsbCwge3g6IHNsaWRlU3RhcnREYXRhWCtlLmRlbHRhWCwgeTowfSwgdHJ1ZSkueDtcclxuICAgICAgICBpZighdGhpcy5jYWxjdWxhdG9yLnN3aXRjaFRocmVzaG9sZChlLmRlbHRhWCkgJiYgYm91bmRYLmlzT3ZlciAmJiBNYXRoLmFicyhlLmRlbHRhWCkgPD0gTWF0aC5hYnMoYm91bmRYLm51bWJlcikpe1xyXG4gICAgICAgICAgICBsZXQgZGlyZWN0aW9uO1xyXG4gICAgICAgICAgICBpZihlLmRpcmVjdGlvbiA9PT0gSGFtbWVyLkRJUkVDVElPTl9MRUZUKXtcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICduZXh0JztcclxuICAgICAgICAgICAgfWVsc2UgaWYoZS5kaXJlY3Rpb24gPT09IEhhbW1lci5ESVJFQ1RJT05fUklHSFQpe1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ3ByZXZpb3VzJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgc3dpdGNoT2JqID0gdGhpcy5jYWxjdWxhdG9yLnN3aXRjaChkaXJlY3Rpb258fGZhbHNlLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICBjYWxsYmFjayh7c3dpdGNoT2JqfSwgZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRlbHRhVGltZSA9IGUuZGVsdGFUaW1lO1xyXG4gICAgICAgIGxldCBzY2FsZSA9IHRoaXMuY2FsY3VsYXRvci5nZXQoJ3NjYWxlJyk7XHJcbiAgICAgICAgaWYoZGVsdGFUaW1lID4gMjAwIHx8IHNjYWxlIDw9IDEpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRvci5zd2lwZShlLmRlbHRhWCwgZS5kZWx0YVksIGRlbHRhVGltZSk7XHJcbiAgICAgICAgY2FsbGJhY2soe3NsaWRlOiB0aGlzLmNhbGN1bGF0b3IuZ2V0KCdzbGlkZScpfSwgZSk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiDlj4zlh7vnmoTkuovku7bmlrnms5VcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayBcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIFxyXG4gICAgICovXHJcbiAgICBkb3VibGV0YXAoY2FsbGJhY2ssIGUpe1xyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5jYWxjdWxhdG9yLmdldCgnc2NhbGUnKTtcclxuICAgICAgICBpZihzY2FsZSA8IDMpe1xyXG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0b3IucG9zaXRpb24oZS5jZW50ZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0b3Iuem9vbSgoMy1zY2FsZSkrMSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRvci5jb3JyZWN0KDMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRvci5pbml0VmFsdWVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxiYWNrKHtzY2FsZTogdGhpcy5jYWxjdWxhdG9yLmdldCgnc2NhbGUnKSwgc2xpZGU6IHRoaXMuY2FsY3VsYXRvci5nZXQoJ3NsaWRlJyl9KTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIOaMgee7reWKqOS9nOe7k+adn+eahOS6i+S7tuaWueazle+8jOmAgueUqOS6jua7keWKqO+8jOaNj+WKqOS9nOeahOe7k+adn+S6i+S7tuOAglxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGUgXHJcbiAgICAgKi9cclxuICAgIGFjdGlvbmVuZChjYWxsYmFjaywgZSl7XHJcbiAgICAgICAgaWYodGhpcy5pc0xvY2spe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXNMb2NrID0gdHJ1ZTtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5pc0xvY2sgPSBmYWxzZTtcclxuICAgICAgICB9LCAyMDApO1xyXG4gICAgICAgIGlmKHRoaXMuY2FsY3VsYXRvci5nZXRMYXN0QWN0aW9uRGF0YSgnc2NhbGUnKSA8PSAxICYmIHRoaXMuY2FsY3VsYXRvci5nZXQoJ3NjYWxlJykgPCAxKXtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMuY2FsbGJhY2tzWydjbG9zZSddKHtjbG9zZTp0cnVlfSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRHYWxsZXJ5KCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmVmb3JlID0gdGhpcy5jYWxjdWxhdG9yLmdldCgnc2xpZGUnKS5zbGljZSgpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY2FsY3VsYXRvci5jb3JyZWN0KCk7XHJcbiAgICAgICAgbGV0IHN3aXRjaE9iaiA9IHtzd2l0Y2g6IGZhbHNlfTtcclxuICAgICAgICBpZigoZS50eXBlID09PSAncGFuY2FuY2VsJyB8fCBlLnR5cGUgPT09ICdwYW5lbmQnKSAmJiBlLnBvaW50ZXJzLmxlbmd0aCA9PSAxICYmIHJlc3VsdC5ib3VuZCBcclxuICAgICAgICAgICAgJiYgcmVzdWx0LmJvdW5kLnguaXNPdmVyICYmIE1hdGguYWJzKGUuZGVsdGFYKSA8PSBNYXRoLmFicyhyZXN1bHQuYm91bmQueC5udW1iZXIpKXtcclxuICAgICAgICAgICAgbGV0IGRpcmVjdGlvbiA9IGJlZm9yZS54PjA/J3ByZXZpb3VzJzonbmV4dCc7XHJcbiAgICAgICAgICAgIGxldCBpc1N3aXRjaCA9IHRoaXMuY2FsY3VsYXRvci5zd2l0Y2hUaHJlc2hvbGQocmVzdWx0LmJvdW5kLngubnVtYmVyKTtcclxuICAgICAgICAgICAgc3dpdGNoT2JqID0gdGhpcy5jYWxjdWxhdG9yLnN3aXRjaChpc1N3aXRjaCwgZGlyZWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FsbGJhY2soe1xyXG4gICAgICAgICAgICBzbGlkZTogdGhpcy5jYWxjdWxhdG9yLmdldCgnc2xpZGUnKSxcclxuICAgICAgICAgICAgc2NhbGU6IHRoaXMuY2FsY3VsYXRvci5nZXQoJ3NjYWxlJyksXHJcbiAgICAgICAgICAgIGNvcnJlY3Q6IHJlc3VsdC5jb3JyZWN0LFxyXG4gICAgICAgICAgICBzd2l0Y2hPYmpcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIOebuOWGjOWFs+mXreS6i+S7tuaWueazlVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGUgIFxyXG4gICAgICovXHJcbiAgICBjbG9zZShjYWxsYmFjaywgZSl7XHJcbiAgICAgICAgY29uc3Qgc2xpZGVZID0gdGhpcy5jYWxjdWxhdG9yLmdldCgnc2xpZGUnKS55O1xyXG4gICAgICAgIGNvbnN0IGJvdW5kID0gdGhpcy5jYWxjdWxhdG9yLmNoZWNrQm91bmQobnVsbCwgbnVsbCwgdHJ1ZSkueTtcclxuICAgICAgICBjb25zdCB0b3VjaEFyZWFTaXplID0gdGhpcy5jYWxjdWxhdG9yLmdldFRvdWNoQXJlYVNpemUoKS55fHx3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgY2xvc2VUaHJlc2hvbGQgPSB0aGlzLm9wdGlvbnMuY2xvc2VUaHJlc2hvbGQ7XHJcbiAgICAgICAgaWYodGhpcy5jYWxjdWxhdG9yLmdldCgnc2NhbGUnKSA+PTEgJiYgYm91bmQuaXNPdmVyICYmIE1hdGguYWJzKGJvdW5kLm51bWJlcikgPj0gKHRvdWNoQXJlYVNpemUqY2xvc2VUaHJlc2hvbGQpICYmIHNsaWRlWSA+IDAgJiYgXHJcbiAgICAgICAgICAgIGUuZGVsdGFZIDw9IE1hdGguYWJzKGJvdW5kLm51bWJlcikpe1xyXG4gICAgICAgICAgICBjYWxsYmFjayh7Y2xvc2U6IHRydWV9KTtcclxuICAgICAgICAgICAgdGhpcy5yZXNldEdhbGxlcnkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufSk7XHJcbi8qKlxyXG4gKiDnlKjkuo7lrZjmlL7miYDmnInkuovku7bnmoTlm57osIPlh73mlbBcclxuICovXHJcbmZuLmV2ZW50cy5jYWxsYmFja3MgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiDorqHnrpflmajniLbnsbvjgIJcclxuICovXHJcbmNsYXNzIENhbGN1bGF0b3Ige1xyXG4gICAgXHJcbiAgICBjb25zdHJ1Y3Rvcih0b3VjaEFyZWEsIG9wdGlvbnMpe1xyXG4gICAgICAgIHRoaXMudG91Y2hBcmVhID0gdG91Y2hBcmVhO1xyXG4gICAgICAgIC8v55So5oi36YWN572u5L+h5oGvXHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICAvL+WbvueJh+eahOW9k+WJjee0ouW8lVxyXG4gICAgICAgIHRoaXMuY3VySW1nSW5kZXggPSAwO1xyXG4gICAgICAgIC8v5Zu+54mH5oC75pWwXHJcbiAgICAgICAgdGhpcy5pbWFnZXNOdW1iZXIgPSAwO1xyXG5cclxuICAgICAgICAvL+iuoeeul+aVsOaNrlxyXG4gICAgICAgIHRoaXMuZGF0YXMgPSB7XHJcbiAgICAgICAgICAgIHNsaWRlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgICAgIHNsaWNlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7eDogdGhpcy54LCB5OiB0aGlzLnl9O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzY2FsZTogMSxcclxuICAgICAgICAgICAgbGFzdFNjYWxlOiAxLFxyXG4gICAgICAgICAgICBsYXN0QWN0aW9uRGF0YXM6IHtcclxuICAgICAgICAgICAgICAgIHNsaWRlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgICAgICAgICB5OiAwXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2NhbGU6IDFcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdHJhY2s6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6IiN5YWl77yM5L+d55WZ5oyH5a6a55qE5L2N5pWw77yM6buY6K6k5L+d55WZMuS9jeWwj+aVsFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG51bSBcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSDkv53nlZnnmoTkvY3mlbBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJvdW5kKG51bSwgc2NhbGUpe1xyXG4gICAgICAgIG51bSA9IG51bSBpbnN0YW5jZW9mIE51bWJlcj92YWw6TnVtYmVyLnBhcnNlRmxvYXQobnVtKTtcclxuICAgICAgICBpZihOdW1iZXIuaXNOYU4obnVtKSl7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtudW19IOS4jeaYr+acieaViOeahOaVsOWAvO+8gWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTnVtYmVyLnBhcnNlRmxvYXQobnVtLnRvRml4ZWQoc2NhbGV8fDIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluaJi+WKv+inpueisOWMuuWfn+eahOWwuuWvuFxyXG4gICAgICovXHJcbiAgICBnZXRUb3VjaEFyZWFTaXplKCl7XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHt9O1xyXG4gICAgICAgIHNpemUueCA9IHRoaXMudG91Y2hBcmVhLmNsaWVudFdpZHRoO1xyXG4gICAgICAgIHNpemUueSA9IHRoaXMudG91Y2hBcmVhLmNsaWVudEhlaWdodDtcclxuICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluWbvueJh+W9k+WJjeeahOWwuuWvuFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHpvb21TY2FsZSDpnIDopoHnvKnmlL7nmoTmr5TkvosgXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IOi/lOWbnuS4gOS4quaVsOe7hO+8jHt4LCB5fVxyXG4gICAgICovXHJcbiAgICBnZXRJbWdTaXplKHpvb21TY2FsZSl7XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy50b3VjaEFyZWEuY2hpbGROb2Rlc1t0aGlzLmN1ckltZ0luZGV4XTtcclxuICAgICAgICBzaXplLnggPSBOdW1iZXIucGFyc2VJbnQoZWwuY2xpZW50V2lkdGgqKHpvb21TY2FsZXx8MSkpO1xyXG4gICAgICAgIHNpemUueSA9IE51bWJlci5wYXJzZUludChlbC5jbGllbnRIZWlnaHQqKHpvb21TY2FsZXx8MSkpO1xyXG4gICAgICAgIHJldHVybiBzaXplO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIOajgOafpeaYr+WQpuW3sue7j+i2iui/h+S6hui+ueeVjFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHpvb21TY2FsZSBcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNsaWRlQXJyYXkg5Zyo6L+Y5rKh5pyJ5pu05pawZG9t5LmL5YmN55qE6K6h566XXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5vRGlmZmVyZW5jZSDmmK/lkKbpnIDopoHlh4/ljrvlm77niYfkuI7ovrnnlYznmoTlt67lgLxcclxuICAgICAqL1xyXG4gICAgY2hlY2tCb3VuZCh6b29tU2NhbGUsIHNsaWRlQXJyYXksIG5vRGlmZmVyZW5jZSl7XHJcbiAgICAgICAgY29uc3Qgc2xpZGUgPSBzbGlkZUFycmF5fHx0aGlzLmdldCgnc2xpZGUnKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDotorov4fnmoTmlbDlgLxcclxuICAgICAgICAgKi9cclxuICAgICAgICBsZXQgcmVzdWx0T2JqID0ge307XHJcbiAgICAgICAgdGhpcy5lYWNoQXhpcygoYXhpcyk9PntcclxuICAgICAgICAgICAgbGV0IHpvb21VcCA9IHRoaXMuZ2V0Qm91bmQoYXhpcywgem9vbVNjYWxlKTtcclxuICAgICAgICAgICAgbGV0IHNsaWRlVmFsID0gTWF0aC5hYnMoc2xpZGVbYXhpc10pO1xyXG4gICAgICAgICAgICBsZXQgb3Zlck51bSA9IHpvb21VcC1zbGlkZVZhbDtcclxuICAgICAgICAgICAgb3Zlck51bSA9IG5vRGlmZmVyZW5jZT9vdmVyTnVtLXRoaXMuZ2V0SW1hZ2VTaXplRGlmZlZhbChheGlzLCB6b29tU2NhbGUpOm92ZXJOdW07XHJcbiAgICAgICAgICAgIHJlc3VsdE9ialtheGlzXSA9IHtcclxuICAgICAgICAgICAgICAgIGlzT3Zlcjogb3Zlck51bTwwLFxyXG4gICAgICAgICAgICAgICAgbnVtYmVyOiBvdmVyTnVtXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0T2JqO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Y+W5b6X5oyH5a6a6L2055qE6L6555WM5YC8XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXhpcyBcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB6b29tU2NhbGUgXHJcbiAgICAgKi9cclxuICAgIGdldEJvdW5kKGF4aXMsIHpvb21TY2FsZSl7XHJcbiAgICAgICAgY29uc3QgdG91Y2hBcmVhU2l6ZSA9IHRoaXMuZ2V0VG91Y2hBcmVhU2l6ZSgpO1xyXG4gICAgICAgIGNvbnN0IGltZ1NpemUgPSB0aGlzLmdldEltZ1NpemUoem9vbVNjYWxlKTtcclxuICAgICAgICBsZXQgZWxTaXplID0gaW1nU2l6ZVtheGlzXTtcclxuICAgICAgICBsZXQgem9vbVVwID0gKGVsU2l6ZS10b3VjaEFyZWFTaXplW2F4aXNdKS8yO1xyXG4gICAgICAgIHJldHVybiB6b29tVXA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnuqDmraPlm77niYfohLHnprvnqpflj6PovrnnlYznmoTmg4XlhrVcclxuICAgICAqIENvcnJlY3QgdGhlIGltYWdlJ3MgZGVwYXJ0dXJlIGZyb20gdGhlIHdpbmRvdyBib3VuZGFyeVxyXG4gICAgICovXHJcbiAgICBjb3JyZWN0KHNjYWxlVil7XHJcbiAgICAgICAgbGV0IHNjYWxlID0gdGhpcy5nZXQoJ3NjYWxlJyk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWmguaenHNjYWxl5bCP5LqOMemCo+S5iHNsaWRl5ZKMc2NhbGXnmoTlgLzlj5jkuLrliJ3lp4vljJblgLxcclxuICAgICAgICAgKiBpZiB0aGUgc2NhbGUgPCAxLCB0aGVuIHRoZSB2YWx1ZXMgb2Ygc2xpZGUmc2NhbGUgYmVjb21lIGluaXRpYWxpemF0aW9uIHZhbHVlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmKHNjYWxlIDw9IDEpe1xyXG4gICAgICAgICAgICBjb25zdCBib3VuZCA9IHRoaXMuY2hlY2tCb3VuZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmluaXRWYWx1ZXMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtjb3JyZWN0OnRydWUsIGJvdW5kfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5aaC5p6c5Zu+54mH57yp5pS+5aSn5LqOM++8jOmCo+S5iOWwsei/mOWOn+S4ujNcclxuICAgICAgICAgKi9cclxuICAgICAgICBsZXQgZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBtYXhTY2FsZSA9IHRoaXMub3B0aW9ucy5tYXhTY2FsZTtcclxuICAgICAgICBjb25zdCB6b29tU2NhbGUgPSBzY2FsZT5tYXhTY2FsZT9tYXhTY2FsZS9zY2FsZTpudWxsO1xyXG4gICAgICAgIGlmKHNjYWxlID4gbWF4U2NhbGUpe1xyXG4gICAgICAgICAgICB0aGlzLnpvb20oem9vbVNjYWxlLCB0cnVlKTtcclxuICAgICAgICAgICAgZmxhZyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOe6oOato+WbvueJh+eahOS9jee9rlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IHNsaWRlID0gdGhpcy5nZXQoJ3NsaWRlJyk7XHJcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IHRoaXMuY2hlY2tCb3VuZChzY2FsZVZ8fHpvb21TY2FsZSk7XHJcbiAgICAgICAgY29uc3QgbmV3U2xpZGVWYWwgPSB7eDogMCwgeTowfTtcclxuICAgICAgICBjb25zdCByZXN1bHRBcnJheSA9IHRoaXMuZWFjaEF4aXMoKGF4aXMpPT57XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrZWRbYXhpc107XHJcbiAgICAgICAgICAgIGlmKCFyZXN1bHQuaXNPdmVyIHx8IChyZXN1bHQuaXNPdmVyICYmIHJlc3VsdC5udW1iZXIgPT09IDApKXtyZXR1cm4gZmFsc2U7fVxyXG4gICAgICAgICAgICBjb25zdCBkaWZmVmFsID0gdGhpcy5nZXRJbWFnZVNpemVEaWZmVmFsKGF4aXMsIHNjYWxlVnx8em9vbVNjYWxlKTtcclxuICAgICAgICAgICAgbmV3U2xpZGVWYWxbYXhpc10gPSAoc2xpZGVbYXhpc108MD9NYXRoLmFicyhyZXN1bHQubnVtYmVyKStkaWZmVmFsOnJlc3VsdC5udW1iZXIrTWF0aC5hYnMoZGlmZlZhbCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZFNsaWRlKG5ld1NsaWRlVmFsLngsIG5ld1NsaWRlVmFsLnkpO1xyXG4gICAgICAgIGZsYWcgPSBmbGFnfHxyZXN1bHRBcnJheS54fHxyZXN1bHRBcnJheS55O1xyXG4gICAgICAgIHJldHVybiB7Y29ycmVjdDogZmxhZywgYm91bmQ6IGNoZWNrZWR9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBlYWNoQXhpcyhmdW5jKXtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgICAgICBBWElTX1NZTUJPTC5mb3JFYWNoKChheGlzLCBpbmRleCk9PntcclxuICAgICAgICAgICAgcmVzdWx0W2F4aXNdID0gZnVuYyhheGlzLCBpbmRleCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuoeeul+WbvueJh+S4jui+ueeVjOeahOW3ruWAvFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF4aXMgXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gem9vbVNjYWxlIFxyXG4gICAgICovXHJcbiAgICBnZXRJbWFnZVNpemVEaWZmVmFsKGF4aXMsIHpvb21TY2FsZSl7XHJcbiAgICAgICAgYXhpcyA9IGF4aXN8fCd4JztcclxuICAgICAgICBjb25zdCBpbWdTaXplID0gdGhpcy5nZXRJbWdTaXplKHpvb21TY2FsZSk7XHJcbiAgICAgICAgY29uc3QgdG91Y2hBcmVhU2l6ZSA9IHRoaXMuZ2V0VG91Y2hBcmVhU2l6ZSgpO1xyXG4gICAgICAgIHJldHVybiBpbWdTaXplW2F4aXNdPnRvdWNoQXJlYVNpemVbYXhpc10/MDooaW1nU2l6ZVtheGlzXS10b3VjaEFyZWFTaXplW2F4aXNdKS8yO1xyXG4gICAgfVxyXG59XHJcblxyXG5PYmplY3QuYXNzaWduKENhbGN1bGF0b3IucHJvdG90eXBlLCB7XHJcbiAgICBpbml0VmFsdWVzKCl7XHJcbiAgICAgICAgdGhpcy5kYXRhcy5zY2FsZSA9IDE7XHJcbiAgICAgICAgdGhpcy5kYXRhcy5sYXN0U2NhbGUgPSAxO1xyXG4gICAgICAgIHRoaXMuZGF0YXMuc2xpZGUuaW5pdCgpO1xyXG4gICAgfSxcclxuICAgIGFkZFNsaWRlKHgsIHkpe1xyXG4gICAgICAgIHggPSB4fHwwO1xyXG4gICAgICAgIHkgPSB5fHwwO1xyXG4gICAgICAgIHRoaXMuZGF0YXMuc2xpZGUueCA9IENhbGN1bGF0b3Iucm91bmQodGhpcy5kYXRhcy5zbGlkZS54K3gpO1xyXG4gICAgICAgIHRoaXMuZGF0YXMuc2xpZGUueSA9IENhbGN1bGF0b3Iucm91bmQodGhpcy5kYXRhcy5zbGlkZS55K3kpO1xyXG4gICAgfSxcclxuICAgIGFkZFNjYWxlKHNjYWxlKXtcclxuICAgICAgICB0aGlzLmRhdGFzLmxhc3RTY2FsZSA9IHRoaXMuZGF0YXMuc2NhbGU7XHJcbiAgICAgICAgdGhpcy5kYXRhcy5zY2FsZSA9IENhbGN1bGF0b3Iucm91bmQodGhpcy5kYXRhcy5zY2FsZStzY2FsZSk7XHJcbiAgICB9LFxyXG4gICAgZ2V0KGtleSl7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuZGF0YXNba2V5XTtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChyZXN1bHQsIGDmsqHmnInmib7liLAgJHtrZXl9IOebuOWFs+eahOaVsOaNru+8gWApO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAgc2V0TGFzdEFjdGlvbkRhdGEoa2V5LCB2YWwpe1xyXG4gICAgICAgIGxldCBjaGVjayA9IHRoaXMuZGF0YXMubGFzdEFjdGlvbkRhdGFzW2tleV07XHJcbiAgICAgICAgaWYoIWNoZWNrKXtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihg6K6+572uICR7a2V5fSDkuLogJHt2YWx9IOWksei0pe+8geS4jeWtmOWcqCAke2tleX0g55u45YWz55qE5Yqo5L2c5pWw5o2uIWApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGF0YXMubGFzdEFjdGlvbkRhdGFzW2tleV0gPSB2YWw7XHJcbiAgICB9LFxyXG4gICAgZ2V0TGFzdEFjdGlvbkRhdGEoa2V5KXtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5kYXRhcy5sYXN0QWN0aW9uRGF0YXNba2V5XTtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChyZXN1bHQsIGDmsqHmnInmib7liLAgJHtrZXl9IOebuOWFs+eahOWKqOS9nOaVsOaNruaVsOaNru+8gWApO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIHBpbmNo55u45YWz55qE6K6h566X5pa55rOVXHJcbiAqL1xyXG5jbGFzcyBHZXN0dXJlQ2FsY3VsYXRvciBleHRlbmRzIENhbGN1bGF0b3Ige1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHRvdWNoQXJlYSwgb3B0aW9ucyl7XHJcbiAgICAgICAgc3VwZXIodG91Y2hBcmVhLCBvcHRpb25zKTtcclxuICAgICAgICAvL+inpueisOeCueS9jee9ruS/oeaBr1xyXG4gICAgICAgIHRoaXMucG9zaXRpb25WYWwgPSB7eDogMCwgeTogMH07XHJcbiAgICAgICAgLy/mr4/mrKHnp7vliqjnmoTlvIDlp4vlgLxcclxuICAgICAgICB0aGlzLnNsaWRlU3RhcnRWYWwgPSB7eDogMCwgeTogMH07XHJcbiAgICAgICAgLy/mr4/mrKHnvKnmlL7nmoTlvIDlp4vlgLxcclxuICAgICAgICB0aGlzLnBpbmNoU3RhcnRWYWwgPSAwO1xyXG4gICAgICAgIC8v55So5LqO6ZSB5a6a5YiH5o2iXHJcbiAgICAgICAgdGhpcy5zd2l0Y2hMb2NrZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOa7keWKqOiuoeeul+aWueazlVxyXG4gICAgICogQHBhcmFtIHsqfSB4IFxyXG4gICAgICogQHBhcmFtIHsqfSB5IFxyXG4gICAgICogQHBhcmFtIHsqfSBpc1N0YXJ0IFxyXG4gICAgICovXHJcbiAgICBzbGlkZSh4LCB5LCBpc1N0YXJ0KXtcclxuICAgICAgICBsZXQgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICBsZXQgZGlzdGFuY2UgPSBbMCwgMF07XHJcbiAgICAgICAgaWYoaXNTdGFydCl7dGhpcy5zZXRMYXN0QWN0aW9uRGF0YSgnc2xpZGUnLCB0aGlzLmdldCgnc2xpZGUnKS5zbGljZSgpKTt9XHJcbiAgICAgICAgdGhpcy5lYWNoQXhpcygoYXhpcywgaW5kZXgpPT57XHJcbiAgICAgICAgICAgIGxldCBzdGFydFZhbCA9IHRoaXMuc2xpZGVTdGFydFZhbFtheGlzXTtcclxuICAgICAgICAgICAgbGV0IG5ld1ZhbCA9IGFyZ3NbaW5kZXhdO1xyXG4gICAgICAgICAgICBpZihpc1N0YXJ0KXtcclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlW2luZGV4XSA9IHN0YXJ0VmFsPT1uZXdWYWx8fE1hdGguYWJzKG5ld1ZhbCk+TWF0aC5hYnMoc3RhcnRWYWwpP25ld1ZhbC1zdGFydFZhbDpuZXdWYWw7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VbaW5kZXhdID0gbmV3VmFsLXN0YXJ0VmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zbGlkZVN0YXJ0VmFsID0ge3gsIHl9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZFNsaWRlLmFwcGx5KHRoaXMsIGRpc3RhbmNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWumuS9jeW9k+WJjeaJi+aMh+inpueisOeahOS9jee9ru+8jOeUqOS6juWcqOe8qeaUvuaXtuWAmeWni+e7iOS/neS7peaJi+aMh+aJgOWcqOS9jee9ruadpee8qeaUvlxyXG4gICAgICogQHBhcmFtIHsqfSBjZW50ZXIgXHJcbiAgICAgKi9cclxuICAgIHBvc2l0aW9uKGNlbnRlcil7XHJcbiAgICAgICAgdGhpcy5lYWNoQXhpcygoYXhpcyk9PntcclxuICAgICAgICAgICAgY29uc3QgdGFTaXplID0gdGhpcy5nZXRUb3VjaEFyZWFTaXplKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGF4aXNTaXplID0gdGFTaXplW2F4aXNdLzI7XHJcbiAgICAgICAgICAgIGxldCBjdXJBeGlzU2l6ZSA9IGF4aXNTaXplK3RoaXMuZ2V0KCdzbGlkZScpW2F4aXNdO1xyXG4gICAgICAgICAgICBsZXQgY2VudGVyVmFsID0gY2VudGVyW2F4aXNdO1xyXG4gICAgICAgICAgICBsZXQgc2NhbGUgPSB0aGlzLmdldCgnc2NhbGUnKTtcclxuICAgICAgICAgICAgbGV0IGNhbCA9IChjdXJBeGlzU2l6ZS1jZW50ZXJWYWwpL3NjYWxlO1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uVmFsW2F4aXNdID0gQ2FsY3VsYXRvci5yb3VuZChjYWwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Zyo57yp5pS+55qE5ZCM5pe26L+b6KGM56e75Yqo77yM55So5LqO5L+d5oyB5Zu+54mH5aeL57uI5aSE5LqOIHBvc2l0aW9uKCkg5omA5a6a5L2N55qE5L2N572uXHJcbiAgICAgKi9cclxuICAgIG1vdmUoKXtcclxuICAgICAgICBsZXQgY3VyU2NhbGUgPSB0aGlzLmdldCgnc2NhbGUnKTtcclxuICAgICAgICBsZXQgc2NhbGUgPSBjdXJTY2FsZS10aGlzLmdldCgnbGFzdFNjYWxlJyk7XHJcbiAgICAgICAgdGhpcy5hZGRTbGlkZSh0aGlzLnBvc2l0aW9uVmFsLngqc2NhbGUsIHRoaXMucG9zaXRpb25WYWwueSpzY2FsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDov5vooYznvKnmlL7orqHnrpdcclxuICAgICAqIEBwYXJhbSB7Kn0gc2NhbGUgXHJcbiAgICAgKiBAcGFyYW0geyp9IGlzU3RhcnQgXHJcbiAgICAgKi9cclxuICAgIHpvb20oc2NhbGUsIGlzU3RhcnQpe1xyXG4gICAgICAgIGNvbnN0IG9sZCA9IHRoaXMuZ2V0KCdzY2FsZScpO1xyXG4gICAgICAgIGxldCBtYXhTY2FsZSA9IHRoaXMub3B0aW9ucy5tYXhTY2FsZTtcclxuICAgICAgICBpZigoc2NhbGUgPCAxICYmIG9sZCA8IDAuNSkgfHwgKHNjYWxlID4gMSAmJiBvbGQgPiBtYXhTY2FsZSsxKSl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRpc3RhbmNlID0gKHNjYWxlLTEpO1xyXG4gICAgICAgIGlmKGlzU3RhcnQpe1xyXG4gICAgICAgICAgICB0aGlzLnNldExhc3RBY3Rpb25EYXRhKCdzY2FsZScsIG9sZCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmFzZVNjYWxlID0gb2xkO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlLXRoaXMucGluY2hTdGFydFZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5waW5jaFN0YXJ0VmFsID0gKHNjYWxlLTEpO1xyXG4gICAgICAgIHRoaXMuYWRkU2NhbGUoc2NhbGU+PTE/ZGlzdGFuY2U6KHRoaXMuYmFzZVNjYWxlKnNjYWxlKS1vbGQpO1xyXG4gICAgICAgIHRoaXMubW92ZSgpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIOWIh+aNouWbvueJh+iuoeeul1xyXG4gICAgICogQHBhcmFtIHsqfSBpc1N3aXRjaCBcclxuICAgICAqIEBwYXJhbSB7Kn0gZGlyZWN0aW9uIFxyXG4gICAgICovXHJcbiAgICBzd2l0Y2goaXNTd2l0Y2gsIGRpcmVjdGlvbil7XHJcbiAgICAgICAgaWYoIWlzU3dpdGNoIHx8IHRoaXMuc3dpdGNoTG9ja2VkKXtcclxuICAgICAgICAgICAgcmV0dXJuIHtzd2l0Y2g6IGZhbHNlfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zd2l0Y2hMb2NrZWQgPSB0cnVlO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnN3aXRjaExvY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIH0sIDE1MCk7XHJcbiAgICAgICAgbGV0IG5leHQgPSBpc1N3aXRjaCYmZGlyZWN0aW9uPT09J25leHQnO1xyXG4gICAgICAgIGxldCBwcmV2aW91cyA9IGlzU3dpdGNoJiZkaXJlY3Rpb249PT0ncHJldmlvdXMnO1xyXG4gICAgICAgIGlzU3dpdGNoID0gbmV4dCYmdGhpcy5jdXJJbWdJbmRleCsxPHRoaXMuaW1hZ2VzTnVtYmVyO1xyXG4gICAgICAgIGlzU3dpdGNoID0gaXNTd2l0Y2h8fChwcmV2aW91cyYmdGhpcy5jdXJJbWdJbmRleD4wKTtcclxuICAgICAgICBpZihpc1N3aXRjaCl7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdFZhbHVlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge3N3aXRjaDogaXNTd2l0Y2gsIG5leHQsIHByZXZpb3VzfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWbvueJh+WIh+aNoueahOaJgOmcgOeahOmYgOWAvFxyXG4gICAgICogQHBhcmFtIHsqfSBzbGlkZSBcclxuICAgICAqL1xyXG4gICAgc3dpdGNoVGhyZXNob2xkKHNsaWRlKXtcclxuICAgICAgICBzbGlkZSA9IE1hdGguYWJzKHNsaWRlfHx0aGlzLmdldCgnc2xpZGUnKS54KTtcclxuICAgICAgICBsZXQgZGlmZlZhbCA9IHRoaXMuZ2V0SW1hZ2VTaXplRGlmZlZhbCgpO1xyXG4gICAgICAgIHNsaWRlID0gc2xpZGUtTWF0aC5hYnMoZGlmZlZhbCk7XHJcbiAgICAgICAgc2xpZGUgPSBzbGlkZTwwPzA6c2xpZGU7XHJcbiAgICAgICAgcmV0dXJuIHNsaWRlPj10aGlzLmdldFRvdWNoQXJlYVNpemUoKS54LzQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlv6vpgJ/mu5HliqjnmoTorqHnrpfmlrnms5VcclxuICAgICAqIEBwYXJhbSB7Kn0geCBcclxuICAgICAqIEBwYXJhbSB7Kn0geSBcclxuICAgICAqIEBwYXJhbSB7Kn0gZGVsdGFUaW1lIFxyXG4gICAgICovXHJcbiAgICBzd2lwZSh4LCB5LCBkZWx0YVRpbWUpe1xyXG4gICAgICAgIGxldCBzbGlkZSA9IHRoaXMuZ2V0KCdzbGlkZScpLnNsaWNlKCk7XHJcbiAgICAgICAgY29uc3QgcmF0ZSA9IDErKDEtKGRlbHRhVGltZS8yMDApKTtcclxuICAgICAgICBsZXQgbmV3U2xpZGUgPSB7eDogeCpyYXRlLCB5OiB5KnJhdGV9O1xyXG4gICAgICAgIHRoaXMuZWFjaEF4aXMoKGF4aXMpPT57XHJcbiAgICAgICAgICAgIGxldCBib3VuZCA9IHRoaXMuZ2V0Qm91bmQoYXhpcyk7XHJcbiAgICAgICAgICAgIGJvdW5kID0gYm91bmQ8PTA/MDpib3VuZDtcclxuICAgICAgICAgICAgaWYoTWF0aC5hYnMoc2xpZGVbYXhpc10pIDwgYm91bmQpe1xyXG4gICAgICAgICAgICAgICAgaWYoTWF0aC5hYnMoc2xpZGVbYXhpc10pK01hdGguYWJzKG5ld1NsaWRlW2F4aXNdKSA+IGJvdW5kKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2FsID0gYm91bmQtTWF0aC5hYnMoc2xpZGVbYXhpc10pKzMwO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1NsaWRlW2F4aXNdID0gbmV3U2xpZGVbYXhpc108MD8wLWNhbDpjYWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdTbGlkZVtheGlzXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZFNsaWRlKG5ld1NsaWRlLngsIG5ld1NsaWRlLnkpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9HYWxsZXJ5LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD03YzAzMjRkOSZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9HYWxsZXJ5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vR2FsbGVyeS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vR2FsbGVyeS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD03YzAzMjRkOSZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzdHlsZTEgZnJvbSBcIi4vR2FsbGVyeS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MSZsYW5nPWNzcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCI3YzAzMjRkOVwiLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIi9Vc2Vycy9vdXdlaS9EZXNrdG9wL0FQb3B1cHMtR2FsbGVyeS1EZW1vL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGkvZGlzdC9pbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCc3YzAzMjRkOScsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCc3YzAzMjRkOScsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vR2FsbGVyeS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9N2MwMzI0ZDkmc2NvcGVkPXRydWUmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignN2MwMzI0ZDknLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIm5vZGVfbW9kdWxlcy9hcG9wdXBzLWdhbGxlcnkvR2FsbGVyeS52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0dhbGxlcnkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0dhbGxlcnkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0zLTIhLi4vdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0dhbGxlcnkudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9N2MwMzI0ZDkmbGFuZz1zY3NzJnNjb3BlZD10cnVlJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuLi92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTMtMiEuLi92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vR2FsbGVyeS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD03YzAzMjRkOSZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCIiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuLi92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vR2FsbGVyeS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MSZsYW5nPWNzcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0dhbGxlcnkudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTEmbGFuZz1jc3MmXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi4vdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0dhbGxlcnkudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTdjMDMyNGQ5JnNjb3BlZD10cnVlJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9XcmFwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02NTk3MGY1YSZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9XcmFwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vV3JhcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vV3JhcC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD02NTk3MGY1YSZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiNjU5NzBmNWFcIixcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCIvVXNlcnMvb3V3ZWkvRGVza3RvcC9BUG9wdXBzLUdhbGxlcnktRGVtby9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpL2Rpc3QvaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnNjU5NzBmNWEnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnNjU5NzBmNWEnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL1dyYXAudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTY1OTcwZjVhJnNjb3BlZD10cnVlJlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzY1OTcwZjVhJywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJub2RlX21vZHVsZXMvYXBvcHVwcy1nYWxsZXJ5L1dyYXAudnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9XcmFwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9XcmFwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4uL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMy0yIS4uL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9XcmFwLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTY1OTcwZjVhJmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0zLTIhLi4vdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1dyYXAudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NjU5NzBmNWEmbGFuZz1zY3NzJnNjb3BlZD10cnVlJlwiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4uL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9XcmFwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02NTk3MGY1YSZzY29wZWQ9dHJ1ZSZcIiIsIi8qISBIYW1tZXIuSlMgLSB2Mi4wLjcgLSAyMDE2LTA0LTIyXG4gKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiBKb3JpayBUYW5nZWxkZXI7XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCBleHBvcnROYW1lLCB1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG52YXIgVkVORE9SX1BSRUZJWEVTID0gWycnLCAnd2Via2l0JywgJ01veicsICdNUycsICdtcycsICdvJ107XG52YXIgVEVTVF9FTEVNRU5UID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbnZhciBUWVBFX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcblxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBub3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBzZXQgYSB0aW1lb3V0IHdpdGggYSBnaXZlbiBzY29wZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc2V0VGltZW91dENvbnRleHQoZm4sIHRpbWVvdXQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChiaW5kRm4oZm4sIGNvbnRleHQpLCB0aW1lb3V0KTtcbn1cblxuLyoqXG4gKiBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgZm4gb24gZWFjaCBlbnRyeVxuICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXG4gKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7KnxBcnJheX0gYXJnXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpbnZva2VBcnJheUFyZyhhcmcsIGZuLCBjb250ZXh0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHdhbGsgb2JqZWN0cyBhbmQgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIW9iaikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiB3cmFwIGEgbWV0aG9kIHdpdGggYSBkZXByZWNhdGlvbiB3YXJuaW5nIGFuZCBzdGFjayB0cmFjZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgdGhlIHN1cHBsaWVkIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gZGVwcmVjYXRlKG1ldGhvZCwgbmFtZSwgbWVzc2FnZSkge1xuICAgIHZhciBkZXByZWNhdGlvbk1lc3NhZ2UgPSAnREVQUkVDQVRFRCBNRVRIT0Q6ICcgKyBuYW1lICsgJ1xcbicgKyBtZXNzYWdlICsgJyBBVCBcXG4nO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ2dldC1zdGFjay10cmFjZScpO1xuICAgICAgICB2YXIgc3RhY2sgPSBlICYmIGUuc3RhY2sgPyBlLnN0YWNrLnJlcGxhY2UoL15bXlxcKF0rP1tcXG4kXS9nbSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxccythdFxccysvZ20sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL15PYmplY3QuPGFub255bW91cz5cXHMqXFwoL2dtLCAne2Fub255bW91c30oKUAnKSA6ICdVbmtub3duIFN0YWNrIFRyYWNlJztcblxuICAgICAgICB2YXIgbG9nID0gd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLndhcm4gfHwgd2luZG93LmNvbnNvbGUubG9nKTtcbiAgICAgICAgaWYgKGxvZykge1xuICAgICAgICAgICAgbG9nLmNhbGwod2luZG93LmNvbnNvbGUsIGRlcHJlY2F0aW9uTWVzc2FnZSwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBvYmplY3RzX3RvX2Fzc2lnblxuICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gKi9cbnZhciBhc3NpZ247XG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgICBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbn1cblxuLyoqXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbnZhciBleHRlbmQgPSBkZXByZWNhdGUoZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFtZXJnZSB8fCAobWVyZ2UgJiYgZGVzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgZGVzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufSwgJ2V4dGVuZCcsICdVc2UgYGFzc2lnbmAuJyk7XG5cbi8qKlxuICogbWVyZ2UgdGhlIHZhbHVlcyBmcm9tIHNyYyBpbiB0aGUgZGVzdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGRlc3Qgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gYnkgc3JjXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG52YXIgbWVyZ2UgPSBkZXByZWNhdGUoZnVuY3Rpb24gbWVyZ2UoZGVzdCwgc3JjKSB7XG4gICAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xufSwgJ21lcmdlJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gKi9cbmZ1bmN0aW9uIGluaGVyaXQoY2hpbGQsIGJhc2UsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgYmFzZVAgPSBiYXNlLnByb3RvdHlwZSxcbiAgICAgICAgY2hpbGRQO1xuXG4gICAgY2hpbGRQID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUCk7XG4gICAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgY2hpbGRQLl9zdXBlciA9IGJhc2VQO1xuXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgYXNzaWduKGNoaWxkUCwgcHJvcGVydGllcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIHNpbXBsZSBmdW5jdGlvbiBiaW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogbGV0IGEgYm9vbGVhbiB2YWx1ZSBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBtdXN0IHJldHVybiBhIGJvb2xlYW5cbiAqIHRoaXMgZmlyc3QgaXRlbSBpbiBhcmdzIHdpbGwgYmUgdXNlZCBhcyB0aGUgY29udGV4dFxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xuICAgIGlmICh0eXBlb2YgdmFsID09IFRZUEVfRlVOQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIHZhbC5hcHBseShhcmdzID8gYXJnc1swXSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIHVzZSB0aGUgdmFsMiB3aGVuIHZhbDEgaXMgdW5kZWZpbmVkXG4gKiBAcGFyYW0geyp9IHZhbDFcbiAqIEBwYXJhbSB7Kn0gdmFsMlxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGlmVW5kZWZpbmVkKHZhbDEsIHZhbDIpIHtcbiAgICByZXR1cm4gKHZhbDEgPT09IHVuZGVmaW5lZCkgPyB2YWwyIDogdmFsMTtcbn1cblxuLyoqXG4gKiBhZGRFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogcmVtb3ZlRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAqIEBtZXRob2QgaGFzUGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBzbWFsbCBpbmRleE9mIHdyYXBwZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaW5TdHIoc3RyLCBmaW5kKSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XG59XG5cbi8qKlxuICogc3BsaXQgc3RyaW5nIG9uIHdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtBcnJheX0gd29yZHNcbiAqL1xuZnVuY3Rpb24gc3BsaXRTdHIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCkuc3BsaXQoL1xccysvZyk7XG59XG5cbi8qKlxuICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICogQHBhcmFtIHtBcnJheX0gc3JjXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICovXG5mdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XG4gICAgaWYgKHNyYy5pbmRleE9mICYmICFmaW5kQnlLZXkpIHtcbiAgICAgICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoKGZpbmRCeUtleSAmJiBzcmNbaV1bZmluZEJ5S2V5XSA9PSBmaW5kKSB8fCAoIWZpbmRCeUtleSAmJiBzcmNbaV0gPT09IGZpbmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn1cblxuLyoqXG4gKiBjb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byByZWFsIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xufVxuXG4vKipcbiAqIHVuaXF1ZSBhcnJheSB3aXRoIG9iamVjdHMgYmFzZWQgb24gYSBrZXkgKGxpa2UgJ2lkJykgb3IganVzdCBieSB0aGUgYXJyYXkncyB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gc3JjIFt7aWQ6MX0se2lkOjJ9LHtpZDoxfV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICogQHBhcmFtIHtCb29sZWFufSBbc29ydD1GYWxzZV1cbiAqIEByZXR1cm5zIHtBcnJheX0gW3tpZDoxfSx7aWQ6Mn1dXG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZUFycmF5KHNyYywga2V5LCBzb3J0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWwgPSBrZXkgPyBzcmNbaV1ba2V5XSA6IHNyY1tpXTtcbiAgICAgICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHNyY1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2ldID0gdmFsO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKHNvcnQpIHtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoZnVuY3Rpb24gc29ydFVuaXF1ZUFycmF5KGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVtrZXldID4gYltrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuLyoqXG4gKiBnZXQgdGhlIHByZWZpeGVkIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHtTdHJpbmd8VW5kZWZpbmVkfSBwcmVmaXhlZFxuICovXG5mdW5jdGlvbiBwcmVmaXhlZChvYmosIHByb3BlcnR5KSB7XG4gICAgdmFyIHByZWZpeCwgcHJvcDtcbiAgICB2YXIgY2FtZWxQcm9wID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xuICAgICAgICBwcmVmaXggPSBWRU5ET1JfUFJFRklYRVNbaV07XG4gICAgICAgIHByb3AgPSAocHJlZml4KSA/IHByZWZpeCArIGNhbWVsUHJvcCA6IHByb3BlcnR5O1xuXG4gICAgICAgIGlmIChwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIGdldCBhIHVuaXF1ZSBpZFxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlSWRcbiAqL1xudmFyIF91bmlxdWVJZCA9IDE7XG5mdW5jdGlvbiB1bmlxdWVJZCgpIHtcbiAgICByZXR1cm4gX3VuaXF1ZUlkKys7XG59XG5cbi8qKlxuICogZ2V0IHRoZSB3aW5kb3cgb2JqZWN0IG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3dGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG4gICAgcmV0dXJuIChkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cpO1xufVxuXG52YXIgTU9CSUxFX1JFR0VYID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZC9pO1xuXG52YXIgU1VQUE9SVF9UT1VDSCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xudmFyIFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMgPSBwcmVmaXhlZCh3aW5kb3csICdQb2ludGVyRXZlbnQnKSAhPT0gdW5kZWZpbmVkO1xudmFyIFNVUFBPUlRfT05MWV9UT1VDSCA9IFNVUFBPUlRfVE9VQ0ggJiYgTU9CSUxFX1JFR0VYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbnZhciBJTlBVVF9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbnZhciBJTlBVVF9UWVBFX1BFTiA9ICdwZW4nO1xudmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xudmFyIElOUFVUX1RZUEVfS0lORUNUID0gJ2tpbmVjdCc7XG5cbnZhciBDT01QVVRFX0lOVEVSVkFMID0gMjU7XG5cbnZhciBJTlBVVF9TVEFSVCA9IDE7XG52YXIgSU5QVVRfTU9WRSA9IDI7XG52YXIgSU5QVVRfRU5EID0gNDtcbnZhciBJTlBVVF9DQU5DRUwgPSA4O1xuXG52YXIgRElSRUNUSU9OX05PTkUgPSAxO1xudmFyIERJUkVDVElPTl9MRUZUID0gMjtcbnZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xudmFyIERJUkVDVElPTl9VUCA9IDg7XG52YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcblxudmFyIERJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0xFRlQgfCBESVJFQ1RJT05fUklHSFQ7XG52YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XG52YXIgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xuXG52YXIgUFJPUFNfWFkgPSBbJ3gnLCAneSddO1xudmFyIFBST1BTX0NMSUVOVF9YWSA9IFsnY2xpZW50WCcsICdjbGllbnRZJ107XG5cbi8qKlxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBJbnB1dChtYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRUYXJnZXQ7XG5cbiAgICAvLyBzbWFsbGVyIHdyYXBwZXIgYXJvdW5kIHRoZSBoYW5kbGVyLCBmb3IgdGhlIHNjb3BlIGFuZCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbWFuYWdlcixcbiAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXG4gICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKGJvb2xPckZuKG1hbmFnZXIub3B0aW9ucy5lbmFibGUsIFttYW5hZ2VyXSkpIHtcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlcihldik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbn1cblxuSW5wdXQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNob3VsZCBoYW5kbGUgdGhlIGlucHV0RXZlbnQgZGF0YSBhbmQgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgLyoqXG4gICAgICogYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldlRhcmdldCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldldpbiAmJiBhZGRFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVuYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldlRhcmdldCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldldpbiAmJiByZW1vdmVFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICogQHJldHVybnMge0lucHV0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dEluc3RhbmNlKG1hbmFnZXIpIHtcbiAgICB2YXIgVHlwZTtcbiAgICB2YXIgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xuXG4gICAgaWYgKGlucHV0Q2xhc3MpIHtcbiAgICAgICAgVHlwZSA9IGlucHV0Q2xhc3M7XG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX1BPSU5URVJfRVZFTlRTKSB7XG4gICAgICAgIFR5cGUgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfT05MWV9UT1VDSCkge1xuICAgICAgICBUeXBlID0gVG91Y2hJbnB1dDtcbiAgICB9IGVsc2UgaWYgKCFTVVBQT1JUX1RPVUNIKSB7XG4gICAgICAgIFR5cGUgPSBNb3VzZUlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFR5cGUgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgKFR5cGUpKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG59XG5cbi8qKlxuICogaGFuZGxlIGlucHV0IGV2ZW50c1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW4gPSBpbnB1dC5wb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGNoYW5nZWRQb2ludGVyc0xlbiA9IGlucHV0LmNoYW5nZWRQb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGlzRmlyc3QgPSAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG4gICAgdmFyIGlzRmluYWwgPSAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG5cbiAgICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xuICAgIGlucHV0LmlzRmluYWwgPSAhIWlzRmluYWw7XG5cbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICBtYW5hZ2VyLnNlc3Npb24gPSB7fTtcbiAgICB9XG5cbiAgICAvLyBzb3VyY2UgZXZlbnQgaXMgdGhlIG5vcm1hbGl6ZWQgdmFsdWUgb2YgdGhlIGRvbUV2ZW50c1xuICAgIC8vIGxpa2UgJ3RvdWNoc3RhcnQsIG1vdXNldXAsIHBvaW50ZXJkb3duJ1xuICAgIGlucHV0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcblxuICAgIC8vIGNvbXB1dGUgc2NhbGUsIHJvdGF0aW9uIGV0Y1xuICAgIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpO1xuXG4gICAgLy8gZW1pdCBzZWNyZXQgZXZlbnRcbiAgICBtYW5hZ2VyLmVtaXQoJ2hhbW1lci5pbnB1dCcsIGlucHV0KTtcblxuICAgIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcbiAgICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG59XG5cbi8qKlxuICogZXh0ZW5kIHRoZSBkYXRhIHdpdGggc29tZSB1c2FibGUgcHJvcGVydGllcyBsaWtlIHNjYWxlLCByb3RhdGUsIHZlbG9jaXR5IGV0Y1xuICogQHBhcmFtIHtPYmplY3R9IG1hbmFnZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KSB7XG4gICAgdmFyIHNlc3Npb24gPSBtYW5hZ2VyLnNlc3Npb247XG4gICAgdmFyIHBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnM7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgLy8gc3RvcmUgdGhlIGZpcnN0IGlucHV0IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYW5kIGRpcmVjdGlvblxuICAgIGlmICghc2Vzc2lvbi5maXJzdElucHV0KSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9XG5cbiAgICAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID4gMSAmJiAhc2Vzc2lvbi5maXJzdE11bHRpcGxlKSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBmaXJzdElucHV0ID0gc2Vzc2lvbi5maXJzdElucHV0O1xuICAgIHZhciBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xuICAgIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcblxuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXIgPSBnZXRDZW50ZXIocG9pbnRlcnMpO1xuICAgIGlucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgIGlucHV0LmRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGZpcnN0SW5wdXQudGltZVN0YW1wO1xuXG4gICAgaW5wdXQuYW5nbGUgPSBnZXRBbmdsZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG4gICAgaW5wdXQuZGlzdGFuY2UgPSBnZXREaXN0YW5jZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG5cbiAgICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XG4gICAgaW5wdXQub2Zmc2V0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcblxuICAgIHZhciBvdmVyYWxsVmVsb2NpdHkgPSBnZXRWZWxvY2l0eShpbnB1dC5kZWx0YVRpbWUsIGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYID0gb3ZlcmFsbFZlbG9jaXR5Lng7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WSA9IG92ZXJhbGxWZWxvY2l0eS55O1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eSA9IChhYnMob3ZlcmFsbFZlbG9jaXR5LngpID4gYWJzKG92ZXJhbGxWZWxvY2l0eS55KSkgPyBvdmVyYWxsVmVsb2NpdHkueCA6IG92ZXJhbGxWZWxvY2l0eS55O1xuXG4gICAgaW5wdXQuc2NhbGUgPSBmaXJzdE11bHRpcGxlID8gZ2V0U2NhbGUoZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMTtcbiAgICBpbnB1dC5yb3RhdGlvbiA9IGZpcnN0TXVsdGlwbGUgPyBnZXRSb3RhdGlvbihmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAwO1xuXG4gICAgaW5wdXQubWF4UG9pbnRlcnMgPSAhc2Vzc2lvbi5wcmV2SW5wdXQgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiAoKGlucHV0LnBvaW50ZXJzLmxlbmd0aCA+XG4gICAgICAgIHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzKSA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6IHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzKTtcblxuICAgIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCk7XG5cbiAgICAvLyBmaW5kIHRoZSBjb3JyZWN0IHRhcmdldFxuICAgIHZhciB0YXJnZXQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgaWYgKGhhc1BhcmVudChpbnB1dC5zcmNFdmVudC50YXJnZXQsIHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0ID0gaW5wdXQuc3JjRXZlbnQudGFyZ2V0O1xuICAgIH1cbiAgICBpbnB1dC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlcjtcbiAgICB2YXIgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZJbnB1dCA9IHNlc3Npb24ucHJldklucHV0IHx8IHt9O1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfU1RBUlQgfHwgcHJldklucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfRU5EKSB7XG4gICAgICAgIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhID0ge1xuICAgICAgICAgICAgeDogcHJldklucHV0LmRlbHRhWCB8fCAwLFxuICAgICAgICAgICAgeTogcHJldklucHV0LmRlbHRhWSB8fCAwXG4gICAgICAgIH07XG5cbiAgICAgICAgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSA9IHtcbiAgICAgICAgICAgIHg6IGNlbnRlci54LFxuICAgICAgICAgICAgeTogY2VudGVyLnlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpbnB1dC5kZWx0YVggPSBwcmV2RGVsdGEueCArIChjZW50ZXIueCAtIG9mZnNldC54KTtcbiAgICBpbnB1dC5kZWx0YVkgPSBwcmV2RGVsdGEueSArIChjZW50ZXIueSAtIG9mZnNldC55KTtcbn1cblxuLyoqXG4gKiB2ZWxvY2l0eSBpcyBjYWxjdWxhdGVkIGV2ZXJ5IHggbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dCxcbiAgICAgICAgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXAsXG4gICAgICAgIHZlbG9jaXR5LCB2ZWxvY2l0eVgsIHZlbG9jaXR5WSwgZGlyZWN0aW9uO1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB2YXIgZGVsdGFYID0gaW5wdXQuZGVsdGFYIC0gbGFzdC5kZWx0YVg7XG4gICAgICAgIHZhciBkZWx0YVkgPSBpbnB1dC5kZWx0YVkgLSBsYXN0LmRlbHRhWTtcblxuICAgICAgICB2YXIgdiA9IGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICB2ZWxvY2l0eVggPSB2Lng7XG4gICAgICAgIHZlbG9jaXR5WSA9IHYueTtcbiAgICAgICAgdmVsb2NpdHkgPSAoYWJzKHYueCkgPiBhYnModi55KSkgPyB2LnggOiB2Lnk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICAgICAgc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgPSBpbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgICAgIHZlbG9jaXR5ID0gbGFzdC52ZWxvY2l0eTtcbiAgICAgICAgdmVsb2NpdHlYID0gbGFzdC52ZWxvY2l0eVg7XG4gICAgICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgICAgICBkaXJlY3Rpb24gPSBsYXN0LmRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBpbnB1dC52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgIGlucHV0LnZlbG9jaXR5WCA9IHZlbG9jaXR5WDtcbiAgICBpbnB1dC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVk7XG4gICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xufVxuXG4vKipcbiAqIGNyZWF0ZSBhIHNpbXBsZSBjbG9uZSBmcm9tIHRoZSBpbnB1dCB1c2VkIGZvciBzdG9yYWdlIG9mIGZpcnN0SW5wdXQgYW5kIGZpcnN0TXVsdGlwbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICogQHJldHVybnMge09iamVjdH0gY2xvbmVkSW5wdXREYXRhXG4gKi9cbmZ1bmN0aW9uIHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KSB7XG4gICAgLy8gbWFrZSBhIHNpbXBsZSBjb3B5IG9mIHRoZSBwb2ludGVycyBiZWNhdXNlIHdlIHdpbGwgZ2V0IGEgcmVmZXJlbmNlIGlmIHdlIGRvbid0XG4gICAgLy8gd2Ugb25seSBuZWVkIGNsaWVudFhZIGZvciB0aGUgY2FsY3VsYXRpb25zXG4gICAgdmFyIHBvaW50ZXJzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgaW5wdXQucG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHBvaW50ZXJzW2ldID0ge1xuICAgICAgICAgICAgY2xpZW50WDogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WCksXG4gICAgICAgICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgICAgICB9O1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGltZVN0YW1wOiBub3coKSxcbiAgICAgICAgcG9pbnRlcnM6IHBvaW50ZXJzLFxuICAgICAgICBjZW50ZXI6IGdldENlbnRlcihwb2ludGVycyksXG4gICAgICAgIGRlbHRhWDogaW5wdXQuZGVsdGFYLFxuICAgICAgICBkZWx0YVk6IGlucHV0LmRlbHRhWVxuICAgIH07XG59XG5cbi8qKlxuICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gcG9pbnRlcnNcbiAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGB4YCBhbmQgYHlgIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50ZXJzKSB7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxuICAgICAgICAgICAgeTogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IDAsIHkgPSAwLCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHBvaW50ZXJzTGVuZ3RoKSB7XG4gICAgICAgIHggKz0gcG9pbnRlcnNbaV0uY2xpZW50WDtcbiAgICAgICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcm91bmQoeCAvIHBvaW50ZXJzTGVuZ3RoKSxcbiAgICAgICAgeTogcm91bmQoeSAvIHBvaW50ZXJzTGVuZ3RoKVxuICAgIH07XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gKi9cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcbiAgICAgICAgeTogeSAvIGRlbHRhVGltZSB8fCAwXG4gICAgfTtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHgsIHkpIHtcbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICByZXR1cm4gRElSRUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgaWYgKGFicyh4KSA+PSBhYnMoeSkpIHtcbiAgICAgICAgcmV0dXJuIHggPCAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgfVxuICAgIHJldHVybiB5IDwgMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XG4gKiBAcGFyYW0ge09iamVjdH0gcDIge3gsIHl9XG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgfVxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICogQHBhcmFtIHtPYmplY3R9IHAxXG4gKiBAcGFyYW0ge09iamVjdH0gcDJcbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAqL1xuZnVuY3Rpb24gZ2V0QW5nbGUocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICovXG5mdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdLCBQUk9QU19DTElFTlRfWFkpICsgZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAqL1xuZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSwgUFJPUFNfQ0xJRU5UX1hZKSAvIGdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cblxudmFyIE1PVVNFX0lOUFVUX01BUCA9IHtcbiAgICBtb3VzZWRvd246IElOUFVUX1NUQVJULFxuICAgIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcbiAgICBtb3VzZXVwOiBJTlBVVF9FTkRcbn07XG5cbnZhciBNT1VTRV9FTEVNRU5UX0VWRU5UUyA9ICdtb3VzZWRvd24nO1xudmFyIE1PVVNFX1dJTkRPV19FVkVOVFMgPSAnbW91c2Vtb3ZlIG1vdXNldXAnO1xuXG4vKipcbiAqIE1vdXNlIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBNb3VzZUlucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IE1PVVNFX0VMRU1FTlRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBNT1VTRV9XSU5ET1dfRVZFTlRTO1xuXG4gICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7IC8vIG1vdXNlZG93biBzdGF0ZVxuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNRWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgICAgICAvLyBvbiBzdGFydCB3ZSB3YW50IHRvIGhhdmUgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9NT1ZFICYmIGV2LndoaWNoICE9PSAxKSB7XG4gICAgICAgICAgICBldmVudFR5cGUgPSBJTlBVVF9FTkQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICAgICAgaWYgKCF0aGlzLnByZXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIFBPSU5URVJfSU5QVVRfTUFQID0ge1xuICAgIHBvaW50ZXJkb3duOiBJTlBVVF9TVEFSVCxcbiAgICBwb2ludGVybW92ZTogSU5QVVRfTU9WRSxcbiAgICBwb2ludGVydXA6IElOUFVUX0VORCxcbiAgICBwb2ludGVyY2FuY2VsOiBJTlBVVF9DQU5DRUwsXG4gICAgcG9pbnRlcm91dDogSU5QVVRfQ0FOQ0VMXG59O1xuXG4vLyBpbiBJRTEwIHRoZSBwb2ludGVyIHR5cGVzIGlzIGRlZmluZWQgYXMgYW4gZW51bVxudmFyIElFMTBfUE9JTlRFUl9UWVBFX0VOVU0gPSB7XG4gICAgMjogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAzOiBJTlBVVF9UWVBFX1BFTixcbiAgICA0OiBJTlBVVF9UWVBFX01PVVNFLFxuICAgIDU6IElOUFVUX1RZUEVfS0lORUNUIC8vIHNlZSBodHRwczovL3R3aXR0ZXIuY29tL2phY29icm9zc2kvc3RhdHVzLzQ4MDU5NjQzODQ4OTg5MDgxNlxufTtcblxudmFyIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAncG9pbnRlcmRvd24nO1xudmFyIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdwb2ludGVybW92ZSBwb2ludGVydXAgcG9pbnRlcmNhbmNlbCc7XG5cbi8vIElFMTAgaGFzIHByZWZpeGVkIHN1cHBvcnQsIGFuZCBjYXNlLXNlbnNpdGl2ZVxuaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCAmJiAhd2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAnTVNQb2ludGVyRG93bic7XG4gICAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbn1cblxuLyoqXG4gKiBQb2ludGVyIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBQb2ludGVyRXZlbnRJbnB1dCgpIHtcbiAgICB0aGlzLmV2RWwgPSBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBQT0lOVEVSX1dJTkRPV19FVkVOVFM7XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5zdG9yZSA9ICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wb2ludGVyRXZlbnRzID0gW10pO1xufVxuXG5pbmhlcml0KFBvaW50ZXJFdmVudElucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBQRWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmYWxzZTtcblxuICAgICAgICB2YXIgZXZlbnRUeXBlTm9ybWFsaXplZCA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdtcycsICcnKTtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IFBPSU5URVJfSU5QVVRfTUFQW2V2ZW50VHlwZU5vcm1hbGl6ZWRdO1xuICAgICAgICB2YXIgcG9pbnRlclR5cGUgPSBJRTEwX1BPSU5URVJfVFlQRV9FTlVNW2V2LnBvaW50ZXJUeXBlXSB8fCBldi5wb2ludGVyVHlwZTtcblxuICAgICAgICB2YXIgaXNUb3VjaCA9IChwb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNIKTtcblxuICAgICAgICAvLyBnZXQgaW5kZXggb2YgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgICAgICB2YXIgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpO1xuXG4gICAgICAgIC8vIHN0YXJ0IGFuZCBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChldi5idXR0b24gPT09IDAgfHwgaXNUb3VjaCkpIHtcbiAgICAgICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHN0b3JlLnB1c2goZXYpO1xuICAgICAgICAgICAgICAgIHN0b3JlSW5kZXggPSBzdG9yZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICByZW1vdmVQb2ludGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGl0IG5vdCBmb3VuZCwgc28gdGhlIHBvaW50ZXIgaGFzbid0IGJlZW4gZG93biAoc28gaXQncyBwcm9iYWJseSBhIGhvdmVyKVxuICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICAgIHN0b3JlW3N0b3JlSW5kZXhdID0gZXY7XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHN0b3JlLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZnJvbSB0aGUgc3RvcmVcbiAgICAgICAgICAgIHN0b3JlLnNwbGljZShzdG9yZUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgU0lOR0xFX1RPVUNIX0lOUFVUX01BUCA9IHtcbiAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gICAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xuXG52YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG52YXIgU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4vKipcbiAqIFRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBTaW5nbGVUb3VjaElucHV0KCkge1xuICAgIHRoaXMuZXZUYXJnZXQgPSBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFM7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFNpbmdsZVRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgaGFuZGxlcjogZnVuY3Rpb24gVEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciB0eXBlID0gU0lOR0xFX1RPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgICAgICAvLyBzaG91bGQgd2UgaGFuZGxlIHRoZSB0b3VjaCBldmVudHM/XG4gICAgICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG91Y2hlcyA9IG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG5cbiAgICAgICAgLy8gd2hlbiBkb25lLCByZXNldCB0aGUgc3RhcnRlZCBzdGF0ZVxuICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHRvdWNoZXNbMF0ubGVuZ3RoIC0gdG91Y2hlc1sxXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHRoaXMge1RvdWNoSW5wdXR9XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgICB2YXIgYWxsID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgY2hhbmdlZCA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpO1xuXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICBhbGwgPSB1bmlxdWVBcnJheShhbGwuY29uY2F0KGNoYW5nZWQpLCAnaWRlbnRpZmllcicsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBbYWxsLCBjaGFuZ2VkXTtcbn1cblxudmFyIFRPVUNIX0lOUFVUX01BUCA9IHtcbiAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gICAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xuXG52YXIgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbi8qKlxuICogTXVsdGktdXNlciB0b3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gVG91Y2hJbnB1dCgpIHtcbiAgICB0aGlzLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICB0aGlzLnRhcmdldElkcyA9IHt9O1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChUb3VjaElucHV0LCBJbnB1dCwge1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1URWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG4gICAgICAgIHZhciB0b3VjaGVzID0gZ2V0VG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcbiAgICAgICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAqL1xuZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGxUb3VjaGVzID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgdGFyZ2V0SWRzID0gdGhpcy50YXJnZXRJZHM7XG5cbiAgICAvLyB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIHRvdWNoLCB0aGUgcHJvY2VzcyBjYW4gYmUgc2ltcGxpZmllZFxuICAgIGlmICh0eXBlICYgKElOUFVUX1NUQVJUIHwgSU5QVVRfTU9WRSkgJiYgYWxsVG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGFyZ2V0SWRzW2FsbFRvdWNoZXNbMF0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gW2FsbFRvdWNoZXMsIGFsbFRvdWNoZXNdO1xuICAgIH1cblxuICAgIHZhciBpLFxuICAgICAgICB0YXJnZXRUb3VjaGVzLFxuICAgICAgICBjaGFuZ2VkVG91Y2hlcyA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpLFxuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyA9IFtdLFxuICAgICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldDtcblxuICAgIC8vIGdldCB0YXJnZXQgdG91Y2hlcyBmcm9tIHRvdWNoZXNcbiAgICB0YXJnZXRUb3VjaGVzID0gYWxsVG91Y2hlcy5maWx0ZXIoZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XG4gICAgfSk7XG5cbiAgICAvLyBjb2xsZWN0IHRvdWNoZXNcbiAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRhcmdldElkc1t0YXJnZXRUb3VjaGVzW2ldLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbHRlciBjaGFuZ2VkIHRvdWNoZXMgdG8gb25seSBjb250YWluIHRvdWNoZXMgdGhhdCBleGlzdCBpbiB0aGUgY29sbGVjdGVkIHRhcmdldCBpZHNcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICBpZiAodGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5wdXNoKGNoYW5nZWRUb3VjaGVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFudXAgcmVtb3ZlZCB0b3VjaGVzXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIGlmICghY2hhbmdlZFRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgICAvLyBtZXJnZSB0YXJnZXRUb3VjaGVzIHdpdGggY2hhbmdlZFRhcmdldFRvdWNoZXMgc28gaXQgY29udGFpbnMgQUxMIHRvdWNoZXMsIGluY2x1ZGluZyAnZW5kJyBhbmQgJ2NhbmNlbCdcbiAgICAgICAgdW5pcXVlQXJyYXkodGFyZ2V0VG91Y2hlcy5jb25jYXQoY2hhbmdlZFRhcmdldFRvdWNoZXMpLCAnaWRlbnRpZmllcicsIHRydWUpLFxuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlc1xuICAgIF07XG59XG5cbi8qKlxuICogQ29tYmluZWQgdG91Y2ggYW5kIG1vdXNlIGlucHV0XG4gKlxuICogVG91Y2ggaGFzIGEgaGlnaGVyIHByaW9yaXR5IHRoZW4gbW91c2UsIGFuZCB3aGlsZSB0b3VjaGluZyBubyBtb3VzZSBldmVudHMgYXJlIGFsbG93ZWQuXG4gKiBUaGlzIGJlY2F1c2UgdG91Y2ggZGV2aWNlcyBhbHNvIGVtaXQgbW91c2UgZXZlbnRzIHdoaWxlIGRvaW5nIGEgdG91Y2guXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cbnZhciBERURVUF9USU1FT1VUID0gMjUwMDtcbnZhciBERURVUF9ESVNUQU5DRSA9IDI1O1xuXG5mdW5jdGlvbiBUb3VjaE1vdXNlSW5wdXQoKSB7XG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHZhciBoYW5kbGVyID0gYmluZEZuKHRoaXMuaGFuZGxlciwgdGhpcyk7XG4gICAgdGhpcy50b3VjaCA9IG5ldyBUb3VjaElucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG4gICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG5cbiAgICB0aGlzLnByaW1hcnlUb3VjaCA9IG51bGw7XG4gICAgdGhpcy5sYXN0VG91Y2hlcyA9IFtdO1xufVxuXG5pbmhlcml0KFRvdWNoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0RXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gVE1FaGFuZGxlcihtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpLFxuICAgICAgICAgICAgaXNNb3VzZSA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9NT1VTRSk7XG5cbiAgICAgICAgaWYgKGlzTW91c2UgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcyAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdoZW4gd2UncmUgaW4gYSB0b3VjaCBldmVudCwgcmVjb3JkIHRvdWNoZXMgdG8gIGRlLWR1cGUgc3ludGhldGljIG1vdXNlIGV2ZW50XG4gICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICByZWNvcmRUb3VjaGVzLmNhbGwodGhpcywgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdXNlICYmIGlzU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBpbnB1dERhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50b3VjaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubW91c2UuZGVzdHJveSgpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiByZWNvcmRUb3VjaGVzKGV2ZW50VHlwZSwgZXZlbnREYXRhKSB7XG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgICAgIHRoaXMucHJpbWFyeVRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXS5pZGVudGlmaWVyO1xuICAgICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldExhc3RUb3VjaChldmVudERhdGEpIHtcbiAgICB2YXIgdG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdO1xuXG4gICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMucHJpbWFyeVRvdWNoKSB7XG4gICAgICAgIHZhciBsYXN0VG91Y2ggPSB7eDogdG91Y2guY2xpZW50WCwgeTogdG91Y2guY2xpZW50WX07XG4gICAgICAgIHRoaXMubGFzdFRvdWNoZXMucHVzaChsYXN0VG91Y2gpO1xuICAgICAgICB2YXIgbHRzID0gdGhpcy5sYXN0VG91Y2hlcztcbiAgICAgICAgdmFyIHJlbW92ZUxhc3RUb3VjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGkgPSBsdHMuaW5kZXhPZihsYXN0VG91Y2gpO1xuICAgICAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGx0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQocmVtb3ZlTGFzdFRvdWNoLCBERURVUF9USU1FT1VUKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzU3ludGhldGljRXZlbnQoZXZlbnREYXRhKSB7XG4gICAgdmFyIHggPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WCwgeSA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRZO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYXN0VG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdCA9IHRoaXMubGFzdFRvdWNoZXNbaV07XG4gICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0LngpLCBkeSA9IE1hdGguYWJzKHkgLSB0LnkpO1xuICAgICAgICBpZiAoZHggPD0gREVEVVBfRElTVEFOQ0UgJiYgZHkgPD0gREVEVVBfRElTVEFOQ0UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFBSRUZJWEVEX1RPVUNIX0FDVElPTiA9IHByZWZpeGVkKFRFU1RfRUxFTUVOVC5zdHlsZSwgJ3RvdWNoQWN0aW9uJyk7XG52YXIgTkFUSVZFX1RPVUNIX0FDVElPTiA9IFBSRUZJWEVEX1RPVUNIX0FDVElPTiAhPT0gdW5kZWZpbmVkO1xuXG4vLyBtYWdpY2FsIHRvdWNoQWN0aW9uIHZhbHVlXG52YXIgVE9VQ0hfQUNUSU9OX0NPTVBVVEUgPSAnY29tcHV0ZSc7XG52YXIgVE9VQ0hfQUNUSU9OX0FVVE8gPSAnYXV0byc7XG52YXIgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcbnZhciBUT1VDSF9BQ1RJT05fTk9ORSA9ICdub25lJztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1ggPSAncGFuLXgnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWSA9ICdwYW4teSc7XG52YXIgVE9VQ0hfQUNUSU9OX01BUCA9IGdldFRvdWNoQWN0aW9uUHJvcHMoKTtcblxuLyoqXG4gKiBUb3VjaCBBY3Rpb25cbiAqIHNldHMgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IG9yIHVzZXMgdGhlIGpzIGFsdGVybmF0aXZlXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRvdWNoQWN0aW9uKG1hbmFnZXIsIHZhbHVlKSB7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLnNldCh2YWx1ZSk7XG59XG5cblRvdWNoQWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vIGZpbmQgb3V0IHRoZSB0b3VjaC1hY3Rpb24gYnkgdGhlIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIGlmICh2YWx1ZSA9PSBUT1VDSF9BQ1RJT05fQ09NUFVURSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbXB1dGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOQVRJVkVfVE9VQ0hfQUNUSU9OICYmIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlICYmIFRPVUNIX0FDVElPTl9NQVBbdmFsdWVdKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtQUkVGSVhFRF9UT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3Rpb25zID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGp1c3QgcmUtc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZVxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0KHRoaXMubWFuYWdlci5vcHRpb25zLnRvdWNoQWN0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcmVjb2duaXplcidzIHNldHRpbmdzXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBjb21wdXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgZWFjaCh0aGlzLm1hbmFnZXIucmVjb2duaXplcnMsIGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIGlmIChib29sT3JGbihyZWNvZ25pemVyLm9wdGlvbnMuZW5hYmxlLCBbcmVjb2duaXplcl0pKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucy5qb2luKCcgJykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgb24gZWFjaCBpbnB1dCBjeWNsZSBhbmQgcHJvdmlkZXMgdGhlIHByZXZlbnRpbmcgb2YgdGhlIGJyb3dzZXIgYmVoYXZpb3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdHM6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQub2Zmc2V0RGlyZWN0aW9uO1xuXG4gICAgICAgIC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxuICAgICAgICBpZiAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKSB7XG4gICAgICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgICAgIHZhciBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICAgICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWV07XG4gICAgICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1hdO1xuXG4gICAgICAgIGlmIChoYXNOb25lKSB7XG4gICAgICAgICAgICAvL2RvIG5vdCBwcmV2ZW50IGRlZmF1bHRzIGlmIHRoaXMgaXMgYSB0YXAgZ2VzdHVyZVxuXG4gICAgICAgICAgICB2YXIgaXNUYXBQb2ludGVyID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgdmFyIGlzVGFwTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IDI7XG4gICAgICAgICAgICB2YXIgaXNUYXBUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCAyNTA7XG5cbiAgICAgICAgICAgIGlmIChpc1RhcFBvaW50ZXIgJiYgaXNUYXBNb3ZlbWVudCAmJiBpc1RhcFRvdWNoVGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgICAgICAgIC8vIGBwYW4teCBwYW4teWAgbWVhbnMgYnJvd3NlciBoYW5kbGVzIGFsbCBzY3JvbGxpbmcvcGFubmluZywgZG8gbm90IHByZXZlbnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNOb25lIHx8XG4gICAgICAgICAgICAoaGFzUGFuWSAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkgfHxcbiAgICAgICAgICAgIChoYXNQYW5YICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRTcmMoc3JjRXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGwgcHJldmVudERlZmF1bHQgdG8gcHJldmVudCB0aGUgYnJvd3NlcidzIGRlZmF1bHQgYmVoYXZpb3IgKHNjcm9sbGluZyBpbiBtb3N0IGNhc2VzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNFdmVudFxuICAgICAqL1xuICAgIHByZXZlbnRTcmM6IGZ1bmN0aW9uKHNyY0V2ZW50KSB7XG4gICAgICAgIHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiB3aGVuIHRoZSB0b3VjaEFjdGlvbnMgYXJlIGNvbGxlY3RlZCB0aGV5IGFyZSBub3QgYSB2YWxpZCB2YWx1ZSwgc28gd2UgbmVlZCB0byBjbGVhbiB0aGluZ3MgdXAuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucykge1xuICAgIC8vIG5vbmVcbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpO1xuXG4gICAgLy8gaWYgYm90aCBwYW4teCBhbmQgcGFuLXkgYXJlIHNldCAoZGlmZmVyZW50IHJlY29nbml6ZXJzXG4gICAgLy8gZm9yIGRpZmZlcmVudCBkaXJlY3Rpb25zLCBlLmcuIGhvcml6b250YWwgcGFuIGJ1dCB2ZXJ0aWNhbCBzd2lwZT8pXG4gICAgLy8gd2UgbmVlZCBub25lIChhcyBvdGhlcndpc2Ugd2l0aCBwYW4teCBwYW4teSBjb21iaW5lZCBub25lIG9mIHRoZXNlXG4gICAgLy8gcmVjb2duaXplcnMgd2lsbCB3b3JrLCBzaW5jZSB0aGUgYnJvd3NlciB3b3VsZCBoYW5kbGUgYWxsIHBhbm5pbmdcbiAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICAvLyBwYW4teCBPUiBwYW4teVxuICAgIGlmIChoYXNQYW5YIHx8IGhhc1BhblkpIHtcbiAgICAgICAgcmV0dXJuIGhhc1BhblggPyBUT1VDSF9BQ1RJT05fUEFOX1ggOiBUT1VDSF9BQ1RJT05fUEFOX1k7XG4gICAgfVxuXG4gICAgLy8gbWFuaXB1bGF0aW9uXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04pKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OO1xuICAgIH1cblxuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fQVVUTztcbn1cblxuZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpIHtcbiAgICBpZiAoIU5BVElWRV9UT1VDSF9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdG91Y2hNYXAgPSB7fTtcbiAgICB2YXIgY3NzU3VwcG9ydHMgPSB3aW5kb3cuQ1NTICYmIHdpbmRvdy5DU1Muc3VwcG9ydHM7XG4gICAgWydhdXRvJywgJ21hbmlwdWxhdGlvbicsICdwYW4teScsICdwYW4teCcsICdwYW4teCBwYW4teScsICdub25lJ10uZm9yRWFjaChmdW5jdGlvbih2YWwpIHtcblxuICAgICAgICAvLyBJZiBjc3Muc3VwcG9ydHMgaXMgbm90IHN1cHBvcnRlZCBidXQgdGhlcmUgaXMgbmF0aXZlIHRvdWNoLWFjdGlvbiBhc3N1bWUgaXQgc3VwcG9ydHNcbiAgICAgICAgLy8gYWxsIHZhbHVlcy4gVGhpcyBpcyB0aGUgY2FzZSBmb3IgSUUgMTAgYW5kIDExLlxuICAgICAgICB0b3VjaE1hcFt2YWxdID0gY3NzU3VwcG9ydHMgPyB3aW5kb3cuQ1NTLnN1cHBvcnRzKCd0b3VjaC1hY3Rpb24nLCB2YWwpIDogdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG91Y2hNYXA7XG59XG5cbi8qKlxuICogUmVjb2duaXplciBmbG93IGV4cGxhaW5lZDsgKlxuICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxuICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXG4gKiBFeGFtcGxlIHNlc3Npb24gZm9yIG1vdXNlLWlucHV0OiBtb3VzZWRvd24gLT4gbW91c2Vtb3ZlIC0+IG1vdXNldXBcbiAqXG4gKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXG4gKiB3aGljaCBkZXRlcm1pbmVzIHdpdGggc3RhdGUgaXQgc2hvdWxkIGJlLlxuICpcbiAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cbiAqIFBPU1NJQkxFIHRvIGdpdmUgaXQgYW5vdGhlciBjaGFuZ2Ugb24gdGhlIG5leHQgY3ljbGUuXG4gKlxuICogICAgICAgICAgICAgICBQb3NzaWJsZVxuICogICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICstLS0tLSstLS0tLSsgICAgICAgICAgICAgICB8XG4gKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XG4gKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0rLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZGVkL1JlY29nbml6ZWRcbiAqL1xudmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcbnZhciBTVEFURV9CRUdBTiA9IDI7XG52YXIgU1RBVEVfQ0hBTkdFRCA9IDQ7XG52YXIgU1RBVEVfRU5ERUQgPSA4O1xudmFyIFNUQVRFX1JFQ09HTklaRUQgPSBTVEFURV9FTkRFRDtcbnZhciBTVEFURV9DQU5DRUxMRUQgPSAxNjtcbnZhciBTVEFURV9GQUlMRUQgPSAzMjtcblxuLyoqXG4gKiBSZWNvZ25pemVyXG4gKiBFdmVyeSByZWNvZ25pemVyIG5lZWRzIHRvIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLmlkID0gdW5pcXVlSWQoKTtcblxuICAgIHRoaXMubWFuYWdlciA9IG51bGw7XG5cbiAgICAvLyBkZWZhdWx0IGlzIGVuYWJsZSB0cnVlXG4gICAgdGhpcy5vcHRpb25zLmVuYWJsZSA9IGlmVW5kZWZpbmVkKHRoaXMub3B0aW9ucy5lbmFibGUsIHRydWUpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuXG4gICAgdGhpcy5zaW11bHRhbmVvdXMgPSB7fTtcbiAgICB0aGlzLnJlcXVpcmVGYWlsID0gW107XG59XG5cblJlY29nbml6ZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBkZWZhdWx0czoge30sXG5cbiAgICAvKipcbiAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UmVjb2duaXplcn1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gYWxzbyB1cGRhdGUgdGhlIHRvdWNoQWN0aW9uLCBpbiBjYXNlIHNvbWV0aGluZyBjaGFuZ2VkIGFib3V0IHRoZSBkaXJlY3Rpb25zL2VuYWJsZWQgc3RhdGVcbiAgICAgICAgdGhpcy5tYW5hZ2VyICYmIHRoaXMubWFuYWdlci50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2ltdWx0YW5lb3VzID0gdGhpcy5zaW11bHRhbmVvdXM7XG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgaWYgKCFzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSkge1xuICAgICAgICAgICAgc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0gPSBvdGhlclJlY29nbml6ZXI7XG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVjb2duaXplV2l0aCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZHJvcCB0aGUgc2ltdWx0YW5lb3VzIGxpbmsuIGl0IGRvZXNudCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIGRyb3BSZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBkZWxldGUgdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlY29nbml6ZXIgY2FuIG9ubHkgcnVuIHdoZW4gYW4gb3RoZXIgaXMgZmFpbGluZ1xuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXF1aXJlRmFpbCA9IHRoaXMucmVxdWlyZUZhaWw7XG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgaWYgKGluQXJyYXkocmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcikgPT09IC0xKSB7XG4gICAgICAgICAgICByZXF1aXJlRmFpbC5wdXNoKG90aGVyUmVjb2duaXplcik7XG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRyb3AgdGhlIHJlcXVpcmVGYWlsdXJlIGxpbmsuIGl0IGRvZXMgbm90IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheSh0aGlzLnJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlRmFpbC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoYXMgcmVxdWlyZSBmYWlsdXJlcyBib29sZWFuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUmVxdWlyZUZhaWx1cmVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoID4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaWYgdGhlIHJlY29nbml6ZXIgY2FuIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBjYW5SZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWW91IHNob3VsZCB1c2UgYHRyeUVtaXRgIGluc3RlYWQgb2YgYGVtaXRgIGRpcmVjdGx5IHRvIGNoZWNrXG4gICAgICogdGhhdCBhbGwgdGhlIG5lZWRlZCByZWNvZ25pemVycyBoYXMgZmFpbGVkIGJlZm9yZSBlbWl0dGluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoZXZlbnQsIGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICdwYW5zdGFydCcgYW5kICdwYW5tb3ZlJ1xuICAgICAgICBpZiAoc3RhdGUgPCBTVEFURV9FTkRFRCkge1xuICAgICAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQpOyAvLyBzaW1wbGUgJ2V2ZW50TmFtZScgZXZlbnRzXG5cbiAgICAgICAgaWYgKGlucHV0LmFkZGl0aW9uYWxFdmVudCkgeyAvLyBhZGRpdGlvbmFsIGV2ZW50KHBhbmxlZnQsIHBhbnJpZ2h0LCBwaW5jaGluLCBwaW5jaG91dC4uLilcbiAgICAgICAgICAgIGVtaXQoaW5wdXQuYWRkaXRpb25hbEV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhbmVuZCBhbmQgcGFuY2FuY2VsXG4gICAgICAgIGlmIChzdGF0ZSA+PSBTVEFURV9FTkRFRCkge1xuICAgICAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcbiAgICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXG4gICAgICogb3RoZXJ3aXNlLCBzZXR1cCB0aGUgc3RhdGUgdG8gRkFJTEVELlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHRyeUVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLmNhbkVtaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXQncyBmYWlsaW5nIGFueXdheVxuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYW4gd2UgZW1pdD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjYW5FbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLnJlcXVpcmVGYWlsW2ldLnN0YXRlICYgKFNUQVRFX0ZBSUxFRCB8IFNUQVRFX1BPU1NJQkxFKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgcmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xuICAgICAgICAvLyBtYWtlIGEgbmV3IGNvcHkgb2YgdGhlIGlucHV0RGF0YVxuICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBpbnB1dERhdGEgd2l0aG91dCBtZXNzaW5nIHVwIHRoZSBvdGhlciByZWNvZ25pemVyc1xuICAgICAgICB2YXIgaW5wdXREYXRhQ2xvbmUgPSBhc3NpZ24oe30sIGlucHV0RGF0YSk7XG5cbiAgICAgICAgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XG4gICAgICAgIGlmICghYm9vbE9yRm4odGhpcy5vcHRpb25zLmVuYWJsZSwgW3RoaXMsIGlucHV0RGF0YUNsb25lXSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNldCB3aGVuIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9SRUNPR05JWkVEIHwgU1RBVEVfQ0FOQ0VMTEVEIHwgU1RBVEVfRkFJTEVEKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMucHJvY2VzcyhpbnB1dERhdGFDbG9uZSk7XG5cbiAgICAgICAgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXG4gICAgICAgIC8vIHNvIHRyaWdnZXIgYW4gZXZlbnRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQgfCBTVEFURV9DQU5DRUxMRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgc3RhdGUgb2YgdGhlIHJlY29nbml6ZXJcbiAgICAgKiB0aGUgYWN0dWFsIHJlY29nbml6aW5nIGhhcHBlbnMgaW4gdGhpcyBtZXRob2RcbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKiBAcmV0dXJucyB7Q29uc3R9IFNUQVRFXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXREYXRhKSB7IH0sIC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBwcmVmZXJyZWQgdG91Y2gtYWN0aW9uXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbGVkIHdoZW4gdGhlIGdlc3R1cmUgaXNuJ3QgYWxsb3dlZCB0byByZWNvZ25pemVcbiAgICAgKiBsaWtlIHdoZW4gYW5vdGhlciBpcyBiZWluZyByZWNvZ25pemVkIG9yIGl0IGlzIGRpc2FibGVkXG4gICAgICogQHZpcnR1YWxcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7IH1cbn07XG5cbi8qKlxuICogZ2V0IGEgdXNhYmxlIHN0cmluZywgdXNlZCBhcyBldmVudCBwb3N0Zml4XG4gKiBAcGFyYW0ge0NvbnN0fSBzdGF0ZVxuICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbiAqL1xuZnVuY3Rpb24gc3RhdGVTdHIoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgJiBTVEFURV9DQU5DRUxMRUQpIHtcbiAgICAgICAgcmV0dXJuICdjYW5jZWwnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9FTkRFRCkge1xuICAgICAgICByZXR1cm4gJ2VuZCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0NIQU5HRUQpIHtcbiAgICAgICAgcmV0dXJuICdtb3ZlJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQkVHQU4pIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBkaXJlY3Rpb24gY29ucyB0byBzdHJpbmdcbiAqIEBwYXJhbSB7Q29uc3R9IGRpcmVjdGlvblxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZGlyZWN0aW9uU3RyKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV04pIHtcbiAgICAgICAgcmV0dXJuICdkb3duJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fVVApIHtcbiAgICAgICAgcmV0dXJuICd1cCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0xFRlQpIHtcbiAgICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fUklHSFQpIHtcbiAgICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBnZXQgYSByZWNvZ25pemVyIGJ5IG5hbWUgaWYgaXQgaXMgYm91bmQgdG8gYSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSBvdGhlclJlY29nbml6ZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICogQHJldHVybnMge1JlY29nbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XG4gICAgdmFyIG1hbmFnZXIgPSByZWNvZ25pemVyLm1hbmFnZXI7XG4gICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIG1hbmFnZXIuZ2V0KG90aGVyUmVjb2duaXplcik7XG4gICAgfVxuICAgIHJldHVybiBvdGhlclJlY29nbml6ZXI7XG59XG5cbi8qKlxuICogVGhpcyByZWNvZ25pemVyIGlzIGp1c3QgdXNlZCBhcyBhIGJhc2UgZm9yIHRoZSBzaW1wbGUgYXR0cmlidXRlIHJlY29nbml6ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIEF0dHJSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChBdHRyUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRlcnM6IDFcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjaGVjayBpZiBpdCB0aGUgcmVjb2duaXplciByZWNlaXZlcyB2YWxpZCBpbnB1dCwgbGlrZSBpbnB1dC5kaXN0YW5jZSA+IDEwLlxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSByZWNvZ25pemVkXG4gICAgICovXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25Qb2ludGVycyA9IHRoaXMub3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgcmV0dXJuIG9wdGlvblBvaW50ZXJzID09PSAwIHx8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9uUG9pbnRlcnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBpbnB1dC5ldmVudFR5cGU7XG5cbiAgICAgICAgdmFyIGlzUmVjb2duaXplZCA9IHN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCk7XG4gICAgICAgIHZhciBpc1ZhbGlkID0gdGhpcy5hdHRyVGVzdChpbnB1dCk7XG5cbiAgICAgICAgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxuICAgICAgICBpZiAoaXNSZWNvZ25pemVkICYmIChldmVudFR5cGUgJiBJTlBVVF9DQU5DRUwgfHwgIWlzVmFsaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DQU5DRUxMRUQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9FTkRFRDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShzdGF0ZSAmIFNUQVRFX0JFR0FOKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NIQU5HRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQYW5cbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGFuZCBtb3ZlZCBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFBhblJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMucFggPSBudWxsO1xuICAgIHRoaXMucFkgPSBudWxsO1xufVxuXG5pbmhlcml0KFBhblJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQYW5SZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwYW4nLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fQUxMXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfSxcblxuICAgIGRpcmVjdGlvblRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgaGFzTW92ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBpbnB1dC5kaXN0YW5jZTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIHggPSBpbnB1dC5kZWx0YVg7XG4gICAgICAgIHZhciB5ID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgICAgIC8vIGxvY2sgdG8gYXhpcz9cbiAgICAgICAgaWYgKCEoZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh4ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICAgICAgICAgIGhhc01vdmVkID0geCAhPSB0aGlzLnBYO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFYKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHkgPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeSA8IDApID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB5ICE9IHRoaXMucFk7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgcmV0dXJuIGhhc01vdmVkICYmIGRpc3RhbmNlID4gb3B0aW9ucy50aHJlc2hvbGQgJiYgZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb247XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOIHx8ICghKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSkpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuXG4gICAgICAgIHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XG4gICAgICAgIHRoaXMucFkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBpbmNoXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFBpbmNoUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFBpbmNoUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncGluY2gnLFxuICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhpbnB1dC5zY2FsZSAtIDEpID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHZhciBpbk91dCA9IGlucHV0LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JztcbiAgICAgICAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGluT3V0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUHJlc3NcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGZvciB4IG1zIHdpdGhvdXQgYW55IG1vdmVtZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFByZXNzUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xufVxuXG5pbmhlcml0KFByZXNzUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUHJlc3NSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwcmVzcycsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICB0aW1lOiAyNTEsIC8vIG1pbmltYWwgdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBwcmVzc2VkXG4gICAgICAgIHRocmVzaG9sZDogOSAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX0FVVE9dO1xuICAgIH0sXG5cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgICAgdmFyIHZhbGlkVGltZSA9IGlucHV0LmRlbHRhVGltZSA+IG9wdGlvbnMudGltZTtcblxuICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgICAgaWYgKCF2YWxpZE1vdmVtZW50IHx8ICF2YWxpZFBvaW50ZXJzIHx8IChpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnB1dCAmJiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSkge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgJ3VwJywgaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIFJvdGF0ZVxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUm90YXRlUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFJvdGF0ZVJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBSb3RhdGVSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdyb3RhdGUnLFxuICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhpbnB1dC5yb3RhdGlvbikgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfVxufSk7XG5cbi8qKlxuICogU3dpcGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBtb3ZpbmcgZmFzdCAodmVsb2NpdHkpLCB3aXRoIGVub3VnaCBkaXN0YW5jZSBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFN3aXBlUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFN3aXBlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFN3aXBlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAnc3dpcGUnLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgICB2ZWxvY2l0eTogMC4zLFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQYW5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRUb3VjaEFjdGlvbi5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIHZhciB2ZWxvY2l0eTtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgKERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WDtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgZGlyZWN0aW9uICYgaW5wdXQub2Zmc2V0RGlyZWN0aW9uICYmXG4gICAgICAgICAgICBpbnB1dC5kaXN0YW5jZSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgJiZcbiAgICAgICAgICAgIGlucHV0Lm1heFBvaW50ZXJzID09IHRoaXMub3B0aW9ucy5wb2ludGVycyAmJlxuICAgICAgICAgICAgYWJzKHZlbG9jaXR5KSA+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQ7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQub2Zmc2V0RGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBBIHRhcCBpcyBlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb2luZyBhIHNtYWxsIHRhcC9jbGljay4gTXVsdGlwbGUgdGFwcyBhcmUgcmVjb2duaXplZCBpZiB0aGV5IG9jY3VyXG4gKiBiZXR3ZWVuIHRoZSBnaXZlbiBpbnRlcnZhbCBhbmQgcG9zaXRpb24uIFRoZSBkZWxheSBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcmVjb2duaXplIG11bHRpLXRhcHMgd2l0aG91dCBmaXJpbmdcbiAqIGEgc2luZ2xlIHRhcC5cbiAqXG4gKiBUaGUgZXZlbnREYXRhIGZyb20gdGhlIGVtaXR0ZWQgZXZlbnQgY29udGFpbnMgdGhlIHByb3BlcnR5IGB0YXBDb3VudGAsIHdoaWNoIGNvbnRhaW5zIHRoZSBhbW91bnQgb2ZcbiAqIG11bHRpLXRhcHMgYmVpbmcgcmVjb2duaXplZC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBUYXBSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcbiAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcbiAgICB0aGlzLnBUaW1lID0gZmFsc2U7XG4gICAgdGhpcy5wQ2VudGVyID0gZmFsc2U7XG5cbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xuICAgIHRoaXMuY291bnQgPSAwO1xufVxuXG5pbmhlcml0KFRhcFJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAndGFwJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRhcHM6IDEsXG4gICAgICAgIGludGVydmFsOiAzMDAsIC8vIG1heCB0aW1lIGJldHdlZW4gdGhlIG11bHRpLXRhcCB0YXBzXG4gICAgICAgIHRpbWU6IDI1MCwgLy8gbWF4IHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgZG93biAobGlrZSBmaW5nZXIgb24gdGhlIHNjcmVlbilcbiAgICAgICAgdGhyZXNob2xkOiA5LCAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgICAgICBwb3NUaHJlc2hvbGQ6IDEwIC8vIGEgbXVsdGktdGFwIGNhbiBiZSBhIGJpdCBvZmYgdGhlIGluaXRpYWwgcG9zaXRpb25cbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9NQU5JUFVMQVRJT05dO1xuICAgIH0sXG5cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB2YXIgdmFsaWRUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCBvcHRpb25zLnRpbWU7XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAgIGlmICgoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpICYmICh0aGlzLmNvdW50ID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgICAgaWYgKHZhbGlkTW92ZW1lbnQgJiYgdmFsaWRUb3VjaFRpbWUgJiYgdmFsaWRQb2ludGVycykge1xuICAgICAgICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsaWRJbnRlcnZhbCA9IHRoaXMucFRpbWUgPyAoaW5wdXQudGltZVN0YW1wIC0gdGhpcy5wVGltZSA8IG9wdGlvbnMuaW50ZXJ2YWwpIDogdHJ1ZTtcbiAgICAgICAgICAgIHZhciB2YWxpZE11bHRpVGFwID0gIXRoaXMucENlbnRlciB8fCBnZXREaXN0YW5jZSh0aGlzLnBDZW50ZXIsIGlucHV0LmNlbnRlcikgPCBvcHRpb25zLnBvc1RocmVzaG9sZDtcblxuICAgICAgICAgICAgdGhpcy5wVGltZSA9IGlucHV0LnRpbWVTdGFtcDtcbiAgICAgICAgICAgIHRoaXMucENlbnRlciA9IGlucHV0LmNlbnRlcjtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgICAgICAgLy8gaWYgdGFwIGNvdW50IG1hdGNoZXMgd2UgaGF2ZSByZWNvZ25pemVkIGl0LFxuICAgICAgICAgICAgLy8gZWxzZSBpdCBoYXMgYmVnYW4gcmVjb2duaXppbmcuLi5cbiAgICAgICAgICAgIHZhciB0YXBDb3VudCA9IHRoaXMuY291bnQgJSBvcHRpb25zLnRhcHM7XG4gICAgICAgICAgICBpZiAodGFwQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBubyBmYWlsaW5nIHJlcXVpcmVtZW50cywgaW1tZWRpYXRlbHkgdHJpZ2dlciB0aGUgdGFwIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gb3Igd2FpdCBhcyBsb25nIGFzIHRoZSBtdWx0aXRhcCBpbnRlcnZhbCB0byB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1JlcXVpcmVGYWlsdXJlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICBmYWlsVGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50YXBDb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIFNpbXBsZSB3YXkgdG8gY3JlYXRlIGEgbWFuYWdlciB3aXRoIGEgZGVmYXVsdCBzZXQgb2YgcmVjb2duaXplcnMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSGFtbWVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnJlY29nbml6ZXJzID0gaWZVbmRlZmluZWQob3B0aW9ucy5yZWNvZ25pemVycywgSGFtbWVyLmRlZmF1bHRzLnByZXNldCk7XG4gICAgcmV0dXJuIG5ldyBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfVxuICovXG5IYW1tZXIuVkVSU0lPTiA9ICcyLjAuNyc7XG5cbi8qKlxuICogZGVmYXVsdCBzZXR0aW5nc1xuICogQG5hbWVzcGFjZVxuICovXG5IYW1tZXIuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cbiAgICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZG9tRXZlbnRzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5L2ZhbGxiYWNrLlxuICAgICAqIFdoZW4gc2V0IHRvIGBjb21wdXRlYCBpdCB3aWxsIG1hZ2ljYWxseSBzZXQgdGhlIGNvcnJlY3QgdmFsdWUgYmFzZWQgb24gdGhlIGFkZGVkIHJlY29nbml6ZXJzLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgY29tcHV0ZVxuICAgICAqL1xuICAgIHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBlbmFibGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXG4gICAgICogQ2hhbmdlIHRoZSBwYXJlbnQgaW5wdXQgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgaW5wdXRUYXJnZXQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xuICAgICAqIEB0eXBlIHtOdWxsfEZ1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dENsYXNzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gICAgICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgcHJlc2V0OiBbXG4gICAgICAgIC8vIFJlY29nbml6ZXJDbGFzcywgb3B0aW9ucywgW3JlY29nbml6ZVdpdGgsIC4uLl0sIFtyZXF1aXJlRmFpbHVyZSwgLi4uXVxuICAgICAgICBbUm90YXRlUmVjb2duaXplciwge2VuYWJsZTogZmFsc2V9XSxcbiAgICAgICAgW1BpbmNoUmVjb2duaXplciwge2VuYWJsZTogZmFsc2V9LCBbJ3JvdGF0ZSddXSxcbiAgICAgICAgW1N3aXBlUmVjb2duaXplciwge2RpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUx9XSxcbiAgICAgICAgW1BhblJlY29nbml6ZXIsIHtkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMfSwgWydzd2lwZSddXSxcbiAgICAgICAgW1RhcFJlY29nbml6ZXJdLFxuICAgICAgICBbVGFwUmVjb2duaXplciwge2V2ZW50OiAnZG91YmxldGFwJywgdGFwczogMn0sIFsndGFwJ11dLFxuICAgICAgICBbUHJlc3NSZWNvZ25pemVyXVxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxuICAgICAqIEFkZCB0aGVtIHRvIHRoaXMgbWV0aG9kIGFuZCB0aGV5IHdpbGwgYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlci5cbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICovXG4gICAgY3NzUHJvcHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRleHQgc2VsZWN0aW9uIHRvIGltcHJvdmUgdGhlIGRyYWdnaW5nIGdlc3R1cmUuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGUgdGhlIFdpbmRvd3MgUGhvbmUgZ3JpcHBlcnMgd2hlbiBwcmVzc2luZyBhbiBlbGVtZW50LlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRoZSBkZWZhdWx0IGNhbGxvdXQgc2hvd24gd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQuXG4gICAgICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAgICAgKiBhIGNhbGxvdXQgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluay4gVGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIGRpc2FibGUgdGhhdCBjYWxsb3V0LlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoQ2FsbG91dDogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB6b29taW5nIGlzIGVuYWJsZWQuIFVzZWQgYnkgSUUxMD5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdXNlckRyYWc6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcbiAgICAgICAgICogY2xpY2thYmxlIGVsZW1lbnQgaW4gaU9TLiBUaGlzIHByb3BlcnR5IG9iZXlzIHRoZSBhbHBoYSB2YWx1ZSwgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwKSdcbiAgICAgICAgICovXG4gICAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgICB9XG59O1xuXG52YXIgU1RPUCA9IDE7XG52YXIgRk9SQ0VEX1NUT1AgPSAyO1xuXG4vKipcbiAqIE1hbmFnZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIEhhbW1lci5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgPSB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgfHwgZWxlbWVudDtcblxuICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICB0aGlzLnJlY29nbml6ZXJzID0gW107XG4gICAgdGhpcy5vbGRDc3NQcm9wcyA9IHt9O1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XG5cbiAgICB0b2dnbGVDc3NQcm9wcyh0aGlzLCB0cnVlKTtcblxuICAgIGVhY2godGhpcy5vcHRpb25zLnJlY29nbml6ZXJzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciByZWNvZ25pemVyID0gdGhpcy5hZGQobmV3IChpdGVtWzBdKShpdGVtWzFdKSk7XG4gICAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xuICAgICAgICBpdGVtWzNdICYmIHJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUoaXRlbVszXSk7XG4gICAgfSwgdGhpcyk7XG59XG5cbk1hbmFnZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gT3B0aW9ucyB0aGF0IG5lZWQgYSBsaXR0bGUgbW9yZSBzZXR1cFxuICAgICAgICBpZiAob3B0aW9ucy50b3VjaEFjdGlvbikge1xuICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbnB1dFRhcmdldCkge1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJzIGFuZCByZWluaXRpYWxpemVcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dC50YXJnZXQgPSBvcHRpb25zLmlucHV0VGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHN0b3AgcmVjb2duaXppbmcgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICAgKiBUaGlzIHNlc3Npb24gd2lsbCBiZSBkaXNjYXJkZWQsIHdoZW4gYSBuZXcgW2lucHV0XXN0YXJ0IGV2ZW50IGlzIGZpcmVkLlxuICAgICAqIFdoZW4gZm9yY2VkLCB0aGUgcmVjb2duaXplciBjeWNsZSBpcyBzdG9wcGVkIGltbWVkaWF0ZWx5LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlXVxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zdG9wcGVkID0gZm9yY2UgPyBGT1JDRURfU1RPUCA6IFNUT1A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJ1biB0aGUgcmVjb2duaXplcnMhXG4gICAgICogY2FsbGVkIGJ5IHRoZSBpbnB1dEhhbmRsZXIgZnVuY3Rpb24gb24gZXZlcnkgbW92ZW1lbnQgb2YgdGhlIHBvaW50ZXJzICh0b3VjaGVzKVxuICAgICAqIGl0IHdhbGtzIHRocm91Z2ggYWxsIHRoZSByZWNvZ25pemVycyBhbmQgdHJpZXMgdG8gZGV0ZWN0IHRoZSBnZXN0dXJlIHRoYXQgaXMgYmVpbmcgbWFkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcnVuIHRoZSB0b3VjaC1hY3Rpb24gcG9seWZpbGxcbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi5wcmV2ZW50RGVmYXVsdHMoaW5wdXREYXRhKTtcblxuICAgICAgICB2YXIgcmVjb2duaXplcjtcbiAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcblxuICAgICAgICAvLyB0aGlzIGhvbGRzIHRoZSByZWNvZ25pemVyIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgLy8gc28gdGhlIHJlY29nbml6ZXIncyBzdGF0ZSBuZWVkcyB0byBiZSBCRUdBTiwgQ0hBTkdFRCwgRU5ERUQgb3IgUkVDT0dOSVpFRFxuICAgICAgICAvLyBpZiBubyByZWNvZ25pemVyIGlzIGRldGVjdGluZyBhIHRoaW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgXG4gICAgICAgIHZhciBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyO1xuXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gdGhlIGxhc3QgcmVjb2duaXplciBpcyByZWNvZ25pemVkXG4gICAgICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxuICAgICAgICBpZiAoIWN1clJlY29nbml6ZXIgfHwgKGN1clJlY29nbml6ZXIgJiYgY3VyUmVjb2duaXplci5zdGF0ZSAmIFNUQVRFX1JFQ09HTklaRUQpKSB7XG4gICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCByZWNvZ25pemVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlY29nbml6ZXIgPSByZWNvZ25pemVyc1tpXTtcblxuICAgICAgICAgICAgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxuICAgICAgICAgICAgLy8gMS4gICBhbGxvdyBpZiB0aGUgc2Vzc2lvbiBpcyBOT1QgZm9yY2VkIHN0b3BwZWQgKHNlZSB0aGUgLnN0b3AoKSBtZXRob2QpXG4gICAgICAgICAgICAvLyAyLiAgIGFsbG93IGlmIHdlIHN0aWxsIGhhdmVuJ3QgcmVjb2duaXplZCBhIGdlc3R1cmUgaW4gdGhpcyBzZXNzaW9uLCBvciB0aGUgdGhpcyByZWNvZ25pemVyIGlzIHRoZSBvbmVcbiAgICAgICAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAgICAgLy8gMy4gICBhbGxvdyBpZiB0aGUgcmVjb2duaXplciBpcyBhbGxvd2VkIHRvIHJ1biBzaW11bHRhbmVvdXMgd2l0aCB0aGUgY3VycmVudCByZWNvZ25pemVkIHJlY29nbml6ZXIuXG4gICAgICAgICAgICAvLyAgICAgIHRoaXMgY2FuIGJlIHNldHVwIHdpdGggdGhlIGByZWNvZ25pemVXaXRoKClgIG1ldGhvZCBvbiB0aGUgcmVjb2duaXplci5cbiAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmICggLy8gMVxuICAgICAgICAgICAgICAgICAgICAhY3VyUmVjb2duaXplciB8fCByZWNvZ25pemVyID09IGN1clJlY29nbml6ZXIgfHwgLy8gMlxuICAgICAgICAgICAgICAgICAgICByZWNvZ25pemVyLmNhblJlY29nbml6ZVdpdGgoY3VyUmVjb2duaXplcikpKSB7IC8vIDNcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZShpbnB1dERhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSByZWNvZ25pemVyIGhhcyBiZWVuIHJlY29nbml6aW5nIHRoZSBpbnB1dCBhcyBhIHZhbGlkIGdlc3R1cmUsIHdlIHdhbnQgdG8gc3RvcmUgdGhpcyBvbmUgYXMgdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSByZWNvZ25pemVyLiBidXQgb25seSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYW4gYWN0aXZlIHJlY29nbml6ZXJcbiAgICAgICAgICAgIGlmICghY3VyUmVjb2duaXplciAmJiByZWNvZ25pemVyLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEKSkge1xuICAgICAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE51bGx9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChyZWNvZ25pemVyIGluc3RhbmNlb2YgUmVjb2duaXplcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVjb2duaXplcnNbaV0ub3B0aW9ucy5ldmVudCA9PSByZWNvZ25pemVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXJzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSByZWNvZ25pemVyIHRvIHRoZSBtYW5hZ2VyXG4gICAgICogZXhpc3RpbmcgcmVjb2duaXplcnMgd2l0aCB0aGUgc2FtZSBldmVudCBuYW1lIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE1hbmFnZXJ9XG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCAnYWRkJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXG4gICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KHJlY29nbml6ZXIub3B0aW9ucy5ldmVudCk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoZXhpc3RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWNvZ25pemVycy5wdXNoKHJlY29nbml6ZXIpO1xuICAgICAgICByZWNvZ25pemVyLm1hbmFnZXIgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYSByZWNvZ25pemVyIGJ5IG5hbWUgb3IgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCAncmVtb3ZlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpO1xuXG4gICAgICAgIC8vIGxldCdzIG1ha2Ugc3VyZSB0aGlzIHJlY29nbml6ZXIgZXhpc3RzXG4gICAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheShyZWNvZ25pemVycywgcmVjb2duaXplcik7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZWNvZ25pemVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYmluZCBldmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdID0gaGFuZGxlcnNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdLnB1c2goaGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdICYmIGhhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaW5BcnJheShoYW5kbGVyc1tldmVudF0sIGhhbmRsZXIpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIC8vIHdlIGFsc28gd2FudCB0byB0cmlnZ2VyIGRvbSBldmVudHNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kb21FdmVudHMpIHtcbiAgICAgICAgICAgIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBoYW5kbGVycywgc28gc2tpcCBpdCBhbGxcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudF0gJiYgdGhpcy5oYW5kbGVyc1tldmVudF0uc2xpY2UoKTtcbiAgICAgICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnR5cGUgPSBldmVudDtcbiAgICAgICAgZGF0YS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzW2ldKGRhdGEpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRlc3Ryb3kgdGhlIG1hbmFnZXIgYW5kIHVuYmluZHMgYWxsIGV2ZW50c1xuICAgICAqIGl0IGRvZXNuJ3QgdW5iaW5kIGRvbSBldmVudHMsIHRoYXQgaXMgdGhlIHVzZXIgb3duIHJlc3BvbnNpYmlsaXR5XG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCAmJiB0b2dnbGVDc3NQcm9wcyh0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBhZGQvcmVtb3ZlIHRoZSBjc3MgcHJvcGVydGllcyBhcyBkZWZpbmVkIGluIG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wc1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFkZFxuICovXG5mdW5jdGlvbiB0b2dnbGVDc3NQcm9wcyhtYW5hZ2VyLCBhZGQpIHtcbiAgICB2YXIgZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICBpZiAoIWVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcHJvcDtcbiAgICBlYWNoKG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wcywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgcHJvcCA9IHByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIG5hbWUpO1xuICAgICAgICBpZiAoYWRkKSB7XG4gICAgICAgICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdID0gZWxlbWVudC5zdHlsZVtwcm9wXTtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdIHx8ICcnO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFhZGQpIHtcbiAgICAgICAgbWFuYWdlci5vbGRDc3NQcm9wcyA9IHt9O1xuICAgIH1cbn1cblxuLyoqXG4gKiB0cmlnZ2VyIGRvbSBldmVudFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICovXG5mdW5jdGlvbiB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZ2VzdHVyZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZ2VzdHVyZUV2ZW50LmluaXRFdmVudChldmVudCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZ2VzdHVyZUV2ZW50Lmdlc3R1cmUgPSBkYXRhO1xuICAgIGRhdGEudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VzdHVyZUV2ZW50KTtcbn1cblxuYXNzaWduKEhhbW1lciwge1xuICAgIElOUFVUX1NUQVJUOiBJTlBVVF9TVEFSVCxcbiAgICBJTlBVVF9NT1ZFOiBJTlBVVF9NT1ZFLFxuICAgIElOUFVUX0VORDogSU5QVVRfRU5ELFxuICAgIElOUFVUX0NBTkNFTDogSU5QVVRfQ0FOQ0VMLFxuXG4gICAgU1RBVEVfUE9TU0lCTEU6IFNUQVRFX1BPU1NJQkxFLFxuICAgIFNUQVRFX0JFR0FOOiBTVEFURV9CRUdBTixcbiAgICBTVEFURV9DSEFOR0VEOiBTVEFURV9DSEFOR0VELFxuICAgIFNUQVRFX0VOREVEOiBTVEFURV9FTkRFRCxcbiAgICBTVEFURV9SRUNPR05JWkVEOiBTVEFURV9SRUNPR05JWkVELFxuICAgIFNUQVRFX0NBTkNFTExFRDogU1RBVEVfQ0FOQ0VMTEVELFxuICAgIFNUQVRFX0ZBSUxFRDogU1RBVEVfRkFJTEVELFxuXG4gICAgRElSRUNUSU9OX05PTkU6IERJUkVDVElPTl9OT05FLFxuICAgIERJUkVDVElPTl9MRUZUOiBESVJFQ1RJT05fTEVGVCxcbiAgICBESVJFQ1RJT05fUklHSFQ6IERJUkVDVElPTl9SSUdIVCxcbiAgICBESVJFQ1RJT05fVVA6IERJUkVDVElPTl9VUCxcbiAgICBESVJFQ1RJT05fRE9XTjogRElSRUNUSU9OX0RPV04sXG4gICAgRElSRUNUSU9OX0hPUklaT05UQUw6IERJUkVDVElPTl9IT1JJWk9OVEFMLFxuICAgIERJUkVDVElPTl9WRVJUSUNBTDogRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgIERJUkVDVElPTl9BTEw6IERJUkVDVElPTl9BTEwsXG5cbiAgICBNYW5hZ2VyOiBNYW5hZ2VyLFxuICAgIElucHV0OiBJbnB1dCxcbiAgICBUb3VjaEFjdGlvbjogVG91Y2hBY3Rpb24sXG5cbiAgICBUb3VjaElucHV0OiBUb3VjaElucHV0LFxuICAgIE1vdXNlSW5wdXQ6IE1vdXNlSW5wdXQsXG4gICAgUG9pbnRlckV2ZW50SW5wdXQ6IFBvaW50ZXJFdmVudElucHV0LFxuICAgIFRvdWNoTW91c2VJbnB1dDogVG91Y2hNb3VzZUlucHV0LFxuICAgIFNpbmdsZVRvdWNoSW5wdXQ6IFNpbmdsZVRvdWNoSW5wdXQsXG5cbiAgICBSZWNvZ25pemVyOiBSZWNvZ25pemVyLFxuICAgIEF0dHJSZWNvZ25pemVyOiBBdHRyUmVjb2duaXplcixcbiAgICBUYXA6IFRhcFJlY29nbml6ZXIsXG4gICAgUGFuOiBQYW5SZWNvZ25pemVyLFxuICAgIFN3aXBlOiBTd2lwZVJlY29nbml6ZXIsXG4gICAgUGluY2g6IFBpbmNoUmVjb2duaXplcixcbiAgICBSb3RhdGU6IFJvdGF0ZVJlY29nbml6ZXIsXG4gICAgUHJlc3M6IFByZXNzUmVjb2duaXplcixcblxuICAgIG9uOiBhZGRFdmVudExpc3RlbmVycyxcbiAgICBvZmY6IHJlbW92ZUV2ZW50TGlzdGVuZXJzLFxuICAgIGVhY2g6IGVhY2gsXG4gICAgbWVyZ2U6IG1lcmdlLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIGFzc2lnbjogYXNzaWduLFxuICAgIGluaGVyaXQ6IGluaGVyaXQsXG4gICAgYmluZEZuOiBiaW5kRm4sXG4gICAgcHJlZml4ZWQ6IHByZWZpeGVkXG59KTtcblxuLy8gdGhpcyBwcmV2ZW50cyBlcnJvcnMgd2hlbiBIYW1tZXIgaXMgbG9hZGVkIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTURcbi8vICBzdHlsZSBsb2FkZXIgYnV0IGJ5IHNjcmlwdCB0YWcsIG5vdCBieSB0aGUgbG9hZGVyLlxudmFyIGZyZWVHbG9iYWwgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9KSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuZnJlZUdsb2JhbC5IYW1tZXIgPSBIYW1tZXI7XG5cbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBIYW1tZXI7XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhhbW1lcjtcbn0gZWxzZSB7XG4gICAgd2luZG93W2V4cG9ydE5hbWVdID0gSGFtbWVyO1xufVxuXG59KSh3aW5kb3csIGRvY3VtZW50LCAnSGFtbWVyJyk7XG4iLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IHJlZj1cInZpZXdcIiB2LXNob3c9XCJ2aXNpYmxlXCI+XHJcbiAgICAgICAgPFdyYXBWdWUgOm5vVHJhbnNpdGlvbj1cIndyYXBOb1RyYW5zaXRpb25cIiA6b3BhY2l0eT1cIndyYXBPcGFjaXR5XCIgOnNob3dXcmFwPVwic2hvd1dyYXBcIiBAb25DbG9zZVdyYXA9XCJvbkNsb3NlXCI+XHJcbiAgICAgICAgICAgIDxkaXYgQGRyYWdzdGFydD0nJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyByZWY9XCJtZWRpYVJlZlwiIGNsYXNzPVwibWVkaWEtY29udGVudFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbWcgOnN0eWxlPVwiaW5kZXg9PT1pbWFnZUF0dHIuaW5kZXg/aW1hZ2VBdHRyLnN0eWxlOm90aGVySW1nU3R5bGUoaW5kZXgpXCIgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDpjbGFzcz1cIlt7J2ltZy10cmFuc2l0aW9uJzogdHJhbnNpdGlvbi5pbWcuZW5hYmxlfV1cIiA6cmVmPVwiJ2ltZ1JlZnMnK2luZGV4XCIgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDprZXk9XCJpbmRleFwiIHYtZm9yPVwiKGl0ZW0sIGluZGV4KSBpbiBtZWRpYURhdGFzXCIgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDpzcmM9XCJpdGVtXCIgdi1pZj1cImlzQ3JlYXRlZChpbmRleClcIiBAbG9hZD1cImltZ0xvYWRlZChpbmRleCwgJGV2ZW50KVwiLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgOnN0eWxlPVwie29wYWNpdHk6Z2JPcGFjaXR5fVwiIHYtc2hvdz1cImdiT3BhY2l0eVwiIGNsYXNzPVwiZ2FsbGVyeS1iYXJcIj5cclxuICAgICAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgICAgICA8bGkgQGNsaWNrPVwib25DbG9zZVwiPjxpbWcgc3R5bGU9XCJoZWlnaHQ6MS41cmVtO3dpZHRoOjEuNXJlbTtcIiBzcmM9XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQURJQUFBQXlDQVlBQUFBZVA0aXhBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBRVJTVVJCVkdoRDdabEJEb013REFTNWxHdi8ya2YyV1lDTnNoSUhpRUtJTnc3eVNLZ28xTjZkYzZZZ0NJTDNzYTdySjczU2FaWXRpNzdMc3Z6bCthVWpHcHFwMmRvaEhkVUJDZm5kWWNwb1ZvclYzSG9aR1p5UEVvQWhjNVFBcWN1Yy9uS1BzNFdLcFl4WkpsUEdQSXNodzhqWXNReWlTUUNMUUxvRWFCbmNUUUswS05CZEFqd3A0a1lDMUJSeUp3SHVGSE1yQVVvS3VwY0F1YUxEU0lDcndtZTRsUUFsTXU0bFFFNW1HQW5sRlNJNUNlQmVwa1FDdUpXNWt0RHozTGMwN29PU291NWw3aFIwSzFOVHpKM01rMEp1WkZvVTZTN1Rza0EzR1l0Z3VveGxJRTJHRVdTZXdaQUFabGxNQ2RBOFUyYmZjNjBnZytOZjlBQmRvSXVZRWtBem0wZ0FXVFQrWldnUUJJRWpwbWtETGtqVGo2R09vVWtBQUFBQVNVVk9SSzVDWUlJPVwiPjwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpPnt7aW1hZ2VBdHRyLmluZGV4KzF9fS97e21lZGlhRGF0YXMubGVuZ3RofX08L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gPGxpIHJlZj1cInRleHRcIj7kv53lrZg8L2xpPiAtLT5cclxuICAgICAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvV3JhcFZ1ZT5cclxuICAgIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5pbXBvcnQgV3JhcFZ1ZSBmcm9tICcuL1dyYXAudnVlJztcclxuaW1wb3J0IEdhbGxlcnkgZnJvbSBcIi4vR2FsbGVyeVwiO1xyXG5cclxuY29uc3Qgd2luZG93SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xyXG5jb25zdCB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBwcm9wczogWydzaG93JywgJ3RpdGxlJywgJ21lZGlhRGF0YXMnLCAnaW5kZXgnXSxcclxuICAgIGNvbXBvbmVudHM6IHtcclxuICAgICAgICBXcmFwVnVlXHJcbiAgICB9LFxyXG4gICAgbW91bnRlZCgpe1xyXG4gICAgICAgIGxldCBnYWxsZXJ5ID0gbmV3IEdhbGxlcnkodGhpcy4kcmVmcy5tZWRpYVJlZiwgdGhpcy5tZWRpYURhdGFzKTtcclxuICAgICAgICBnYWxsZXJ5LnVwZGF0ZUltYWdlSW5kZXgodGhpcy5pbmRleHx8MCk7XHJcbiAgICAgICAgbGV0IGNlbnRlclZhbCA9IG51bGw7XHJcbiAgICAgICAgZ2FsbGVyeS5vbigncGluY2gnLCBvYmo9PntcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG9iai5yZXN1bHQ7XHJcbiAgICAgICAgICAgIHRoaXMuem9vbShyZXN1bHQuc2NhbGUpO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZSA9IHJlc3VsdC5zbGlkZTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlcigpO1xyXG4gICAgICAgICAgICBpZihyZXN1bHQubGFzdEFjdGlvbkRhdGEgPD0gMSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyYXBPcGFjaXR5ID0gKHJlc3VsdC5zY2FsZS0wLjUpLzAuNTtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JhcE5vVHJhbnNpdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhpcy5kZWJ1ZyhKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBnYWxsZXJ5Lm9uKCdzbGlkZScsIG9iaj0+e1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gb2JqLnJlc3VsdDtcclxuICAgICAgICAgICAgbGV0IHNsaWRlID0gcmVzdWx0LnNsaWRlO1xyXG4gICAgICAgICAgICBsZXQgc2xpZGVYID0gc2xpZGUueDtcclxuICAgICAgICAgICAgbGV0IGN1clNsaWRlWCA9IHRoaXMudHJhbnNsYXRlLng7XHJcbiAgICAgICAgICAgIGxldCBkaWZmID0gc2xpZGVYLWN1clNsaWRlWDtcclxuICAgICAgICAgICAgaWYocmVzdWx0LmJvdW5kLnguaXNPdmVyICYmIG9iai5lLnBvaW50ZXJzLmxlbmd0aCA9PT0gMSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlQXR0ci5uZXh0LnRyYW5zbGF0ZSArPSBkaWZmO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbWFnZUF0dHIucHJldmlvdXMudHJhbnNsYXRlICs9IGRpZmY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50cmFuc2xhdGUgPSBzbGlkZTtcclxuICAgICAgICAgICAgbGV0IGJvdW5kWSA9IHJlc3VsdC5ib3VuZC55O1xyXG4gICAgICAgICAgICBpZihib3VuZFkuaXNPdmVyICYmIHNsaWRlLnkgPiAwKXtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvdWNoQXJlYSA9IHRoaXMuZ2V0VG91Y2hBcmVhU2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cmFwT3BhY2l0eSA9IDEtKE1hdGguYWJzKGJvdW5kWS5udW1iZXIpLygodG91Y2hBcmVhLnh8fHdpbmRvd0hlaWdodCkvMikpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cmFwTm9UcmFuc2l0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyKCk7XHJcbiAgICAgICAgICAgIC8vIHRoaXMuZGVidWcoSlNPTi5zdHJpbmdpZnkocmVzdWx0KSsnXycrb2JqLmUucG9pbnRlcnMubGVuZ3RoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBnYWxsZXJ5Lm9uKCdhY3Rpb25lbmQnLCBvYmo9PntcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG9iai5yZXN1bHQ7XHJcbiAgICAgICAgICAgIGxldCBzd2l0Y2hlZCA9IHRoaXMuaW1hZ2VTd2l0Y2gocmVzdWx0LnN3aXRjaE9iaik7XHJcbiAgICAgICAgICAgIGlmKCFzd2l0Y2hlZCAmJiByZXN1bHQuY29ycmVjdCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlQXR0clJlc2V0KHJlc3VsdC5zY2FsZSwgcmVzdWx0LnNsaWRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLndyYXBOb1RyYW5zaXRpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy53cmFwT3BhY2l0eSA9IDE7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZ2FsbGVyeS5vbignZG91YmxldGFwJywgb2JqPT57XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBvYmoucmVzdWx0O1xyXG4gICAgICAgICAgICB0aGlzLmRvSW1nVHJhbnNpdGlvbigoKT0+e1xyXG4gICAgICAgICAgICAgICAgdGhpcy56b29tKHJlc3VsdC5zY2FsZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZSA9IHJlc3VsdC5zbGlkZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZ2FsbGVyeS5vbignc3dpcGUnLCBvYmo9PntcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG9iai5yZXN1bHQ7XHJcbiAgICAgICAgICAgIGlmKHJlc3VsdC5zd2l0Y2hPYmope1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbWFnZVN3aXRjaChyZXN1bHQuc3dpdGNoT2JqKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgc2xpZGUgPSByZXN1bHQuc2xpZGU7XHJcbiAgICAgICAgICAgIGlmKHNsaWRlKXtcclxuICAgICAgICAgICAgICAgIHNsaWRlID0gc2xpZGUuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZG9JbWdUcmFuc2l0aW9uKCgpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2xhdGUgPSBzbGlkZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyKCk7XHJcbiAgICAgICAgICAgICAgICB9KS50aGVuKCgpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuZ2FsbGVyeS5jb3JyZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0LmNvcnJlY3Qpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvSW1nVHJhbnNpdGlvbigoKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2xhdGUgPSByZXN1bHQuc2xpZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZ2FsbGVyeS5vbignY2xvc2UnLCBvYmo9PntcclxuICAgICAgICAgICAgdGhpcy53cmFwTm9UcmFuc2l0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSgpLnRoZW4oKCk9PntcclxuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VBdHRyUmVzZXQoMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZ2FsbGVyeSA9IGdhbGxlcnk7XHJcbiAgICB9LFxyXG4gICAgZGF0YSgpe1xyXG4gICAgICAgIGxldCBpbWFnZUluZGV4ID0gdGhpcy5pbmRleHx8MDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzaG93V3JhcDogZmFsc2UsXHJcbiAgICAgICAgICAgIHdyYXBOb1RyYW5zaXRpb246IGZhbHNlLFxyXG4gICAgICAgICAgICB3cmFwT3BhY2l0eTogMSxcclxuICAgICAgICAgICAgLy/lhoXpg6jmoIflv5fvvIznlKjkuo7lrp7njrDliqjnlLvmlYjmnpxcclxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGdiT3BhY2l0eTogMCwgXHJcbiAgICAgICAgICAgIHdpbmRvdzogd2luZG93LFxyXG4gICAgICAgICAgICBnYWxsZXJ5OiBudWxsLFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICBpbWc6IHtcclxuICAgICAgICAgICAgICAgICAgICBlbmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVySWQ6IG51bGxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW1hZ2VBdHRyOiB7XHJcbiAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGluZGV4OiBpbWFnZUluZGV4LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXHJcbiAgICAgICAgICAgICAgICBzY2FsZTogMSxcclxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZToge3g6IDAsIHk6MH0sXHJcbiAgICAgICAgICAgICAgICBzaXplczoge30sXHJcbiAgICAgICAgICAgICAgICBuZXh0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlOiB3aW5kb3dXaWR0aCs0MFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlOiAwLXdpbmRvd1dpZHRoLTQwXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb3RoZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGU6IDIqd2luZG93V2lkdGhcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBjcmVhdGVkOiBbXSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiBgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMHB4LCAwcHgpOyB3aWR0aDogMDsgaGVpZ2h0OiAwO2BcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIG9uQ2xvc2UoKXtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNsb3ZlLCByZWplY3QpPT57XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdvbkNsb3NlJyk7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXNsb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICB9LCAzMTApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGltZ0xvYWRlZChpbmRleCwgZXZlbnQpe1xyXG4gICAgICAgICAgICBsZXQgaW1nRWwgPSBldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSBpbWdFbC5uYXR1cmFsSGVpZ2h0O1xyXG4gICAgICAgICAgICBsZXQgd2lkdGggPSBpbWdFbC5uYXR1cmFsV2lkdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvdWNoQXJlYSA9IHRoaXMuZ2V0VG91Y2hBcmVhU2l6ZSgpO1xyXG4gICAgICAgICAgICBsZXQgcmF0aW9YID0gdG91Y2hBcmVhLngvd2lkdGg7XHJcbiAgICAgICAgICAgIGxldCByYXRpb1kgPSB0b3VjaEFyZWEueS9oZWlnaHQ7XHJcbiAgICAgICAgICAgIGxldCByYXRpbyA9IDE7XHJcbiAgICAgICAgICAgIC8vIGlmKChoZWlnaHQgPiBpbm5lckhlaWdodCAmJiB3aW5kb3dXaWR0aCA+IGlubmVySGVpZ2h0KSBcclxuICAgICAgICAgICAgLy8gICAgIHx8IChoZWlnaHQgPCBpbm5lckhlaWdodCAmJiBoZWlnaHQgPiB3aWR0aCAmJiAoaGVpZ2h0LXdpbmRvd1dpZHRoKSA+IHdpZHRoKVxyXG4gICAgICAgICAgICAvLyAgICAgfHwgKGhlaWdodCA+IHdpZHRoICYmIChoZWlnaHQtd2lkdGgpID4gd2lkdGgpKXtcclxuICAgICAgICAgICAgaWYoaGVpZ2h0ID4gd2lkdGggJiYgKGhlaWdodC13aWR0aCkgPiB3aWR0aCl7XHJcbiAgICAgICAgICAgICAgICByYXRpbyA9IHdpZHRoKnJhdGlvWT50b3VjaEFyZWEueD9yYXRpb1g6cmF0aW9ZO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHJhdGlvID0gaGVpZ2h0KnJhdGlvWD50b3VjaEFyZWEueT9yYXRpb1k6cmF0aW9YO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdpZHRoICo9IHJhdGlvO1xyXG4gICAgICAgICAgICBoZWlnaHQgKj0gcmF0aW87XHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VBdHRyLnNpemVzW2luZGV4XSA9IFtNYXRoLnJvdW5kKHdpZHRoKSwgTWF0aC5yb3VuZChoZWlnaHQpXTtcclxuICAgICAgICAgICAgaWYoaW5kZXggPT09IHRoaXMuaW1hZ2VBdHRyLmluZGV4KXtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0ltYWdlKHRydWUsIGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZG9JbWdUcmFuc2l0aW9uKGZ1bmMpe1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc2xvdmUsIHJlamVjdCk9PntcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRyYW5zaXRpb24uaW1nLnRpbWVySWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uLmltZy5lbmFibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYoZnVuYyAmJiBmdW5jIGluc3RhbmNlb2YgRnVuY3Rpb24pe1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbi5pbWcudGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbi5pbWcuZW5hYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzbG92ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSwgMzEwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZWJ1ZyhpbmZvKXtcclxuICAgICAgICAgICAgdGhpcy4kcmVmcy50ZXh0LmlubmVySFRNTCA9IGluZm87XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRJbWdTaXplKGluZGV4LCBhdHRyKXtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW1hZ2VBdHRyLmluZGV4ID09PSBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VBdHRyW2F0dHJdKydweCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHNpemUgPSB0aGlzLmltYWdlQXR0ci5zaXplc1tpbmRleF07XHJcbiAgICAgICAgICAgIGlmKHNpemUpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemVbYXR0cj09PSd3aWR0aCc/MDoxXSsncHgnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW1hZ2VBdHRyUmVzZXQoc2NhbGUsIHNsaWRlKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9JbWdUcmFuc2l0aW9uKCgpPT57XHJcbiAgICAgICAgICAgICAgICB0aGlzLnpvb20oc2NhbGU+PTA/c2NhbGU6MSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZSA9IHNsaWRlfHx7eDowLHk6MH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRJYW1nZVJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmV4dElhbWdlUmVzZXQoKXtcclxuICAgICAgICAgICAgY29uc3QgdG91Y2hBcmVhID0gdGhpcy5nZXRUb3VjaEFyZWFTaXplKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VBdHRyLnByZXZpb3VzLnRyYW5zbGF0ZSA9IDAtdG91Y2hBcmVhLngtNDA7XHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VBdHRyLm5leHQudHJhbnNsYXRlID0gdG91Y2hBcmVhLngrNDA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaG93SW1hZ2UoYm9vbCwgaW5kZXgpe1xyXG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuaW1hZ2VBdHRyLnNpemVzW2luZGV4XTtcclxuICAgICAgICAgICAgaWYoYm9vbCAmJiBzaXplKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VBdHRyLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvSW1nVHJhbnNpdGlvbigoKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlQXR0ci53aWR0aCA9IHNpemVbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VBdHRyLmhlaWdodCA9IHNpemVbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZighYm9vbCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvSW1nVHJhbnNpdGlvbigoKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VBdHRyLndpZHRoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlQXR0ci5oZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIoKTtcclxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKCk9PntcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlQXR0ci5pbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzQ3JlYXRlZChpbmRleCl7XHJcbiAgICAgICAgICAgIGxldCBjcmVhdGVkID0gdGhpcy5pbWFnZUF0dHIuY3JlYXRlZDtcclxuICAgICAgICAgICAgaWYoY3JlYXRlZFtpbmRleF0pe3JldHVybiB0cnVlO31cclxuICAgICAgICAgICAgaWYoaW5kZXg9PT10aGlzLmltYWdlQXR0ci5pbmRleCB8fGluZGV4PT09dGhpcy5pbWFnZUF0dHIuaW5kZXgrMSBcclxuICAgICAgICAgICAgICAgIHx8aW5kZXg9PT10aGlzLmltYWdlQXR0ci5pbmRleCsyIHx8aW5kZXg9PT10aGlzLmltYWdlQXR0ci5pbmRleC0xKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVkW2luZGV4XSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW1hZ2VTd2l0Y2goc3dpdGNoT2JqKXtcclxuICAgICAgICAgICAgaWYoIXN3aXRjaE9iai5zd2l0Y2gpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaE9iai5uZXh0P3RoaXMuaW1hZ2VBdHRyLmluZGV4Kys6dGhpcy5pbWFnZUF0dHIuaW5kZXgtLTtcclxuICAgICAgICAgICAgbGV0IGN1ckltZ1NpemUgPSB0aGlzLmltYWdlQXR0ci5zaXplc1t0aGlzLmltYWdlQXR0ci5pbmRleF07XHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VBdHRyLndpZHRoID0gY3VySW1nU2l6ZVswXTtcclxuICAgICAgICAgICAgdGhpcy5pbWFnZUF0dHIuaGVpZ2h0ID0gY3VySW1nU2l6ZVsxXTtcclxuICAgICAgICAgICAgdGhpcy5nYWxsZXJ5LnVwZGF0ZUltYWdlSW5kZXgodGhpcy5pbWFnZUF0dHIuaW5kZXgpO1xyXG4gICAgICAgICAgICB0aGlzLmltYWdlQXR0clJlc2V0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVuZGVyZXIoKXtcclxuICAgICAgICAgICAgbGV0IHRyYW5zbGF0ZSA9IHRoaXMuaW1hZ2VBdHRyLnRyYW5zbGF0ZTtcclxuICAgICAgICAgICAgbGV0IHdpZHRoID0gdGhpcy5pbWFnZUF0dHIud2lkdGg7XHJcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmltYWdlQXR0ci5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VBdHRyLnN0eWxlID0gYHRyYW5zZm9ybTogdHJhbnNsYXRlKCR7dHJhbnNsYXRlLnh9cHgsICR7dHJhbnNsYXRlLnl9cHgpOyB3aWR0aDogJHt3aWR0aH1weDsgaGVpZ2h0OiAke2hlaWdodH1weDtgO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3RoZXJJbWdTdHlsZShpbmRleCl7XHJcbiAgICAgICAgICAgIGxldCB0cmFuc2xhdGUgPSB0aGlzLmltYWdlQXR0ci5pbmRleCsxPT09aW5kZXg/dGhpcy5pbWFnZUF0dHIubmV4dC50cmFuc2xhdGU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleD50aGlzLmltYWdlQXR0ci5pbmRleD90aGlzLmltYWdlQXR0ci5vdGhlci50cmFuc2xhdGU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlQXR0ci5pbmRleC0xPT09aW5kZXg/dGhpcy5pbWFnZUF0dHIucHJldmlvdXMudHJhbnNsYXRlOm51bGw7XHJcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IHRoaXMuZ2V0SW1nU2l6ZShpbmRleCwgJ3dpZHRoJyk7IFxyXG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5nZXRJbWdTaXplKGluZGV4LCAnaGVpZ2h0Jyk7XHJcbiAgICAgICAgICAgIHJldHVybiBgdHJhbnNmb3JtOiB0cmFuc2xhdGUoJHt0cmFuc2xhdGV9cHgpOyB3aWR0aDogJHt3aWR0aH07IGhlaWdodDogJHtoZWlnaHR9O2A7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB6b29tKHNjYWxlKXtcclxuICAgICAgICAgICAgaWYodGhpcy5pbWFnZUF0dHIuc2NhbGUgPT09IHNjYWxlKXtyZXR1cm47fVxyXG4gICAgICAgICAgICB0aGlzLmltYWdlQXR0ci5zY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgICAgICB0aGlzLmltYWdlQXR0ci53aWR0aCA9IE51bWJlci5wYXJzZUludCh0aGlzLmltYWdlQXR0ci5zaXplc1t0aGlzLmltYWdlQXR0ci5pbmRleF1bMF0qc2NhbGUpO1xyXG4gICAgICAgICAgICB0aGlzLmltYWdlQXR0ci5oZWlnaHQgPSBOdW1iZXIucGFyc2VJbnQodGhpcy5pbWFnZUF0dHIuc2l6ZXNbdGhpcy5pbWFnZUF0dHIuaW5kZXhdWzFdKnNjYWxlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFRvdWNoQXJlYVNpemUoKXtcclxuICAgICAgICAgICAgY29uc3QgdG91Y2hBcmVhWCA9IHRoaXMuJHJlZnMubWVkaWFSZWYuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvdWNoQXJlYVkgPSB0aGlzLiRyZWZzLm1lZGlhUmVmLmNsaWVudEhlaWdodDtcclxuICAgICAgICAgICAgcmV0dXJuIHt4OiB0b3VjaEFyZWFYLCB5OiB0b3VjaEFyZWFZfTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY29tcHV0ZWQ6IHtcclxuICAgICAgICB0cmFuc2xhdGU6IHtcclxuICAgICAgICAgICAgc2V0KG5ld1ZhbCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlQXR0ci50cmFuc2xhdGUueCA9IG5ld1ZhbC54O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbWFnZUF0dHIudHJhbnNsYXRlLnkgPSBuZXdWYWwueTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0KCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbWFnZUF0dHIudHJhbnNsYXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHdhdGNoOiB7XHJcbiAgICAgICAgc2hvdyh2YWwpe1xyXG4gICAgICAgICAgICBpZih2YWwpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiDmraTmrKHnrYnlvoXmmK/kuLrkuobnrYnlvoVkaWFsb2fmmL7npLrlkI7lho3mmL7npLp3cmFwXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1dyYXAgPSB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5YWI562JV3JhcOeahOWKqOeUu+aJp+ihjOWIsOS4gOWNiueahOaXtuWAmeWGjeaYvuekuuWGheWuueWdl1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dJbWFnZSh0cnVlLCB0aGlzLmluZGV4fHwwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYk9wYWNpdHkgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIDE1MCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0SWFtZ2VSZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgfSwgMTUwKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1dyYXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2JPcGFjaXR5ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0ltYWdlKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VBdHRyLmluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIH0sIDMxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOebkeWQrOe8qeaUvuavlOeOh++8jOeEtuWQjuiwg+aVtOWbvueJh+Wkp+Wwj1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgICdpbWFnZUF0dHIuc2NhbGUnOiBmdW5jdGlvbihuZXdWYWwsIG9sZFZhbCkge1xyXG4gICAgICAgICAgICBpZihuZXdWYWwgPT09IG9sZFZhbCB8fCBuZXdWYWwgPD0gMCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pbWFnZUF0dHIud2lkdGggPSBOdW1iZXIucGFyc2VJbnQodGhpcy5pbWFnZUF0dHIuc2l6ZXNbdGhpcy5pbWFnZUF0dHIuaW5kZXhdWzBdKm5ld1ZhbCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VBdHRyLmhlaWdodCA9IE51bWJlci5wYXJzZUludCh0aGlzLmltYWdlQXR0ci5zaXplc1t0aGlzLmltYWdlQXR0ci5pbmRleF1bMV0qbmV3VmFsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1lZGlhRGF0YXMoZGF0YXMpe1xyXG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gZGF0YXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLmltYWdlQXR0ci5sZW5ndGggPSBsZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VBdHRyLmNyZWF0ZWQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICAgICAgICAgICAgdGhpcy5nYWxsZXJ5LnNldEltYWdlc051bWJlcihsZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic2Nzc1wiIHNjb3BlZD5cclxuICAgIC5tZWRpYS1jb250ZW50IHtcclxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgICAgICAgZmxleC13cmFwOiBub3dyYXA7XHJcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuICAgICAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICAgICAgd2lkdGg6IDEwMCU7XHJcbiAgICAgICAgbWFyZ2luOiBhdXRvO1xyXG4gICAgICAgIGltZyB7XHJcbiAgICAgICAgICAgIGhlaWdodDogMCU7XHJcbiAgICAgICAgICAgIHdpZHRoOiAwJTtcclxuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICAgICAgJi53aWR0aC1yYXRpbyB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGF1dG87XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAmLmhlaWdodC1yYXRpbyB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogYXV0bztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAmLmltZy10cmFuc2l0aW9uIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IHdpZHRoIDAuM3MsIGhlaWdodCAwLjNzLCB0cmFuc2Zvcm0gMC4zcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC5nYWxsZXJ5LWJhciB7XHJcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzO1xyXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcclxuICAgICAgICBib3R0b206IDA7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjUpO1xyXG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcclxuICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICBmb250LXNpemU6IDEuM3JlbTtcclxuICAgICAgICBwYWRkaW5nLWJvdHRvbTogY29uc3RhbnQoc2FmZS1hcmVhLWluc2V0LWJvdHRvbSk7XHJcbiAgICAgICAgcGFkZGluZy1ib3R0b206IGVudihzYWZlLWFyZWEtaW5zZXQtYm90dG9tKTtcclxuICAgICAgICB1bCBsaSB7XHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDFyZW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG48L3N0eWxlPlxyXG48c3R5bGU+XHJcbiAgICAud3JhcCAuY29udGFpbmVyIHtcclxuICAgICAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICB9XHJcbjwvc3R5bGU+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXYgY2xhc3M9XCJ3cmFwXCI+XHJcbiAgICAgICAgPGRpdiA6Y2xhc3M9XCJbJ2NvdmVyJywgeyd0cmFuc2l0aW9uJzogIW5vVHJhbnNpdGlvbn1dXCIgOnN0eWxlPVwieydiYWNrZ3JvdW5kLWNvbG9yJzogYmFja2dyb3VuZENvbG9yfVwiIEBjbGljaz1cImNsb3NlXCI+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiA6Y2xhc3M9XCJbJ2NvbnRhaW5lcicsIHBvc2l0aW9uP3Bvc2l0aW9uOidjZW50ZXInXVwiPlxyXG4gICAgICAgICAgICA8c2xvdD48L3Nsb3Q+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGNyZWF0ZWQoKXtcclxuICAgIH0sXHJcbiAgICBwcm9wczogWydzaG93V3JhcCcsICdwb3NpdGlvbicsICdvcGFjaXR5JywgJ25vVHJhbnNpdGlvbiddLFxyXG4gICAgZGF0YSgpe1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRCa0NvbG9ySGlkZSA9ICdyZ2JhKDAsIDAsIDAsIDApJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGRlZmF1bHRCa0NvbG9ySGlkZSwgXHJcbiAgICAgICAgICAgIGRlZmF1bHRCa0NvbG9yU2hvdzogYHJnYmEoMCwgMCwgMCwgJHt0aGlzLm9wYWNpdHk/dGhpcy5vcGFjaXR5OjAuNX0pYCwgXHJcbiAgICAgICAgICAgIGRlZmF1bHRCa0NvbG9ySGlkZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgY2xvc2UoKXtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIOWwhuWFs+mXreeahOaOp+WItuadg+S6pOeUseW8leeUqOiAhVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy4kZW1pdCgnb25DbG9zZVdyYXAnKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgd2F0Y2g6IHtcclxuICAgICAgICBzaG93V3JhcCh2YWwpe1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICog6K+l5pa55rOV55So5LqO5pi+56S6d3JhcOWSjOmakOiXj3dyYXDnmoTliqjnlLvmk43kvZxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmKHZhbCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZGVmYXVsdEJrQ29sb3JTaG93O1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gdGhpcy5kZWZhdWx0QmtDb2xvckhpZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9wYWNpdHkodmFsKXtcclxuICAgICAgICAgICAgaWYodGhpcy5zaG93V3JhcCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IGByZ2JhKDAsIDAsIDAsICR7dmFsP3ZhbDowLjV9KWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbjxzdHlsZSBsYW5nPVwic2Nzc1wiIHNjb3BlZD5cclxuICAgIC53cmFwIHtcclxuICAgICAgICAuY292ZXIge1xyXG4gICAgICAgICAgICB6LWluZGV4OiAxMDA7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcclxuICAgICAgICAgICAgdG9wOiAwO1xyXG4gICAgICAgICAgICBsZWZ0OiAwO1xyXG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xyXG4gICAgICAgICAgICAmLnRyYW5zaXRpb24ge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjNzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC5jb250YWluZXIge1xyXG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xyXG4gICAgICAgICAgICB6LWluZGV4OiAxMDE7XHJcbiAgICAgICAgICAgIHRvcDogMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbjwvc3R5bGU+IiwiPHRlbXBsYXRlPlxyXG4gICAgPGRpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwidG9wXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsb2dcIj5cclxuICAgICAgICAgICAgICAgIEFQb3B1cHMtR2FsbGVyeVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPHA+Q3VycmVudCB2ZXJzaW9uOiAxLjAuMCBiZXRhPC9wPlxyXG4gICAgICAgICAgICA8IS0tIDxkaXYgY2xhc3M9XCJtZW51XCI+XHJcbiAgICAgICAgICAgICAgICA8YT5Eb2M8L2E+IHwgPGE+R2l0aHViPC9hPiB8IDxhPkZlZWRiYWNrPC9hPlxyXG4gICAgICAgICAgICA8L2Rpdj4gLS0+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImltYWdlLWxpc3RcIj5cclxuICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiQC9pbWdzL3RodW1ibmFpbC0xLmpwZ1wiIEBjbGljaz1cInNob3dHYWxsZXJ5KDApXCI+XHJcbiAgICAgICAgICAgICAgICA8cD50YXAgdGhpcyBwaWN0dXJlPC9wPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGdhbGxlcnkgOm1lZGlhRGF0YXM9J2dhbGxlcnlEYXRhcycgOmluZGV4PVwiMFwiIDpzaG93PVwiaXNTaG93XCIgQG9uQ2xvc2U9XCJpc1Nob3c9ZmFsc2VcIj48L2dhbGxlcnk+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImRvY1wiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwid2FybmluZ1wiPlxyXG4gICAgICAgICAgICAgICAgPGgyPkJlZm9yZSBzdGFydGluZzwvaDI+XHJcbiAgICAgICAgICAgICAgICBCZWZvcmUgdXNpbmcsIHlvdSBuZWVkIHRvIGtub3cgYWJvdXQgPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWQ7XCI+dnVlanM8L3NwYW4+IGFuZCA8c3BhbiBzdHlsZT1cImNvbG9yOnJlZDtcIj52dWUncyBzaW5nbGUtZmlsZSBjb21wb25lbnQ8L3NwYW4+IGRldmVsb3BtZW50XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZ2V0dGluZy1zdGFydGVkXCI+XHJcbiAgICAgICAgICAgICAgICA8aDI+R2V0dGluZyBzdGFydGVkPC9oMj5cclxuICAgICAgICAgICAgICAgIDxoND5TdGVwMTogaW5zdGFsbCBieSBucG08L2g0PlxyXG4gICAgICAgICAgICAgICAgPHA+XHJcbiAgICAgICAgICAgICAgICAgICAgPHByZT48Y29kZT5ucG0gaW5zdGFsbCBwb3B1cHMtZ2FsbGVyeS12dWU8L2NvZGU+PC9wcmU+XHJcbiAgICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgICAgICA8aDQ+U3RlcDI6IGltcG9ydCBnYWxsZXJ5IHZ1ZSBjb21wb25lbnQ8L2g0PlxyXG4gICAgICAgICAgICAgICAgPHA+XHJcbiAgICAgICAgICAgICAgICAgICAgPHByZT48Y29kZT5pbXBvcnQgZ2FsbGVyeSBmcm9tIFwicG9wdXBzLWdhbGxlcnlcIjs8YnIvPjwvY29kZT48L3ByZT5cclxuICAgICAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgICAgICAgIDxoND5TdGVwMzogQWRkIHRvIHZ1ZWpzIGNvbXBvbmVudHM8L2g0PlxyXG4gICAgICAgICAgICAgICAgPHA+XHJcbiAgICAgICAgICAgICAgICAgICAgPHByZT48Y29kZT5jb21wb25lbnRzOiB7IGdhbGxlcnkgfTxici8+PC9jb2RlPjwvcHJlPlxyXG4gICAgICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgICAgICAgPGg0PlN0ZXA0OiB1c2VpbmcgZ2FsbGVyeSBjb21wb25lbnQgb24geW91ciB2dWUgcGFnZTwvaDQ+XHJcbiAgICAgICAgICAgICAgICA8cD5cclxuICAgICAgICAgICAgICAgICAgICA8cHJlPjxjb2RlPiYjNjA7Z2FsbGVyeSA6aW1hZ2VEYXRhcz1cImltYWdlRGF0YXNcIiA6aW5kZXg9XCIwXCIgOnNob3c9XCJpc1Nob3dcIiBAb25DbG9zZT1cImlzU2hvdz1mYWxzZVwiPiYjNjA7L2dhbGxlcnk+PC9jb2RlPjwvcHJlPlxyXG4gICAgICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgICAgICAgPGg0PlBhcmFtZXRlcjo8L2g0PlxyXG4gICAgICAgICAgICAgICAgPHRhYmxlPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoPk5hbWU8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+VHlwZTwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5SZXF1aXJlZDwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5pbWFnZURhdGFzPC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5hcnJheTwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+dHJ1ZTwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+VGhlIGltYWdlcyB5b3Ugd2FudCB0byBzaG93PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPmluZGV4PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5udW1iZXI8L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPmZhbHNlPC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5UaGUgaW5kZXggb2YgdGhlIGltYWdlcyBzaG93biBzdGFydHMgYXQgMC4gPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWQ7XCI+ZGVmdWFsdDogMDwvc3Bhbj48L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+c2hvdzwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+Ym9vbGVhbjwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+dHJ1ZTwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+RGlzcGxheSBhbmQgY2xvc2UgZmxhZ3M8L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+b25DbG9zZTwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+ZnVuY3Rpb248L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPnRydWU8L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPllvdSBtdXN0IGNoYW5nZSB0aGUgc2hvdyB2YWx1ZSB0byBmYWxzZSBpbnNpZGUgdGhlIGZ1bmN0aW9uPC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImJvb3RvbVwiPlxyXG4gICAgICAgICAgICBMaWNlbnNlOiBNSVQgPGEgc3R5bGU9XCJtYXJnaW4tbGVmdDogMnJlbTtcIj5HaXRodWI8L2E+IDxhIGhyZWY9XCJtYWlsdG86ODAxOTg5M0BxcS5jb21cIiBzdHlsZT1cIm1hcmdpbi1sZWZ0OiAycmVtO1wiPjgwMTk4OTNAcXEuY29tPC9hPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBnYWxsZXJ5IGZyb20gXCJhcG9wdXBzLWdhbGxlcnlcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIG5hbWU6IFwiQXBwXCIsXHJcbiAgICBjb21wb25lbnRzOiB7XHJcbiAgICAgICAgZ2FsbGVyeVxyXG4gICAgfSxcclxuICAgIGRhdGEgKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGltYWdlRGF0YTogW1tcclxuICAgICAgICAgICAgICAgIHJlcXVpcmUoYEAvaW1ncy9hbmltYWwtMy5qcGdgKSxcclxuICAgICAgICAgICAgICAgIHJlcXVpcmUoYEAvaW1ncy9hbmltYWwtMS5qcGdgKSxcclxuICAgICAgICAgICAgICAgIHJlcXVpcmUoYEAvaW1ncy9hbmltYWwtMi5qcGdgKSxcclxuICAgICAgICAgICAgICAgIHJlcXVpcmUoYEAvaW1ncy9wZXJzb24tMi5qcGdgKSxcclxuICAgICAgICAgICAgICAgIHJlcXVpcmUoYEAvaW1ncy9wZXJzb24tMS5qcGdgKSxcclxuICAgICAgICAgICAgICAgIHJlcXVpcmUoYEAvaW1ncy8xLmpwZ2ApLFxyXG4gICAgICAgICAgICAgICAgcmVxdWlyZShgQC9pbWdzLzIuanBnYCksXHJcbiAgICAgICAgICAgICAgICByZXF1aXJlKGBAL2ltZ3MvMy5qcGdgKSxcclxuICAgICAgICAgICAgICAgIHJlcXVpcmUoYEAvaW1ncy80LmpwZ2ApXHJcbiAgICAgICAgICAgIF0sW1xyXG4gICAgICAgICAgICBdXSxcclxuICAgICAgICAgICAgZ2FsbGVyeURhdGFzOiBbXSxcclxuICAgICAgICAgICAgaXNTaG93OiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgc2hvd0dhbGxlcnkoaW5kZXgpe1xyXG4gICAgICAgICAgICB0aGlzLmdhbGxlcnlEYXRhcyA9IHRoaXMuaW1hZ2VEYXRhW2luZGV4XTtcclxuICAgICAgICAgICAgdGhpcy5pc1Nob3cgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cclxuICAgIEBpbXBvcnQgJ2NvbW1vbi5zY3NzJztcclxuICAgIC50b3Age1xyXG4gICAgICAgIHdpZHRoOiA4NSU7XHJcbiAgICAgICAgbWFyZ2luOjJyZW0gYXV0bztcclxuICAgICAgICAubG9nIHtcclxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMnJlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcCB7XHJcbiAgICAgICAgICAgIGNvbG9yOiByZ2IoMjIxLCA2MCwgNjApO1xyXG4gICAgICAgICAgICBwYWRkaW5nOiAxcmVtIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLmNvbnRlbnQge1xyXG4gICAgICAgIG1hcmdpbi10b3A6IDFyZW07XHJcbiAgICAgICAgLmltYWdlLWxpc3R7XHJcbiAgICAgICAgICAgIG1hcmdpbjogYXV0bztcclxuICAgICAgICAgICAgYm9yZGVyLWJvdHRvbTogMC4xcmVtIHNvbGlkICNjNWM1YzUwYTtcclxuICAgICAgICAgICAgbWFyZ2luLXRvcDogMnJlbTtcclxuICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgICAgICAgICAuaW1hZ2UtZGl2IHtcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogMXJlbSAwO1xyXG4gICAgICAgICAgICAgICAgbWF4LWhlaWdodDogMjByZW07XHJcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgICAgICAgICAgICAgaW1nIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC5kb2Mge1xyXG4gICAgICAgIG1heC13aWR0aDogMTIwMHB4O1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xyXG4gICAgICAgIHBhZGRpbmc6IDFyZW0gMXJlbTtcclxuICAgICAgICBtYXJnaW46IGF1dG87XHJcbiAgICAgICAgcHJlIHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIyOCwgMjI4LCAyMjgpO1xyXG4gICAgICAgICAgICBvdmVyZmxvdzogYXV0bztcclxuICAgICAgICAgICAgcGFkZGluZzogMXJlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGFibGUge1xyXG4gICAgICAgICAgICB0ZCB7XHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwLjVyZW0gMXJlbTtcclxuICAgICAgICAgICAgICAgICY6bnRoLW9mLXR5cGUoMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLmJvb3RvbSB7XHJcbiAgICAgICAgcGFkZGluZzogMnJlbTtcclxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICB9XHJcbjwvc3R5bGU+IiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5tZWRpYS1jb250ZW50W2RhdGEtdi03YzAzMjRkOV0ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGZsZXgtd3JhcDogbm93cmFwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWFyZ2luOiBhdXRvO1xcbn1cXG4ubWVkaWEtY29udGVudCBpbWdbZGF0YS12LTdjMDMyNGQ5XSB7XFxuICAgIGhlaWdodDogMCU7XFxuICAgIHdpZHRoOiAwJTtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuLm1lZGlhLWNvbnRlbnQgaW1nLndpZHRoLXJhdGlvW2RhdGEtdi03YzAzMjRkOV0ge1xcbiAgICAgIGhlaWdodDogYXV0bztcXG4gICAgICB3aWR0aDogMTAwJTtcXG59XFxuLm1lZGlhLWNvbnRlbnQgaW1nLmhlaWdodC1yYXRpb1tkYXRhLXYtN2MwMzI0ZDldIHtcXG4gICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgICAgd2lkdGg6IGF1dG87XFxufVxcbi5tZWRpYS1jb250ZW50IGltZy5pbWctdHJhbnNpdGlvbltkYXRhLXYtN2MwMzI0ZDldIHtcXG4gICAgICB0cmFuc2l0aW9uOiB3aWR0aCAwLjNzLCBoZWlnaHQgMC4zcywgdHJhbnNmb3JtIDAuM3M7XFxufVxcbi5nYWxsZXJ5LWJhcltkYXRhLXYtN2MwMzI0ZDldIHtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIGJvdHRvbTogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC41KTtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgZm9udC1zaXplOiAxLjNyZW07XFxuICBwYWRkaW5nLWJvdHRvbTogY29uc3RhbnQoc2FmZS1hcmVhLWluc2V0LWJvdHRvbSk7XFxuICBwYWRkaW5nLWJvdHRvbTogZW52KHNhZmUtYXJlYS1pbnNldC1ib3R0b20pO1xcbn1cXG4uZ2FsbGVyeS1iYXIgdWwgbGlbZGF0YS12LTdjMDMyNGQ5XSB7XFxuICAgIHBhZGRpbmc6IDFyZW07XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4ud3JhcCAuY292ZXJbZGF0YS12LTY1OTcwZjVhXSB7XFxuICB6LWluZGV4OiAxMDA7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxufVxcbi53cmFwIC5jb3Zlci50cmFuc2l0aW9uW2RhdGEtdi02NTk3MGY1YV0ge1xcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuM3M7XFxufVxcbi53cmFwIC5jb250YWluZXJbZGF0YS12LTY1OTcwZjVhXSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHotaW5kZXg6IDEwMTtcXG4gIHRvcDogMDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5odG1sLCBib2R5IHtcXG4gIGZvbnQtc2l6ZTogMTNweDtcXG4gIG1hcmdpbjogMCAwO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBsaW5lLWhlaWdodDogMS42cmVtO1xcbiAgdGV4dC1zaXplLWFkanVzdDogMTAwJTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlYWVhZWE7XFxufVxcbnVsLCBvbCB7XFxuICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICBmbGV4LXdyYXA6IG5vd3JhcDtcXG59XFxudWwsIG9sLCBwIHtcXG4gIHBhZGRpbmc6IDA7XFxuICBtYXJnaW46IDA7XFxufVxcbmE6dmlzaXRlZCwgYSB7XFxuICBjb2xvcjogIzAwOWZmZjtcXG59XFxuYSB7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxufVxcbmlucHV0W3R5cGU9YnV0dG9uXSwgaW5wdXRbdHlwZT1zdWJtaXRdLCBpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPXBhc3N3b3JkXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICBvdXRsaW5lOiBub25lO1xcbn1cXG5AbWVkaWEgc2NyZWVuIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSkge1xcbmh0bWwsIGJvZHkge1xcbiAgICBwYWRkaW5nLXRvcDogY29uc3RhbnQoc2FmZS1hcmVhLWluc2V0LXRvcCk7XFxuICAgIHBhZGRpbmctdG9wOiBlbnYoc2FmZS1hcmVhLWluc2V0LXRvcCk7XFxuICAgIHBhZGRpbmctbGVmdDogY29uc3RhbnQoc2FmZS1hcmVhLWluc2V0LWxlZnQpO1xcbiAgICBwYWRkaW5nLWxlZnQ6IGVudihzYWZlLWFyZWEtaW5zZXQtbGVmdCk7XFxuICAgIHBhZGRpbmctcmlnaHQ6IGNvbnN0YW50KHNhZmUtYXJlYS1pbnNldC1yaWdodCk7XFxuICAgIHBhZGRpbmctcmlnaHQ6IGVudihzYWZlLWFyZWEtaW5zZXQtcmlnaHQpO1xcbn1cXG59XFxuLnRvcCB7XFxuICB3aWR0aDogODUlO1xcbiAgbWFyZ2luOiAycmVtIGF1dG87XFxufVxcbi50b3AgLmxvZyB7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBmb250LXNpemU6IDJyZW07XFxufVxcbi50b3AgcCB7XFxuICAgIGNvbG9yOiAjZGQzYzNjO1xcbiAgICBwYWRkaW5nOiAxcmVtIDA7XFxufVxcbi5jb250ZW50IHtcXG4gIG1hcmdpbi10b3A6IDFyZW07XFxufVxcbi5jb250ZW50IC5pbWFnZS1saXN0IHtcXG4gICAgbWFyZ2luOiBhdXRvO1xcbiAgICBib3JkZXItYm90dG9tOiAwLjFyZW0gc29saWQgI2M1YzVjNTBhO1xcbiAgICBtYXJnaW4tdG9wOiAycmVtO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcbi5jb250ZW50IC5pbWFnZS1saXN0IC5pbWFnZS1kaXYge1xcbiAgICAgIG1hcmdpbjogMXJlbSAwO1xcbiAgICAgIG1heC1oZWlnaHQ6IDIwcmVtO1xcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxufVxcbi5jb250ZW50IC5pbWFnZS1saXN0IC5pbWFnZS1kaXYgaW1nIHtcXG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgd2lkdGg6IDEwMCU7XFxufVxcbi5kb2Mge1xcbiAgbWF4LXdpZHRoOiAxMjAwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gIHBhZGRpbmc6IDFyZW0gMXJlbTtcXG4gIG1hcmdpbjogYXV0bztcXG59XFxuLmRvYyBwcmUge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTRlNGU0O1xcbiAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgcGFkZGluZzogMXJlbTtcXG59XFxuLmRvYyB0YWJsZSB0ZCB7XFxuICAgIHBhZGRpbmc6IDAuNXJlbSAxcmVtO1xcbn1cXG4uZG9jIHRhYmxlIHRkOm50aC1vZi10eXBlKDEpIHtcXG4gICAgICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuLmJvb3RvbSB7XFxuICBwYWRkaW5nOiAycmVtO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLndyYXAgLmNvbnRhaW5lciB7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiIsInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwic2hvd1wiLFxuICAgICAgICAgIHJhd05hbWU6IFwidi1zaG93XCIsXG4gICAgICAgICAgdmFsdWU6IF92bS52aXNpYmxlLFxuICAgICAgICAgIGV4cHJlc3Npb246IFwidmlzaWJsZVwiXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICByZWY6IFwidmlld1wiXG4gICAgfSxcbiAgICBbXG4gICAgICBfYyhcbiAgICAgICAgXCJXcmFwVnVlXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgbm9UcmFuc2l0aW9uOiBfdm0ud3JhcE5vVHJhbnNpdGlvbixcbiAgICAgICAgICAgIG9wYWNpdHk6IF92bS53cmFwT3BhY2l0eSxcbiAgICAgICAgICAgIHNob3dXcmFwOiBfdm0uc2hvd1dyYXBcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uOiB7IG9uQ2xvc2VXcmFwOiBfdm0ub25DbG9zZSB9XG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJlZjogXCJtZWRpYVJlZlwiLFxuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZWRpYS1jb250ZW50XCIsXG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgZHJhZ3N0YXJ0OiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3ZtLl9sKF92bS5tZWRpYURhdGFzLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3ZtLmlzQ3JlYXRlZChpbmRleClcbiAgICAgICAgICAgICAgICA/IF9jKFwiaW1nXCIsIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBcImltZ1JlZnNcIiArIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICByZWZJbkZvcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFt7IFwiaW1nLXRyYW5zaXRpb25cIjogX3ZtLnRyYW5zaXRpb24uaW1nLmVuYWJsZSB9XSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6XG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXggPT09IF92bS5pbWFnZUF0dHIuaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gX3ZtLmltYWdlQXR0ci5zdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBfdm0ub3RoZXJJbWdTdHlsZShpbmRleCksXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHNyYzogaXRlbSB9LFxuICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgIGxvYWQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLmltZ0xvYWRlZChpbmRleCwgJGV2ZW50KVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcInNob3dcIixcbiAgICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1zaG93XCIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLmdiT3BhY2l0eSxcbiAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiZ2JPcGFjaXR5XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImdhbGxlcnktYmFyXCIsXG4gICAgICAgICAgICAgIHN0eWxlOiB7IG9wYWNpdHk6IF92bS5nYk9wYWNpdHkgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXCJ1bFwiLCBbXG4gICAgICAgICAgICAgICAgX2MoXCJsaVwiLCB7IG9uOiB7IGNsaWNrOiBfdm0ub25DbG9zZSB9IH0sIFtcbiAgICAgICAgICAgICAgICAgIF9jKFwiaW1nXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgaGVpZ2h0OiBcIjEuNXJlbVwiLCB3aWR0aDogXCIxLjVyZW1cIiB9LFxuICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgIHNyYzpcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFESUFBQUF5Q0FZQUFBQWVQNGl4QUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUVSU1VSQlZHaEQ3WmxCRG9Nd0RBUzVsR3YvMmtmMldZQ05zaElIaUVLSU53N3lTS2dvMU42ZGM2WWdDSUwzc2E3cko3M1NhWll0aTc3THN2emwrYVVqR3BxcDJkb2hIZFVCQ2ZuZFljcG9Wb3JWM0hvWkdaeVBFb0FoYzVRQXFjdWMvbktQczRXS3BZeFpKbFBHUElzaHc4allzUXlpU1FDTFFMb0VhQm5jVFFLMEtOQmRBandwNGtZQzFCUnlKd0h1RkhNckFVb0t1cGNBdWFMRFNJQ3J3bWU0bFFBbE11NGxRRTVtR0FubEZTSTVDZUJlcGtRQ3VKVzVrdER6M0xjMDdvT1NvdTVsN2hSMEsxTlR6SjNNazBKdVpGb1U2UzdUc2tBM0dZdGd1b3hsSUUyR0VXU2V3WkFBWmxsTUNkQThVMmJmYzYwZ2crTmY5QUJkb0l1WUVrQXptMGdBV1RUK1pXZ1FCSUVqcG1rRExralRqNkdPb1VrQUFBQUFTVVZPUks1Q1lJST1cIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgX2MoXCJsaVwiLCBbXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICAgIF92bS5fcyhfdm0uaW1hZ2VBdHRyLmluZGV4ICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiL1wiICtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3MoX3ZtLm1lZGlhRGF0YXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKVxuICAgICAgICBdXG4gICAgICApXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwid3JhcFwiIH0sIFtcbiAgICBfYyhcImRpdlwiLCB7XG4gICAgICBjbGFzczogW1wiY292ZXJcIiwgeyB0cmFuc2l0aW9uOiAhX3ZtLm5vVHJhbnNpdGlvbiB9XSxcbiAgICAgIHN0eWxlOiB7IFwiYmFja2dyb3VuZC1jb2xvclwiOiBfdm0uYmFja2dyb3VuZENvbG9yIH0sXG4gICAgICBvbjogeyBjbGljazogX3ZtLmNsb3NlIH1cbiAgICB9KSxcbiAgICBfdm0uX3YoXCIgXCIpLFxuICAgIF9jKFxuICAgICAgXCJkaXZcIixcbiAgICAgIHsgY2xhc3M6IFtcImNvbnRhaW5lclwiLCBfdm0ucG9zaXRpb24gPyBfdm0ucG9zaXRpb24gOiBcImNlbnRlclwiXSB9LFxuICAgICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgICAgMlxuICAgIClcbiAgXSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIFtcbiAgICBfdm0uX20oMCksXG4gICAgX3ZtLl92KFwiIFwiKSxcbiAgICBfYyhcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7IHN0YXRpY0NsYXNzOiBcImNvbnRlbnRcIiB9LFxuICAgICAgW1xuICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImltYWdlLWxpc3RcIiB9LCBbXG4gICAgICAgICAgX2MoXCJpbWdcIiwge1xuICAgICAgICAgICAgYXR0cnM6IHsgc3JjOiByZXF1aXJlKFwiQC9pbWdzL3RodW1ibmFpbC0xLmpwZ1wiKSB9LFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgIF92bS5zaG93R2FsbGVyeSgwKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcInBcIiwgW192bS5fdihcInRhcCB0aGlzIHBpY3R1cmVcIildKVxuICAgICAgICBdKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJnYWxsZXJ5XCIsIHtcbiAgICAgICAgICBhdHRyczogeyBtZWRpYURhdGFzOiBfdm0uZ2FsbGVyeURhdGFzLCBpbmRleDogMCwgc2hvdzogX3ZtLmlzU2hvdyB9LFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBvbkNsb3NlOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgX3ZtLmlzU2hvdyA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgXSxcbiAgICAgIDFcbiAgICApLFxuICAgIF92bS5fdihcIiBcIiksXG4gICAgX3ZtLl9tKDEpLFxuICAgIF92bS5fdihcIiBcIiksXG4gICAgX3ZtLl9tKDIpXG4gIF0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW1xuICBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInRvcFwiIH0sIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibG9nXCIgfSwgW1xuICAgICAgICBfdm0uX3YoXCJcXG4gICAgICAgICAgICBBUG9wdXBzLUdhbGxlcnlcXG4gICAgICAgIFwiKVxuICAgICAgXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJwXCIsIFtfdm0uX3YoXCJDdXJyZW50IHZlcnNpb246IDEuMC4wIGJldGFcIildKVxuICAgIF0pXG4gIH0sXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZG9jXCIgfSwgW1xuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJ3YXJuaW5nXCIgfSwgW1xuICAgICAgICBfYyhcImgyXCIsIFtfdm0uX3YoXCJCZWZvcmUgc3RhcnRpbmdcIildKSxcbiAgICAgICAgX3ZtLl92KFwiXFxuICAgICAgICAgICAgQmVmb3JlIHVzaW5nLCB5b3UgbmVlZCB0byBrbm93IGFib3V0IFwiKSxcbiAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljU3R5bGU6IHsgY29sb3I6IFwicmVkXCIgfSB9LCBbX3ZtLl92KFwidnVlanNcIildKSxcbiAgICAgICAgX3ZtLl92KFwiIGFuZCBcIiksXG4gICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY1N0eWxlOiB7IGNvbG9yOiBcInJlZFwiIH0gfSwgW1xuICAgICAgICAgIF92bS5fdihcInZ1ZSdzIHNpbmdsZS1maWxlIGNvbXBvbmVudFwiKVxuICAgICAgICBdKSxcbiAgICAgICAgX3ZtLl92KFwiIGRldmVsb3BtZW50XFxuICAgICAgICBcIilcbiAgICAgIF0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZ2V0dGluZy1zdGFydGVkXCIgfSwgW1xuICAgICAgICBfYyhcImgyXCIsIFtfdm0uX3YoXCJHZXR0aW5nIHN0YXJ0ZWRcIildKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJoNFwiLCBbX3ZtLl92KFwiU3RlcDE6IGluc3RhbGwgYnkgbnBtXCIpXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwicFwiLCBbXG4gICAgICAgICAgX2MoXCJwcmVcIiwgW19jKFwiY29kZVwiLCBbX3ZtLl92KFwibnBtIGluc3RhbGwgcG9wdXBzLWdhbGxlcnktdnVlXCIpXSldKVxuICAgICAgICBdKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJoNFwiLCBbX3ZtLl92KFwiU3RlcDI6IGltcG9ydCBnYWxsZXJ5IHZ1ZSBjb21wb25lbnRcIildKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJwXCIsIFtcbiAgICAgICAgICBfYyhcInByZVwiLCBbXG4gICAgICAgICAgICBfYyhcImNvZGVcIiwgW1xuICAgICAgICAgICAgICBfdm0uX3YoJ2ltcG9ydCBnYWxsZXJ5IGZyb20gXCJwb3B1cHMtZ2FsbGVyeVwiOycpLFxuICAgICAgICAgICAgICBfYyhcImJyXCIpXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcImg0XCIsIFtfdm0uX3YoXCJTdGVwMzogQWRkIHRvIHZ1ZWpzIGNvbXBvbmVudHNcIildKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJwXCIsIFtcbiAgICAgICAgICBfYyhcInByZVwiLCBbX2MoXCJjb2RlXCIsIFtfdm0uX3YoXCJjb21wb25lbnRzOiB7IGdhbGxlcnkgfVwiKSwgX2MoXCJiclwiKV0pXSlcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiaDRcIiwgW192bS5fdihcIlN0ZXA0OiB1c2VpbmcgZ2FsbGVyeSBjb21wb25lbnQgb24geW91ciB2dWUgcGFnZVwiKV0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcInBcIiwgW1xuICAgICAgICAgIF9jKFwicHJlXCIsIFtcbiAgICAgICAgICAgIF9jKFwiY29kZVwiLCBbXG4gICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAnPGdhbGxlcnkgOmltYWdlRGF0YXM9XCJpbWFnZURhdGFzXCIgOmluZGV4PVwiMFwiIDpzaG93PVwiaXNTaG93XCIgQG9uQ2xvc2U9XCJpc1Nob3c9ZmFsc2VcIj48L2dhbGxlcnk+J1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcImg0XCIsIFtfdm0uX3YoXCJQYXJhbWV0ZXI6XCIpXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwidGFibGVcIiwgW1xuICAgICAgICAgIF9jKFwidGhlYWRcIiwgW1xuICAgICAgICAgICAgX2MoXCJ0aFwiLCBbX3ZtLl92KFwiTmFtZVwiKV0pLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFwidGhcIiwgW192bS5fdihcIlR5cGVcIildKSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBfYyhcInRoXCIsIFtfdm0uX3YoXCJSZXF1aXJlZFwiKV0pLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFwidGhcIiwgW192bS5fdihcIkRlc2NyaXB0aW9uXCIpXSlcbiAgICAgICAgICBdKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwidGJvZHlcIiwgW1xuICAgICAgICAgICAgX2MoXCJ0clwiLCBbXG4gICAgICAgICAgICAgIF9jKFwidGRcIiwgW192bS5fdihcImltYWdlRGF0YXNcIildKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX2MoXCJ0ZFwiLCBbX3ZtLl92KFwiYXJyYXlcIildKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX2MoXCJ0ZFwiLCBbX3ZtLl92KFwidHJ1ZVwiKV0pLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfYyhcInRkXCIsIFtfdm0uX3YoXCJUaGUgaW1hZ2VzIHlvdSB3YW50IHRvIHNob3dcIildKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX2MoXCJ0clwiLCBbXG4gICAgICAgICAgICAgIF9jKFwidGRcIiwgW192bS5fdihcImluZGV4XCIpXSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwidGRcIiwgW192bS5fdihcIm51bWJlclwiKV0pLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfYyhcInRkXCIsIFtfdm0uX3YoXCJmYWxzZVwiKV0pLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfYyhcInRkXCIsIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoXCJUaGUgaW5kZXggb2YgdGhlIGltYWdlcyBzaG93biBzdGFydHMgYXQgMC4gXCIpLFxuICAgICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY1N0eWxlOiB7IGNvbG9yOiBcInJlZFwiIH0gfSwgW1xuICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiZGVmdWFsdDogMFwiKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBfYyhcInRyXCIsIFtcbiAgICAgICAgICAgICAgX2MoXCJ0ZFwiLCBbX3ZtLl92KFwic2hvd1wiKV0pLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfYyhcInRkXCIsIFtfdm0uX3YoXCJib29sZWFuXCIpXSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwidGRcIiwgW192bS5fdihcInRydWVcIildKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX2MoXCJ0ZFwiLCBbX3ZtLl92KFwiRGlzcGxheSBhbmQgY2xvc2UgZmxhZ3NcIildKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX2MoXCJ0clwiLCBbXG4gICAgICAgICAgICAgIF9jKFwidGRcIiwgW192bS5fdihcIm9uQ2xvc2VcIildKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX2MoXCJ0ZFwiLCBbX3ZtLl92KFwiZnVuY3Rpb25cIildKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX2MoXCJ0ZFwiLCBbX3ZtLl92KFwidHJ1ZVwiKV0pLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfYyhcInRkXCIsIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICBcIllvdSBtdXN0IGNoYW5nZSB0aGUgc2hvdyB2YWx1ZSB0byBmYWxzZSBpbnNpZGUgdGhlIGZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgIF0pXG4gIH0sXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiYm9vdG9tXCIgfSwgW1xuICAgICAgX3ZtLl92KFwiXFxuICAgICAgICBMaWNlbnNlOiBNSVQgXCIpLFxuICAgICAgX2MoXCJhXCIsIHsgc3RhdGljU3R5bGU6IHsgXCJtYXJnaW4tbGVmdFwiOiBcIjJyZW1cIiB9IH0sIFtfdm0uX3YoXCJHaXRodWJcIildKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJhXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdGF0aWNTdHlsZTogeyBcIm1hcmdpbi1sZWZ0XCI6IFwiMnJlbVwiIH0sXG4gICAgICAgICAgYXR0cnM6IHsgaHJlZjogXCJtYWlsdG86ODAxOTg5M0BxcS5jb21cIiB9XG4gICAgICAgIH0sXG4gICAgICAgIFtfdm0uX3YoXCI4MDE5ODkzQHFxLmNvbVwiKV1cbiAgICAgIClcbiAgICBdKVxuICB9XG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyLCAvKiBzZXJ2ZXIgb25seSAqL1xuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHsgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgdGhpcy4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290KSB9XG4gICAgICA6IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG4iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuLi92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTMtMiEuLi92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vR2FsbGVyeS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD03YzAzMjRkOSZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSByZXF1aXJlKFwiIS4uL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiNTc0MWIxMWRcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0zLTIhLi4vdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0dhbGxlcnkudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9N2MwMzI0ZDkmbGFuZz1zY3NzJnNjb3BlZD10cnVlJlwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4uL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMy0yIS4uL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9HYWxsZXJ5LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTdjMDMyNGQ5Jmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSZcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4uL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMy0yIS4uL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9XcmFwLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTY1OTcwZjVhJmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSZcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IHJlcXVpcmUoXCIhLi4vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCIyZGI3NGQ0Y1wiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuLi92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTMtMiEuLi92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vV3JhcC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD02NTk3MGY1YSZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0zLTIhLi4vdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1dyYXAudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NjU5NzBmNWEmbGFuZz1zY3NzJnNjb3BlZD10cnVlJlwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0zLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9pbmRleC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPXNjc3MmXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcIjVhYTQ1MGEwXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMy0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1zY3NzJlwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMy0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1zY3NzJlwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0dhbGxlcnkudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTEmbGFuZz1jc3MmXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSByZXF1aXJlKFwiIS4uL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiMDEyYzFhZWNcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0dhbGxlcnkudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTEmbGFuZz1jc3MmXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0dhbGxlcnkudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTEmbGFuZz1jc3MmXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iLCIvKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4gIE1vZGlmaWVkIGJ5IEV2YW4gWW91IEB5eXg5OTA4MDNcbiovXG5cbmltcG9ydCBsaXN0VG9TdHlsZXMgZnJvbSAnLi9saXN0VG9TdHlsZXMnXG5cbnZhciBoYXNEb2N1bWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuaWYgKHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAndnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiAnICtcbiAgICBcIlVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCJcbiAgKSB9XG59XG5cbi8qXG50eXBlIFN0eWxlT2JqZWN0ID0ge1xuICBpZDogbnVtYmVyO1xuICBwYXJ0czogQXJyYXk8U3R5bGVPYmplY3RQYXJ0PlxufVxuXG50eXBlIFN0eWxlT2JqZWN0UGFydCA9IHtcbiAgY3NzOiBzdHJpbmc7XG4gIG1lZGlhOiBzdHJpbmc7XG4gIHNvdXJjZU1hcDogP3N0cmluZ1xufVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0gey8qXG4gIFtpZDogbnVtYmVyXToge1xuICAgIGlkOiBudW1iZXIsXG4gICAgcmVmczogbnVtYmVyLFxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxuICB9XG4qL31cblxudmFyIGhlYWQgPSBoYXNEb2N1bWVudCAmJiAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdKVxudmFyIHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcbnZhciBpc1Byb2R1Y3Rpb24gPSBmYWxzZVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxudmFyIG9wdGlvbnMgPSBudWxsXG52YXIgc3NySWRLZXkgPSAnZGF0YS12dWUtc3NyLWlkJ1xuXG4vLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbi8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbnZhciBpc09sZElFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhZGRTdHlsZXNDbGllbnQgKHBhcmVudElkLCBsaXN0LCBfaXNQcm9kdWN0aW9uLCBfb3B0aW9ucykge1xuICBpc1Byb2R1Y3Rpb24gPSBfaXNQcm9kdWN0aW9uXG5cbiAgb3B0aW9ucyA9IF9vcHRpb25zIHx8IHt9XG5cbiAgdmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdClcbiAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgICBkb21TdHlsZS5yZWZzLS1cbiAgICAgIG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKVxuICAgIH1cbiAgICBpZiAobmV3TGlzdCkge1xuICAgICAgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBuZXdMaXN0KVxuICAgICAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMgPSBbXVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldXG4gICAgICBpZiAoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZG9tU3R5bGUucGFydHNbal0oKVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcyAvKiBBcnJheTxTdHlsZU9iamVjdD4gKi8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKytcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSlcbiAgICAgIH1cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgaWYgKGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA+IGl0ZW0ucGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA9IGl0ZW0ucGFydHMubGVuZ3RoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIHN0eWxlc0luRG9tW2l0ZW0uaWRdID0geyBpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50ICgpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgc3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KVxuICByZXR1cm4gc3R5bGVFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gIHZhciB1cGRhdGUsIHJlbW92ZVxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbJyArIHNzcklkS2V5ICsgJ349XCInICsgb2JqLmlkICsgJ1wiXScpXG5cbiAgaWYgKHN0eWxlRWxlbWVudCkge1xuICAgIGlmIChpc1Byb2R1Y3Rpb24pIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGFuZCBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gICAgICAvLyBzaW1wbHkgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBub29wXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGJ1dCBpbiBkZXYgbW9kZS5cbiAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBDaHJvbWUgY2FuJ3QgaGFuZGxlIHNvdXJjZSBtYXAgaW4gc2VydmVyLXJlbmRlcmVkXG4gICAgICAvLyBzdHlsZSB0YWdzIC0gc291cmNlIG1hcHMgaW4gPHN0eWxlPiBvbmx5IHdvcmtzIGlmIHRoZSBzdHlsZSB0YWcgaXNcbiAgICAgIC8vIGNyZWF0ZWQgYW5kIGluc2VydGVkIGR5bmFtaWNhbGx5LiBTbyB3ZSByZW1vdmUgdGhlIHNlcnZlciByZW5kZXJlZFxuICAgICAgLy8gc3R5bGVzIGFuZCBpbmplY3QgbmV3IG9uZXMuXG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgaWYgKGlzT2xkSUUpIHtcbiAgICAvLyB1c2Ugc2luZ2xldG9uIG1vZGUgZm9yIElFOS5cbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrK1xuICAgIHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKSlcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSlcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBtdWx0aS1zdHlsZS10YWcgbW9kZSBpbiBhbGwgb3RoZXIgY2FzZXNcbiAgICBzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZShvYmopXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcbiAgICAgICAgICBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuICAgICAgICAgIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKVxuICAgIH1cbiAgfVxufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgdGV4dFN0b3JlID0gW11cblxuICByZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudFxuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpXG4gIH1cbn0pKClcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLmNzc1xuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKVxuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKVxuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXNcbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSlcbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZUVsZW1lbnQsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzc1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWFcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXBcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKVxuICB9XG4gIGlmIChvcHRpb25zLnNzcklkKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShzc3JJZEtleSwgb2JqLmlkKVxuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZGV2dG9vbHMvZG9jcy9qYXZhc2NyaXB0LWRlYnVnZ2luZ1xuICAgIC8vIHRoaXMgbWFrZXMgc291cmNlIG1hcHMgaW5zaWRlIHN0eWxlIHRhZ3Mgd29yayBwcm9wZXJseSBpbiBDaHJvbWVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VVUkw9JyArIHNvdXJjZU1hcC5zb3VyY2VzWzBdICsgJyAqLydcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArICcgKi8nXG4gIH1cblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpXG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKVxuICB9XG59XG4iLCIvKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuIiwiLyohXG4gKiBWdWUuanMgdjIuNS4xN1xuICogKGMpIDIwMTQtMjAxOCBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8vIHRoZXNlIGhlbHBlcnMgcHJvZHVjZXMgYmV0dGVyIHZtIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmdcbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlIGUuZy4gW29iamVjdCBPYmplY3RdXG4gKi9cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdC4uLiBlLmcuXG4gKiBQaGFudG9tSlMgMS54LiBUZWNobmljYWxseSB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZSBzaW5jZSBuYXRpdmUgYmluZCBpc1xuICogbm93IG1vcmUgcGVyZm9ybWFudCBpbiBtb3N0IGJyb3dzZXJzLCBidXQgcmVtb3ZpbmcgaXQgd291bGQgYmUgYnJlYWtpbmcgZm9yXG4gKiBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvclxuICogYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHBvbHlmaWxsQmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG5cbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG5mdW5jdGlvbiBuYXRpdmVCaW5kIChmbiwgY3R4KSB7XG4gIHJldHVybiBmbi5iaW5kKGN0eClcbn1cblxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICA/IG5hdGl2ZUJpbmRcbiAgOiBwb2x5ZmlsbEJpbmQ7XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKipcbiAqIFJldHVybiBzYW1lIHZhbHVlXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RhdGljIGtleXMgc3RyaW5nIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbnZhciBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJyxcbiAgJ2Vycm9yQ2FwdHVyZWQnXG5dO1xuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgKi9cbiAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSAvW15cXHcuJF0vO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcbnZhciB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG52YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG4vKiAgKi9cblxudmFyIHdhcm4gPSBub29wO1xudmFyIHRpcCA9IG5vb3A7XG52YXIgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IChub29wKTsgLy8gd29yayBhcm91bmQgZmxvdyBjaGVja1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobm9vcCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuXG4gICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5jaWQgIT0gbnVsbFxuICAgICAgPyB2bS5vcHRpb25zXG4gICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICA/IHZtLiRvcHRpb25zIHx8IHZtLmNvbnN0cnVjdG9yLm9wdGlvbnNcbiAgICAgICAgOiB2bSB8fCB7fTtcbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gICAgdmFyIGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cblxudmFyIHVpZCA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gdGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvbmx5IG9uZVxuLy8gd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQgYXQgYW55IHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0IChfdGFyZ2V0KSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7IHRhcmdldFN0YWNrLnB1c2goRGVwLnRhcmdldCk7IH1cbiAgRGVwLnRhcmdldCA9IF90YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFjay5wb3AoKTtcbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zLFxuICBhc3luY0ZhY3Rvcnlcbikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLmVsbSA9IGVsbTtcbiAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5mbkNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuU2NvcGVJZCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbiAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSB0ZXh0O1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1xuXG52YXIgbWV0aG9kc1RvUGF0Y2ggPSBbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dO1xuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5tZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcbiAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cbiAqL1xudmFyIHNob3VsZE9ic2VydmUgPSB0cnVlO1xuXG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XG4gIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvXG4gICAgICA/IHByb3RvQXVnbWVudFxuICAgICAgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlKG9iaiwga2V5c1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBzaG91bGRPYnNlcnZlICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyLFxuICBzaGFsbG93XG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICBpZiAoIWdldHRlciAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFsID0gb2JqW2tleV07XG4gIH1cbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxuICApIHtcbiAgICB3YXJuKChcIkNhbm5vdCBzZXQgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxuICApIHtcbiAgICB3YXJuKChcIkNhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogcGFyZW50VmFsO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkkMSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5JDFdO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUgKG5hbWUpIHtcbiAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICdhbmQgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyLidcbiAgICApO1xuICB9XG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAnaWQ6ICcgKyBuYW1lXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJwcm9wc1xcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShwcm9wcykpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdCAob3B0aW9ucywgdm0pIHtcbiAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoIWluamVjdCkgeyByZXR1cm4gfVxuICB2YXIgbm9ybWFsaXplZCA9IG9wdGlvbnMuaW5qZWN0ID0ge307XG4gIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbmplY3QpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGluamVjdCkge1xuICAgICAgdmFyIHZhbCA9IGluamVjdFtrZXldO1xuICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJpbmplY3RcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUoaW5qZWN0KSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gYm9vbGVhbiBjYXN0aW5nXG4gIHZhciBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgaWYgKGJvb2xlYW5JbmRleCA+IC0xKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSB7XG4gICAgICAvLyBvbmx5IGNhc3QgZW1wdHkgc3RyaW5nIC8gc2FtZSBuYW1lIHRvIGJvb2xlYW4gaWZcbiAgICAgIC8vIGJvb2xlYW4gaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgICAgdmFyIHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZE9ic2VydmUgPSBzaG91bGRPYnNlcnZlO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICB0b2dnbGVPYnNlcnZpbmcocHJldlNob3VsZE9ic2VydmUpO1xuICB9XG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgLy8gc2tpcCB2YWxpZGF0aW9uIGZvciB3ZWV4IHJlY3ljbGUtbGlzdCBjaGlsZCBjb21wb25lbnQgcHJvcHNcbiAgICAhKGZhbHNlICYmIGlzT2JqZWN0KHZhbHVlKSAmJiAoJ0BiaW5kaW5nJyBpbiB2YWx1ZSkpXG4gICkge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgICBcIiBFeHBlY3RlZCBcIiArIChleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpKSArXG4gICAgICBcIiwgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNTYW1lVHlwZSAoYSwgYikge1xuICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKVxufVxuXG5mdW5jdGlvbiBnZXRUeXBlSW5kZXggKHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTFcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwZWN0ZWRUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXNbaV0sIHR5cGUpKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmICh2bSkge1xuICAgIHZhciBjdXIgPSB2bTtcbiAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTWVzc2FnZUNoYW5uZWwgKi9cblxudmFyIGNhbGxiYWNrcyA9IFtdO1xudmFyIHBlbmRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvcGllc1tpXSgpO1xuICB9XG59XG5cbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgYm90aCBtaWNyb3Rhc2tzIGFuZCAobWFjcm8pIHRhc2tzLlxuLy8gSW4gPCAyLjQgd2UgdXNlZCBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGJ1dCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Mgd2hlcmVcbi8vIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwKSBvciBldmVuIGJldHdlZW4gYnViYmxpbmcgb2YgdGhlIHNhbWVcbi8vIGV2ZW50ICgjNjU2NikuIEhvd2V2ZXIsIHVzaW5nIChtYWNybykgdGFza3MgZXZlcnl3aGVyZSBhbHNvIGhhcyBzdWJ0bGUgcHJvYmxlbXNcbi8vIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludCAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEhlcmUgd2UgdXNlIG1pY3JvdGFzayBieSBkZWZhdWx0LCBidXQgZXhwb3NlIGEgd2F5IHRvIGZvcmNlIChtYWNybykgdGFzayB3aGVuXG4vLyBuZWVkZWQgKGUuZy4gaW4gZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgYnkgdi1vbikuXG52YXIgbWljcm9UaW1lckZ1bmM7XG52YXIgbWFjcm9UaW1lckZ1bmM7XG52YXIgdXNlTWFjcm9UYXNrID0gZmFsc2U7XG5cbi8vIERldGVybWluZSAobWFjcm8pIHRhc2sgZGVmZXIgaW1wbGVtZW50YXRpb24uXG4vLyBUZWNobmljYWxseSBzZXRJbW1lZGlhdGUgc2hvdWxkIGJlIHRoZSBpZGVhbCBjaG9pY2UsIGJ1dCBpdCdzIG9ubHkgYXZhaWxhYmxlXG4vLyBpbiBJRS4gVGhlIG9ubHkgcG9seWZpbGwgdGhhdCBjb25zaXN0ZW50bHkgcXVldWVzIHRoZSBjYWxsYmFjayBhZnRlciBhbGwgRE9NXG4vLyBldmVudHMgdHJpZ2dlcmVkIGluIHRoZSBzYW1lIGxvb3AgaXMgYnkgdXNpbmcgTWVzc2FnZUNoYW5uZWwuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICBpc05hdGl2ZShNZXNzYWdlQ2hhbm5lbCkgfHxcbiAgLy8gUGhhbnRvbUpTXG4gIE1lc3NhZ2VDaGFubmVsLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE1lc3NhZ2VDaGFubmVsQ29uc3RydWN0b3JdJ1xuKSkge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICB2YXIgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2hDYWxsYmFja3M7XG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHBvcnQucG9zdE1lc3NhZ2UoMSk7XG4gIH07XG59IGVsc2Uge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcbiAgfTtcbn1cblxuLy8gRGV0ZXJtaW5lIG1pY3JvdGFzayBkZWZlciBpbXBsZW1lbnRhdGlvbi5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0LCAkZmxvdy1kaXNhYmxlLWxpbmUgKi9cbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgbWljcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcC50aGVuKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBmYWxsYmFjayB0byBtYWNyb1xuICBtaWNyb1RpbWVyRnVuYyA9IG1hY3JvVGltZXJGdW5jO1xufVxuXG4vKipcbiAqIFdyYXAgYSBmdW5jdGlvbiBzbyB0aGF0IGlmIGFueSBjb2RlIGluc2lkZSB0cmlnZ2VycyBzdGF0ZSBjaGFuZ2UsXG4gKiB0aGUgY2hhbmdlcyBhcmUgcXVldWVkIHVzaW5nIGEgKG1hY3JvKSB0YXNrIGluc3RlYWQgb2YgYSBtaWNyb3Rhc2suXG4gKi9cbmZ1bmN0aW9uIHdpdGhNYWNyb1Rhc2sgKGZuKSB7XG4gIHJldHVybiBmbi5fd2l0aFRhc2sgfHwgKGZuLl93aXRoVGFzayA9IGZ1bmN0aW9uICgpIHtcbiAgICB1c2VNYWNyb1Rhc2sgPSB0cnVlO1xuICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHVzZU1hY3JvVGFzayA9IGZhbHNlO1xuICAgIHJldHVybiByZXNcbiAgfSlcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgdmFyIF9yZXNvbHZlO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXBlbmRpbmcpIHtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICBpZiAodXNlTWFjcm9UYXNrKSB7XG4gICAgICBtYWNyb1RpbWVyRnVuYygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWNyb1RpbWVyRnVuYygpO1xuICAgIH1cbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXG4gICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb3h5KTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpO1xuICAgIH07XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNsb25lZFtpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGRlZiwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBkZWYgPSBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChcbiAgICBjb21wLl9fZXNNb2R1bGUgfHxcbiAgICAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG4gICkge1xuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgZmFjdG9yeSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIHZhciBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cblxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkuY29udGV4dHMpKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZXh0cyA9IGZhY3RvcnkuY29udGV4dHMgPSBbY29udGV4dF07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZXh0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29udGV4dHNbaV0uJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYocmVzLmNvbXBvbmVudCkgJiYgdHlwZW9mIHJlcy5jb21wb25lbnQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgPyAoXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiKVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4sIG9uY2UpIHtcbiAgaWYgKG9uY2UpIHtcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoZm4pIHtcbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgIHZhciBjYjtcbiAgICAgIHZhciBpJDEgPSBjYnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkkMS0tKSB7XG4gICAgICAgIGNiID0gY2JzW2kkMV07XG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgY2JzLnNwbGljZShpJDEsIDEpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cblxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAvLyByZW1vdmUgc2xvdCBhdHRyaWJ1dGUgaWYgdGhlIG5vZGUgaXMgcmVzb2x2ZWQgYXMgYSBWdWUgc2xvdCBub2RlXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcbiAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgfVxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZm5Db250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgZGF0YSAmJiBkYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBkYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgZm9yICh2YXIgbmFtZSQxIGluIHNsb3RzKSB7XG4gICAgaWYgKHNsb3RzW25hbWUkMV0uZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgICAgZGVsZXRlIHNsb3RzW25hbWUkMV07XG4gICAgfVxuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgcmVzXG4pIHtcbiAgcmVzID0gcmVzIHx8IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZuc1tpXSkpIHtcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhmbnNbaV0sIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1tmbnNbaV0ua2V5XSA9IGZuc1tpXS5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgfVxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcbiAgICAgICAgdm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXG4gICAgICApO1xuICAgICAgLy8gbm8gbmVlZCBmb3IgdGhlIHJlZiBub2RlcyBhZnRlciBpbml0aWFsIHBhdGNoXG4gICAgICAvLyB0aGlzIHByZXZlbnRzIGtlZXBpbmcgYSBkZXRhY2hlZCBET00gdHJlZSBpbiBtZW1vcnkgKCM1ODUxKVxuICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSA9IHZtLiRvcHRpb25zLl9yZWZFbG0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwgbnVsbCwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxuICB2YXIgaGFzQ2hpbGRyZW4gPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcbiAgICB2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0IC8vIGhhcyBvbGQgc2NvcGVkIHNsb3RzXG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcbiAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gIHZtLiRhdHRycyA9IHBhcmVudFZub2RlLmRhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgdmFyIHByb3BPcHRpb25zID0gdm0uJG9wdGlvbnMucHJvcHM7IC8vIHd0ZiBmbG93P1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cblxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcbiAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuXG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChoYXNDaGlsZHJlbikge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGFuZGxlcnNbaV0uY2FsbCh2bSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoaG9vayArIFwiIGhvb2tcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDEgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnMsXG4gIGlzUmVuZGVyV2F0Y2hlclxuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgfVxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDE7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBleHBPckZuLnRvU3RyaW5nKClcbiAgICA6ICcnO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzJDEuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMkMS5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBpZiAoIWlzUm9vdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gIH1cbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxuICAgICAgICAgIGNvbmZpZy5pc1Jlc2VydmVkQXR0cihoeXBoZW5hdGVkS2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGh5cGhlbmF0ZWRLZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcbiAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZShwcm9wcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XG4gIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgcHVzaFRhcmdldCgpO1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9IGZpbmFsbHkge1xuICAgIHBvcFRhcmdldCgpO1xuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXG4gIHZhciBpc1NTUiA9IGlzU2VydmVyUmVuZGVyaW5nKCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBnZXR0ZXIgPT0gbnVsbCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghaXNTU1IpIHtcbiAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIoXG4gICAgICAgIHZtLFxuICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcbiAgICAgICAgbm9vcCxcbiAgICAgICAgY29tcHV0ZWRXYXRjaGVyT3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAoXG4gIHRhcmdldCxcbiAga2V5LFxuICB1c2VyRGVmXG4pIHtcbiAgdmFyIHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICA6IHVzZXJEZWY7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IHVzZXJEZWYuZ2V0XG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0XG4gICAgICA/IHVzZXJEZWYuc2V0XG4gICAgICA6IG5vb3A7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoKGtleSBpbiB2bSkgJiYgaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIFwiICtcbiAgICAgICAgICBcIkF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBoYW5kbGVyLFxuICBvcHRpb25zXG4pIHtcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgcmV0dXJuIHZtLiR3YXRjaChleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdCkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5qZWN0LCBrZXkpLmVudW1lcmFibGVcbiAgICAgIH0pXG4gICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBoYXNPd24oc291cmNlLl9wcm92aWRlZCwgcHJvdmlkZUtleSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGlmICgnZGVmYXVsdCcgaW4gaW5qZWN0W2tleV0pIHtcbiAgICAgICAgICB2YXIgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdHlwZW9mIHByb3ZpZGVEZWZhdWx0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHByb3ZpZGVEZWZhdWx0LmNhbGwodm0pXG4gICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKChcIkluamVjdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbm90IGZvdW5kXCIpLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICB2YWwsXG4gIHJlbmRlclxuKSB7XG4gIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgfVxuICB9XG4gIGlmIChpc0RlZihyZXQpKSB7XG4gICAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgdmFyIG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgbm9kZXMgPSBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2Rlcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdE5vZGVzLl9yZW5kZXJlZCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgICAgXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cIixcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbm9kZXMgPSBzbG90Tm9kZXMgfHwgZmFsbGJhY2s7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5LZXlDb2RlLFxuICBldmVudEtleU5hbWUsXG4gIGJ1aWx0SW5LZXlOYW1lXG4pIHtcbiAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gdHJlZVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbChcbiAgICB0aGlzLl9yZW5kZXJQcm94eSxcbiAgICBudWxsLFxuICAgIHRoaXMgLy8gZm9yIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0ZW1wbGF0ZXNcbiAgKTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgZGF0YSxcbiAgcHJvcHMsXG4gIGNoaWxkcmVuLFxuICBwYXJlbnQsXG4gIEN0b3Jcbikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBjb250ZXh0Vm07XG4gIGlmIChoYXNPd24ocGFyZW50LCAnX3VpZCcpKSB7XG4gICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNvbnRleHQgdm0gcGFzc2VkIGluIGlzIGEgZnVuY3Rpb25hbCBjb250ZXh0IGFzIHdlbGwuXG4gICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgLy8gcmVhbCBjb250ZXh0IGluc3RhbmNlLlxuICAgIGNvbnRleHRWbSA9IHBhcmVudDtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBwYXJlbnQgPSBwYXJlbnQuX29yaWdpbmFsO1xuICB9XG4gIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG5cbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XG4gIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XG4gIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudCk7IH07XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IGRhdGEuc2NvcGVkU2xvdHMgfHwgZW1wdHlPYmplY3Q7XG4gIH1cblxuICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgdmFyIHZub2RlcyA9IG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlKSB8fCBbXTtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucykge1xuICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gIHZhciBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gIGNsb25lLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGlmIChkYXRhLnNsb3QpIHtcbiAgICAoY2xvbmUuZGF0YSB8fCAoY2xvbmUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgfVxuICByZXR1cm4gY2xvbmVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cblxuLy8gUmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBob29rIHRvIHdlZXggbmF0aXZlIHJlbmRlciBlbmdpbmUuXG4vLyBUaGUgaG9vayB3aWxsIGJlIHRyaWdnZXJlZCBieSBuYXRpdmUsIG5vdCBqYXZhc2NyaXB0LlxuXG5cbi8vIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSBjb21wb25lbnQgdG8gd2VleCBuYXRpdmUgcmVuZGVyIGVuZ2luZS5cblxuLyogICovXG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9IYW5rczEwMTAwL3dlZXgtbmF0aXZlLWRpcmVjdGl2ZS90cmVlL21hc3Rlci9jb21wb25lbnRcblxuLy8gbGlzdGVuaW5nIG9uIG5hdGl2ZSBjYWxsYmFja1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAoXG4gICAgdm5vZGUsXG4gICAgaHlkcmF0aW5nLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG1cbiAgKSB7XG4gICAgaWYgKFxuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiZcbiAgICAgICF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQgJiZcbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlXG4gICAgKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLFxuICAgICAgICBwYXJlbnRFbG0sXG4gICAgICAgIHJlZkVsbVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgdmFyIGFzeW5jRmFjdG9yeTtcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IsIGNvbnRleHQpO1xuICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcbiAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxuICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXG4gICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHRhZ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XG5cbiAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgdmFyIHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgZGF0YSA9IHt9O1xuICAgIGlmIChzbG90KSB7XG4gICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgIH1cbiAgfVxuXG4gIC8vIGluc3RhbGwgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcblxuICAvLyBXZWV4IHNwZWNpZmljOiBpbnZva2UgcmVjeWNsZS1saXN0IG9wdGltaXplZCBAcmVuZGVyIGZ1bmN0aW9uIGZvclxuICAvLyBleHRyYWN0aW5nIGNlbGwtc2xvdCB0ZW1wbGF0ZS5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0hhbmtzMTAxMDAvd2VleC1uYXRpdmUtZGlyZWN0aXZlL3RyZWUvbWFzdGVyL2NvbXBvbmVudFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGluc3RhbGxDb21wb25lbnRIb29rcyAoZGF0YSkge1xuICB2YXIgaG9va3MgPSBkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIGhvb2tzW2tleV0gPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAoaXNEZWYob25bZXZlbnRdKSkge1xuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2UgaWYgKGlzRGVmKHZub2RlKSkge1xuICAgIGlmIChpc0RlZihucykpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7IHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoXG4gICAgICAgIGlzVW5kZWYoY2hpbGQubnMpIHx8IChpc1RydWUoZm9yY2UpICYmIGNoaWxkLnRhZyAhPT0gJ3N2ZycpKSkge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyByZWYgIzUzMThcbi8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4vLyA6Y2xhc3MgYXJlIHVzZWQgb24gc2xvdCBub2Rlc1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWVwQmluZGluZ3MgKGRhdGEpIHtcbiAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5zdHlsZSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5jbGFzcyk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIC8vIHJlc2V0IF9yZW5kZXJlZCBmbGFnIG9uIHNsb3RzIGZvciBkdXBsaWNhdGUgc2xvdCBjaGVja1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdm0uJHNsb3RzKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICB2bS4kc2xvdHNba2V5XS5fcmVuZGVyZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX3BhcmVudFZub2RlKSB7XG4gICAgICB2bS4kc2NvcGVkU2xvdHMgPSBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCBlbXB0eU9iamVjdDtcbiAgICB9XG5cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlclwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCQzID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQkMysrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcblxuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgb3B0cy5wcm9wc0RhdGEgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZztcblxuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBleHRlbmRlZCA9IEN0b3IuZXh0ZW5kT3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgZXh0ZW5kZWRba2V5XSwgc2VhbGVkW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gZGVkdXBlIChsYXRlc3QsIGV4dGVuZGVkLCBzZWFsZWQpIHtcbiAgLy8gY29tcGFyZSBsYXRlc3QgYW5kIHNlYWxlZCB0byBlbnN1cmUgbGlmZWN5Y2xlIGhvb2tzIHdvbid0IGJlIGR1cGxpY2F0ZWRcbiAgLy8gYmV0d2VlbiBtZXJnZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBzZWFsZWQgPSBBcnJheS5pc0FycmF5KHNlYWxlZCkgPyBzZWFsZWQgOiBbc2VhbGVkXTtcbiAgICBleHRlbmRlZCA9IEFycmF5LmlzQXJyYXkoZXh0ZW5kZWQpID8gZXh0ZW5kZWQgOiBbZXh0ZW5kZWRdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0ZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBwdXNoIG9yaWdpbmFsIG9wdGlvbnMgYW5kIG5vdCBzZWFsZWQgb3B0aW9ucyB0byBleGNsdWRlIGR1cGxpY2F0ZWQgb3B0aW9uc1xuICAgICAgaWYgKGV4dGVuZGVkLmluZGV4T2YobGF0ZXN0W2ldKSA+PSAwIHx8IHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XG4gICAgICAgIHJlcy5wdXNoKGxhdGVzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGF0ZXN0XG4gIH1cbn1cblxuZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbnJlbmRlck1peGluKFZ1ZSk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xuICB2YXIgY2FjaGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5jYWNoZTtcbiAgdmFyIGtleXMgPSBrZWVwQWxpdmVJbnN0YW5jZS5rZXlzO1xuICB2YXIgX3Zub2RlID0ga2VlcEFsaXZlSW5zdGFuY2UuX3Zub2RlO1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcbiAgY2FjaGUsXG4gIGtleSxcbiAga2V5cyxcbiAgY3VycmVudFxuKSB7XG4gIHZhciBjYWNoZWQkJDEgPSBjYWNoZVtrZXldO1xuICBpZiAoY2FjaGVkJCQxICYmICghY3VycmVudCB8fCBjYWNoZWQkJDEudGFnICE9PSBjdXJyZW50LnRhZykpIHtcbiAgICBjYWNoZWQkJDEuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxuICBjYWNoZVtrZXldID0gbnVsbDtcbiAgcmVtb3ZlKGtleXMsIGtleSk7XG59XG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5rZXlzID0gW107XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMkMS5jYWNoZSwga2V5LCB0aGlzJDEua2V5cyk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG5cbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYkMS5jYWNoZTtcbiAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgfVxufVxuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmVcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgfVxufSk7XG5cbi8vIGV4cG9zZSBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCBmb3Igc3NyIHJ1bnRpbWUgaGVscGVyIGluc3RhbGxhdGlvblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ0Z1bmN0aW9uYWxSZW5kZXJDb250ZXh0Jywge1xuICB2YWx1ZTogRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcbn0pO1xuXG5WdWUudmVyc2lvbiA9ICcyLjUuMTcnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgc3RhdGljQ2xhc3MsXG4gIGR5bmFtaWNDbGFzc1xuKSB7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBzdHJpbmdpZmllZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxuXG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZVNjb3BlIChub2RlLCBzY29wZUlkKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcbn1cblxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcblx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cdHNldFN0eWxlU2NvcGU6IHNldFN0eWxlU2NvcGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWlzRGVmKGtleSkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFpblZQcmUgJiZcbiAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgIShcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgIH0pXG4gICAgICApICYmXG4gICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgKVxuICB9XG5cbiAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcblxuICBmdW5jdGlvbiBjcmVhdGVFbG0gKFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtLFxuICAgIG5lc3RlZCxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4XG4gICkge1xuICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAvLyBUaGlzIHZub2RlIHdhcyB1c2VkIGluIGEgcHJldmlvdXMgcmVuZGVyIVxuICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXG4gICAgICAvLyBwb3RlbnRpYWwgcGF0Y2ggZXJyb3JzIGRvd24gdGhlIHJvYWQgd2hlbiBpdCdzIHVzZWQgYXMgYW4gaW5zZXJ0aW9uXG4gICAgICAvLyByZWZlcmVuY2Ugbm9kZS4gSW5zdGVhZCwgd2UgY2xvbmUgdGhlIG5vZGUgb24tZGVtYW5kIGJlZm9yZSBjcmVhdGluZ1xuICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKHJlZiQkMS5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgdm5vZGVUb01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKG5ld0NoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSlcbiAgICAgICAgICA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XVxuICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGVUb01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgaWYgKHNhbWVWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xuICAgIHZhciBzZWVuS2V5cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2bm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleTtcbiAgICAgIGlmIChpc0RlZihrZXkpKSB7XG4gICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIChcIkR1cGxpY2F0ZSBrZXlzIGRldGVjdGVkOiAnXCIgKyBrZXkgKyBcIicuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5cIiksXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIGMgPSBvbGRDaFtpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgIHZhciBpO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcbiAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBhc3NlcnQgbm9kZSBtYXRjaFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YSkgJiYgaXNEZWYoaSA9IGkuZG9tUHJvcHMpICYmIGlzRGVmKGkgPSBpLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgdmFyIGZ1bGxJbnZva2UgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZnVsbEludm9rZSAmJiBkYXRhWydjbGFzcyddKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUsIGluVlByZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fCAoXG4gICAgICAgICFpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBpblZQcmUpICYmXG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0kMSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgbm9kZVxuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtJDEsXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXG4gICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cbiAgICAgICAgICAgICAgdmFyIGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgaW5zZXJ0LmZucy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2kkMl0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCAoXCJkaXJlY3RpdmUgXCIgKyAoZGlyLm5hbWUpICsgXCIgXCIgKyBob29rICsgXCIgaG9va1wiKSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dXG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcbiAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgOiBrZXk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZVNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICB9IGVsc2Uge1xuICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgLy8gPHRleHRhcmVhPi4uLiBibG9jayB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYW5kIHJlbW92ZSB0aGUgYmxvY2tlclxuICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXG4gICAgICBrZXkgPT09ICdwbGFjZWhvbGRlcicgJiYgIWVsLl9faWVwaFxuICAgICkge1xuICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgfTtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5cblxuXG5cblxuXG5cblxuLy8gYWRkIGEgcmF3IGF0dHIgKHVzZSB0aGlzIGluIHByZVRyYW5zZm9ybXMpXG5cblxuXG5cblxuXG5cblxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cblxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5cbi8qICAqL1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICB2YXIgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAvLyBhZnRlciAyLjUuIEtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBnZW5lcmF0ZWQgY29kZSBmcm9tIDwgMi40XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyIChoYW5kbGVyLCBldmVudCwgY2FwdHVyZSkge1xuICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgIHZhciByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkJDEgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgb25jZSQkMSxcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIGhhbmRsZXIgPSB3aXRoTWFjcm9UYXNrKGhhbmRsZXIpO1xuICBpZiAob25jZSQkMSkgeyBoYW5kbGVyID0gY3JlYXRlT25jZUhhbmRsZXIoaGFuZGxlciwgZXZlbnQsIGNhcHR1cmUpOyB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgZXZlbnQsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgZXZlbnQsXG4gICAgaGFuZGxlci5fd2l0aFRhc2sgfHwgaGFuZGxlcixcbiAgICBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcbiAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKGlzVW5kZWYocHJvcHNba2V5XSkpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgICAvLyAjNjYwMSB3b3JrIGFyb3VuZCBDaHJvbWUgdmVyc2lvbiA8PSA1NSBidWcgd2hlcmUgc2luZ2xlIHRleHROb2RlXG4gICAgICAvLyByZXBsYWNlZCBieSBpbm5lckhUTUwvdGV4dENvbnRlbnQgcmV0YWlucyBpdHMgcGFyZW50Tm9kZSBwcm9wZXJ0eVxuICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xuICAgIGlmIChtb2RpZmllcnMubGF6eSkge1xuICAgICAgLy8gaW5wdXRzIHdpdGggbGF6eSBzaG91bGQgb25seSBiZSB1cGRhdGVkIHdoZW4gbm90IGluIGZvY3VzXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufVxuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoXG4gICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSlcbiAgICAgICkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn1cblxuLyogICovXG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgY3VyID0gY3VyLnRyaW0oKTtcbiAgICBpZiAoY3VyKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZikge1xuICBpZiAoIWRlZikge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZi5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgfVxufSk7XG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlclxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgOiBzZXRUaW1lb3V0XG4gIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcbiAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge31cblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXVxuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgZGlyZWN0aXZlID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gIzY5MDNcbiAgICAgIGlmIChvbGRWbm9kZS5lbG0gJiYgIW9sZFZub2RlLmVsbS5fdk9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICB2YXIgY3VyT3B0aW9ucyA9IGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICAgIGlmIChjdXJPcHRpb25zLnNvbWUoZnVuY3Rpb24gKG8sIGkpIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zW2ldKTsgfSkpIHtcbiAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcbiAgICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXG4gICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9ucyk7XG4gICAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSlcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBkaXJlY3RpdmUsXG4gIHNob3c6IHNob3dcbn1cblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG4vLyBzdXBwb3J0cyB0cmFuc2l0aW9uIG1vZGUgKG91dC1pbiAvIGluLW91dClcblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcbiAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlICgpIHtcbiAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICB0aGlzLl92bm9kZSxcbiAgICAgIHRoaXMua2VwdCxcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICk7XG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdGhpcy5fcmVmbG93ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn1cblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaW5Ccm93c2VyKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICBpc0Nocm9tZVxuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgKTtcbiAgICB9XG4gIH0sIDApO1xufVxuXG4vKiAgKi9cblxuZXhwb3J0IGRlZmF1bHQgVnVlO1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsIGV2YWwpKFwidGhpc1wiKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltZ3MvZmJhNzM0ZTBhNDMwNmRmM2U5Nzk5OTc2MTEzNTFjNDkuanBnXCI7IiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1ncy8wNDkwOTcxZGM4YTI4MzkxYTY5ZjExNDc1NTI5OGRhYy5qcGdcIjsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWdzL2I5OWM3NjY0NjMxYzEzMDhjODRiYTk5OTY0NDcyOWE1LmpwZ1wiOyIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltZ3MvOWFlYTkzZjFjM2NiMTg0MDRiOWM0NGJhMGFhMzZiZGUuanBnXCI7IiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1ncy82NTFmMjdmMzIxMjQ2MTYzZjZiY2Q0MzNlMzZkYmE1OS5qcGdcIjsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWdzLzY5MTA2ZDMzZjlmMjk4ZmJhNmM4YWQ5YTc5ODlhMmQ4LmpwZ1wiOyIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltZ3MvZjc0ZmRkMWM5MzgxMWNjZWNhMGM4MzEyODMwMGI4YTYuanBnXCI7IiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1ncy8xMGRhN2Y4ZmI5NDNmNGM0MzY3MGU1Zjc3NmEyMzNjMy5qcGdcIjsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWdzLzAyMTQwYzNhNjFmYjY4NTVlYzNjZTAzOGZlNWVmNjc0LmpwZ1wiOyIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltZ3MvYWE0OTBjMmIzNTY2MDc1YTYzZThjNjMzMTY1N2RjNmUuanBnXCI7IiwiaW1wb3J0IFZ1ZSBmcm9tIFwidnVlXCI7XHJcbmltcG9ydCBJbmRleCBmcm9tIFwiLi9pbmRleC52dWVcIjtcclxuXHJcbm5ldyBWdWUoe1xyXG4gICAgZWw6IFwiI2FwcFwiLFxyXG4gICAgY29tcG9uZW50czoge0luZGV4fSxcclxuICAgIHJlbmRlciAoaCkge1xyXG4gICAgICByZXR1cm4gaCgnSW5kZXgnKVxyXG4gICAgfVxyXG59KTsiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL2luZGV4LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD00YTQ5ZmFiNyZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL2luZGV4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9pbmRleC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPXNjc3MmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIi9Vc2Vycy9vdXdlaS9EZXNrdG9wL0FQb3B1cHMtR2FsbGVyeS1EZW1vL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGkvZGlzdC9pbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCc0YTQ5ZmFiNycsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCc0YTQ5ZmFiNycsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTRhNDlmYWI3JlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzRhNDlmYWI3Jywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJpbmRleC9pbmRleC52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMy0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1zY3NzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0zLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9pbmRleC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPXNjc3MmXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTRhNDlmYWI3JlwiIl0sInNvdXJjZVJvb3QiOiIifQ==